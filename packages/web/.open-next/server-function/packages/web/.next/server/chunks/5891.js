exports.id = 5891;
exports.ids = [5891];
exports.modules = {

/***/ 69134:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CognitoIdentityProvider = void 0;
const smithy_client_1 = __webpack_require__(18851);
const CognitoIdentityProviderClient_1 = __webpack_require__(85228);
const AddCustomAttributesCommand_1 = __webpack_require__(64502);
const AdminAddUserToGroupCommand_1 = __webpack_require__(66892);
const AdminConfirmSignUpCommand_1 = __webpack_require__(36341);
const AdminCreateUserCommand_1 = __webpack_require__(84037);
const AdminDeleteUserAttributesCommand_1 = __webpack_require__(34324);
const AdminDeleteUserCommand_1 = __webpack_require__(85870);
const AdminDisableProviderForUserCommand_1 = __webpack_require__(27958);
const AdminDisableUserCommand_1 = __webpack_require__(39730);
const AdminEnableUserCommand_1 = __webpack_require__(66516);
const AdminForgetDeviceCommand_1 = __webpack_require__(11040);
const AdminGetDeviceCommand_1 = __webpack_require__(49148);
const AdminGetUserCommand_1 = __webpack_require__(30824);
const AdminInitiateAuthCommand_1 = __webpack_require__(6470);
const AdminLinkProviderForUserCommand_1 = __webpack_require__(97909);
const AdminListDevicesCommand_1 = __webpack_require__(94207);
const AdminListGroupsForUserCommand_1 = __webpack_require__(55328);
const AdminListUserAuthEventsCommand_1 = __webpack_require__(21606);
const AdminRemoveUserFromGroupCommand_1 = __webpack_require__(19006);
const AdminResetUserPasswordCommand_1 = __webpack_require__(900);
const AdminRespondToAuthChallengeCommand_1 = __webpack_require__(47702);
const AdminSetUserMFAPreferenceCommand_1 = __webpack_require__(4844);
const AdminSetUserPasswordCommand_1 = __webpack_require__(53479);
const AdminSetUserSettingsCommand_1 = __webpack_require__(18955);
const AdminUpdateAuthEventFeedbackCommand_1 = __webpack_require__(70499);
const AdminUpdateDeviceStatusCommand_1 = __webpack_require__(49981);
const AdminUpdateUserAttributesCommand_1 = __webpack_require__(41849);
const AdminUserGlobalSignOutCommand_1 = __webpack_require__(83344);
const AssociateSoftwareTokenCommand_1 = __webpack_require__(91999);
const ChangePasswordCommand_1 = __webpack_require__(6049);
const ConfirmDeviceCommand_1 = __webpack_require__(70622);
const ConfirmForgotPasswordCommand_1 = __webpack_require__(19272);
const ConfirmSignUpCommand_1 = __webpack_require__(60368);
const CreateGroupCommand_1 = __webpack_require__(31788);
const CreateIdentityProviderCommand_1 = __webpack_require__(13492);
const CreateResourceServerCommand_1 = __webpack_require__(92984);
const CreateUserImportJobCommand_1 = __webpack_require__(22510);
const CreateUserPoolClientCommand_1 = __webpack_require__(53173);
const CreateUserPoolCommand_1 = __webpack_require__(35451);
const CreateUserPoolDomainCommand_1 = __webpack_require__(57509);
const DeleteGroupCommand_1 = __webpack_require__(486);
const DeleteIdentityProviderCommand_1 = __webpack_require__(93150);
const DeleteResourceServerCommand_1 = __webpack_require__(29456);
const DeleteUserAttributesCommand_1 = __webpack_require__(77643);
const DeleteUserCommand_1 = __webpack_require__(85207);
const DeleteUserPoolClientCommand_1 = __webpack_require__(96418);
const DeleteUserPoolCommand_1 = __webpack_require__(87108);
const DeleteUserPoolDomainCommand_1 = __webpack_require__(46084);
const DescribeIdentityProviderCommand_1 = __webpack_require__(73972);
const DescribeResourceServerCommand_1 = __webpack_require__(46139);
const DescribeRiskConfigurationCommand_1 = __webpack_require__(54779);
const DescribeUserImportJobCommand_1 = __webpack_require__(71992);
const DescribeUserPoolClientCommand_1 = __webpack_require__(68420);
const DescribeUserPoolCommand_1 = __webpack_require__(75913);
const DescribeUserPoolDomainCommand_1 = __webpack_require__(48684);
const ForgetDeviceCommand_1 = __webpack_require__(33174);
const ForgotPasswordCommand_1 = __webpack_require__(60474);
const GetCSVHeaderCommand_1 = __webpack_require__(34957);
const GetDeviceCommand_1 = __webpack_require__(88362);
const GetGroupCommand_1 = __webpack_require__(88960);
const GetIdentityProviderByIdentifierCommand_1 = __webpack_require__(97790);
const GetLogDeliveryConfigurationCommand_1 = __webpack_require__(67417);
const GetSigningCertificateCommand_1 = __webpack_require__(65580);
const GetUICustomizationCommand_1 = __webpack_require__(26482);
const GetUserAttributeVerificationCodeCommand_1 = __webpack_require__(86502);
const GetUserCommand_1 = __webpack_require__(22294);
const GetUserPoolMfaConfigCommand_1 = __webpack_require__(9084);
const GlobalSignOutCommand_1 = __webpack_require__(14524);
const InitiateAuthCommand_1 = __webpack_require__(97494);
const ListDevicesCommand_1 = __webpack_require__(20131);
const ListGroupsCommand_1 = __webpack_require__(19010);
const ListIdentityProvidersCommand_1 = __webpack_require__(40247);
const ListResourceServersCommand_1 = __webpack_require__(67716);
const ListTagsForResourceCommand_1 = __webpack_require__(53519);
const ListUserImportJobsCommand_1 = __webpack_require__(68786);
const ListUserPoolClientsCommand_1 = __webpack_require__(48532);
const ListUserPoolsCommand_1 = __webpack_require__(42083);
const ListUsersCommand_1 = __webpack_require__(60086);
const ListUsersInGroupCommand_1 = __webpack_require__(27102);
const ResendConfirmationCodeCommand_1 = __webpack_require__(67520);
const RespondToAuthChallengeCommand_1 = __webpack_require__(59539);
const RevokeTokenCommand_1 = __webpack_require__(51011);
const SetLogDeliveryConfigurationCommand_1 = __webpack_require__(48124);
const SetRiskConfigurationCommand_1 = __webpack_require__(67422);
const SetUICustomizationCommand_1 = __webpack_require__(83812);
const SetUserMFAPreferenceCommand_1 = __webpack_require__(22853);
const SetUserPoolMfaConfigCommand_1 = __webpack_require__(12417);
const SetUserSettingsCommand_1 = __webpack_require__(72598);
const SignUpCommand_1 = __webpack_require__(80766);
const StartUserImportJobCommand_1 = __webpack_require__(45449);
const StopUserImportJobCommand_1 = __webpack_require__(54443);
const TagResourceCommand_1 = __webpack_require__(57095);
const UntagResourceCommand_1 = __webpack_require__(90036);
const UpdateAuthEventFeedbackCommand_1 = __webpack_require__(64386);
const UpdateDeviceStatusCommand_1 = __webpack_require__(48996);
const UpdateGroupCommand_1 = __webpack_require__(3265);
const UpdateIdentityProviderCommand_1 = __webpack_require__(54409);
const UpdateResourceServerCommand_1 = __webpack_require__(67223);
const UpdateUserAttributesCommand_1 = __webpack_require__(83973);
const UpdateUserPoolClientCommand_1 = __webpack_require__(48505);
const UpdateUserPoolCommand_1 = __webpack_require__(37871);
const UpdateUserPoolDomainCommand_1 = __webpack_require__(80659);
const VerifySoftwareTokenCommand_1 = __webpack_require__(66249);
const VerifyUserAttributeCommand_1 = __webpack_require__(17584);
const commands = {
    AddCustomAttributesCommand: AddCustomAttributesCommand_1.AddCustomAttributesCommand,
    AdminAddUserToGroupCommand: AdminAddUserToGroupCommand_1.AdminAddUserToGroupCommand,
    AdminConfirmSignUpCommand: AdminConfirmSignUpCommand_1.AdminConfirmSignUpCommand,
    AdminCreateUserCommand: AdminCreateUserCommand_1.AdminCreateUserCommand,
    AdminDeleteUserCommand: AdminDeleteUserCommand_1.AdminDeleteUserCommand,
    AdminDeleteUserAttributesCommand: AdminDeleteUserAttributesCommand_1.AdminDeleteUserAttributesCommand,
    AdminDisableProviderForUserCommand: AdminDisableProviderForUserCommand_1.AdminDisableProviderForUserCommand,
    AdminDisableUserCommand: AdminDisableUserCommand_1.AdminDisableUserCommand,
    AdminEnableUserCommand: AdminEnableUserCommand_1.AdminEnableUserCommand,
    AdminForgetDeviceCommand: AdminForgetDeviceCommand_1.AdminForgetDeviceCommand,
    AdminGetDeviceCommand: AdminGetDeviceCommand_1.AdminGetDeviceCommand,
    AdminGetUserCommand: AdminGetUserCommand_1.AdminGetUserCommand,
    AdminInitiateAuthCommand: AdminInitiateAuthCommand_1.AdminInitiateAuthCommand,
    AdminLinkProviderForUserCommand: AdminLinkProviderForUserCommand_1.AdminLinkProviderForUserCommand,
    AdminListDevicesCommand: AdminListDevicesCommand_1.AdminListDevicesCommand,
    AdminListGroupsForUserCommand: AdminListGroupsForUserCommand_1.AdminListGroupsForUserCommand,
    AdminListUserAuthEventsCommand: AdminListUserAuthEventsCommand_1.AdminListUserAuthEventsCommand,
    AdminRemoveUserFromGroupCommand: AdminRemoveUserFromGroupCommand_1.AdminRemoveUserFromGroupCommand,
    AdminResetUserPasswordCommand: AdminResetUserPasswordCommand_1.AdminResetUserPasswordCommand,
    AdminRespondToAuthChallengeCommand: AdminRespondToAuthChallengeCommand_1.AdminRespondToAuthChallengeCommand,
    AdminSetUserMFAPreferenceCommand: AdminSetUserMFAPreferenceCommand_1.AdminSetUserMFAPreferenceCommand,
    AdminSetUserPasswordCommand: AdminSetUserPasswordCommand_1.AdminSetUserPasswordCommand,
    AdminSetUserSettingsCommand: AdminSetUserSettingsCommand_1.AdminSetUserSettingsCommand,
    AdminUpdateAuthEventFeedbackCommand: AdminUpdateAuthEventFeedbackCommand_1.AdminUpdateAuthEventFeedbackCommand,
    AdminUpdateDeviceStatusCommand: AdminUpdateDeviceStatusCommand_1.AdminUpdateDeviceStatusCommand,
    AdminUpdateUserAttributesCommand: AdminUpdateUserAttributesCommand_1.AdminUpdateUserAttributesCommand,
    AdminUserGlobalSignOutCommand: AdminUserGlobalSignOutCommand_1.AdminUserGlobalSignOutCommand,
    AssociateSoftwareTokenCommand: AssociateSoftwareTokenCommand_1.AssociateSoftwareTokenCommand,
    ChangePasswordCommand: ChangePasswordCommand_1.ChangePasswordCommand,
    ConfirmDeviceCommand: ConfirmDeviceCommand_1.ConfirmDeviceCommand,
    ConfirmForgotPasswordCommand: ConfirmForgotPasswordCommand_1.ConfirmForgotPasswordCommand,
    ConfirmSignUpCommand: ConfirmSignUpCommand_1.ConfirmSignUpCommand,
    CreateGroupCommand: CreateGroupCommand_1.CreateGroupCommand,
    CreateIdentityProviderCommand: CreateIdentityProviderCommand_1.CreateIdentityProviderCommand,
    CreateResourceServerCommand: CreateResourceServerCommand_1.CreateResourceServerCommand,
    CreateUserImportJobCommand: CreateUserImportJobCommand_1.CreateUserImportJobCommand,
    CreateUserPoolCommand: CreateUserPoolCommand_1.CreateUserPoolCommand,
    CreateUserPoolClientCommand: CreateUserPoolClientCommand_1.CreateUserPoolClientCommand,
    CreateUserPoolDomainCommand: CreateUserPoolDomainCommand_1.CreateUserPoolDomainCommand,
    DeleteGroupCommand: DeleteGroupCommand_1.DeleteGroupCommand,
    DeleteIdentityProviderCommand: DeleteIdentityProviderCommand_1.DeleteIdentityProviderCommand,
    DeleteResourceServerCommand: DeleteResourceServerCommand_1.DeleteResourceServerCommand,
    DeleteUserCommand: DeleteUserCommand_1.DeleteUserCommand,
    DeleteUserAttributesCommand: DeleteUserAttributesCommand_1.DeleteUserAttributesCommand,
    DeleteUserPoolCommand: DeleteUserPoolCommand_1.DeleteUserPoolCommand,
    DeleteUserPoolClientCommand: DeleteUserPoolClientCommand_1.DeleteUserPoolClientCommand,
    DeleteUserPoolDomainCommand: DeleteUserPoolDomainCommand_1.DeleteUserPoolDomainCommand,
    DescribeIdentityProviderCommand: DescribeIdentityProviderCommand_1.DescribeIdentityProviderCommand,
    DescribeResourceServerCommand: DescribeResourceServerCommand_1.DescribeResourceServerCommand,
    DescribeRiskConfigurationCommand: DescribeRiskConfigurationCommand_1.DescribeRiskConfigurationCommand,
    DescribeUserImportJobCommand: DescribeUserImportJobCommand_1.DescribeUserImportJobCommand,
    DescribeUserPoolCommand: DescribeUserPoolCommand_1.DescribeUserPoolCommand,
    DescribeUserPoolClientCommand: DescribeUserPoolClientCommand_1.DescribeUserPoolClientCommand,
    DescribeUserPoolDomainCommand: DescribeUserPoolDomainCommand_1.DescribeUserPoolDomainCommand,
    ForgetDeviceCommand: ForgetDeviceCommand_1.ForgetDeviceCommand,
    ForgotPasswordCommand: ForgotPasswordCommand_1.ForgotPasswordCommand,
    GetCSVHeaderCommand: GetCSVHeaderCommand_1.GetCSVHeaderCommand,
    GetDeviceCommand: GetDeviceCommand_1.GetDeviceCommand,
    GetGroupCommand: GetGroupCommand_1.GetGroupCommand,
    GetIdentityProviderByIdentifierCommand: GetIdentityProviderByIdentifierCommand_1.GetIdentityProviderByIdentifierCommand,
    GetLogDeliveryConfigurationCommand: GetLogDeliveryConfigurationCommand_1.GetLogDeliveryConfigurationCommand,
    GetSigningCertificateCommand: GetSigningCertificateCommand_1.GetSigningCertificateCommand,
    GetUICustomizationCommand: GetUICustomizationCommand_1.GetUICustomizationCommand,
    GetUserCommand: GetUserCommand_1.GetUserCommand,
    GetUserAttributeVerificationCodeCommand: GetUserAttributeVerificationCodeCommand_1.GetUserAttributeVerificationCodeCommand,
    GetUserPoolMfaConfigCommand: GetUserPoolMfaConfigCommand_1.GetUserPoolMfaConfigCommand,
    GlobalSignOutCommand: GlobalSignOutCommand_1.GlobalSignOutCommand,
    InitiateAuthCommand: InitiateAuthCommand_1.InitiateAuthCommand,
    ListDevicesCommand: ListDevicesCommand_1.ListDevicesCommand,
    ListGroupsCommand: ListGroupsCommand_1.ListGroupsCommand,
    ListIdentityProvidersCommand: ListIdentityProvidersCommand_1.ListIdentityProvidersCommand,
    ListResourceServersCommand: ListResourceServersCommand_1.ListResourceServersCommand,
    ListTagsForResourceCommand: ListTagsForResourceCommand_1.ListTagsForResourceCommand,
    ListUserImportJobsCommand: ListUserImportJobsCommand_1.ListUserImportJobsCommand,
    ListUserPoolClientsCommand: ListUserPoolClientsCommand_1.ListUserPoolClientsCommand,
    ListUserPoolsCommand: ListUserPoolsCommand_1.ListUserPoolsCommand,
    ListUsersCommand: ListUsersCommand_1.ListUsersCommand,
    ListUsersInGroupCommand: ListUsersInGroupCommand_1.ListUsersInGroupCommand,
    ResendConfirmationCodeCommand: ResendConfirmationCodeCommand_1.ResendConfirmationCodeCommand,
    RespondToAuthChallengeCommand: RespondToAuthChallengeCommand_1.RespondToAuthChallengeCommand,
    RevokeTokenCommand: RevokeTokenCommand_1.RevokeTokenCommand,
    SetLogDeliveryConfigurationCommand: SetLogDeliveryConfigurationCommand_1.SetLogDeliveryConfigurationCommand,
    SetRiskConfigurationCommand: SetRiskConfigurationCommand_1.SetRiskConfigurationCommand,
    SetUICustomizationCommand: SetUICustomizationCommand_1.SetUICustomizationCommand,
    SetUserMFAPreferenceCommand: SetUserMFAPreferenceCommand_1.SetUserMFAPreferenceCommand,
    SetUserPoolMfaConfigCommand: SetUserPoolMfaConfigCommand_1.SetUserPoolMfaConfigCommand,
    SetUserSettingsCommand: SetUserSettingsCommand_1.SetUserSettingsCommand,
    SignUpCommand: SignUpCommand_1.SignUpCommand,
    StartUserImportJobCommand: StartUserImportJobCommand_1.StartUserImportJobCommand,
    StopUserImportJobCommand: StopUserImportJobCommand_1.StopUserImportJobCommand,
    TagResourceCommand: TagResourceCommand_1.TagResourceCommand,
    UntagResourceCommand: UntagResourceCommand_1.UntagResourceCommand,
    UpdateAuthEventFeedbackCommand: UpdateAuthEventFeedbackCommand_1.UpdateAuthEventFeedbackCommand,
    UpdateDeviceStatusCommand: UpdateDeviceStatusCommand_1.UpdateDeviceStatusCommand,
    UpdateGroupCommand: UpdateGroupCommand_1.UpdateGroupCommand,
    UpdateIdentityProviderCommand: UpdateIdentityProviderCommand_1.UpdateIdentityProviderCommand,
    UpdateResourceServerCommand: UpdateResourceServerCommand_1.UpdateResourceServerCommand,
    UpdateUserAttributesCommand: UpdateUserAttributesCommand_1.UpdateUserAttributesCommand,
    UpdateUserPoolCommand: UpdateUserPoolCommand_1.UpdateUserPoolCommand,
    UpdateUserPoolClientCommand: UpdateUserPoolClientCommand_1.UpdateUserPoolClientCommand,
    UpdateUserPoolDomainCommand: UpdateUserPoolDomainCommand_1.UpdateUserPoolDomainCommand,
    VerifySoftwareTokenCommand: VerifySoftwareTokenCommand_1.VerifySoftwareTokenCommand,
    VerifyUserAttributeCommand: VerifyUserAttributeCommand_1.VerifyUserAttributeCommand
};
class CognitoIdentityProvider extends CognitoIdentityProviderClient_1.CognitoIdentityProviderClient {
}
exports.CognitoIdentityProvider = CognitoIdentityProvider;
(0, smithy_client_1.createAggregatedClient)(commands, CognitoIdentityProvider);


/***/ }),

/***/ 85228:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CognitoIdentityProviderClient = exports.__Client = void 0;
const middleware_host_header_1 = __webpack_require__(23496);
const middleware_logger_1 = __webpack_require__(25791);
const middleware_recursion_detection_1 = __webpack_require__(86548);
const middleware_signing_1 = __webpack_require__(73129);
const middleware_user_agent_1 = __webpack_require__(71886);
const config_resolver_1 = __webpack_require__(25708);
const middleware_content_length_1 = __webpack_require__(32636);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_retry_1 = __webpack_require__(75567);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "__Client", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Client;
    }
}));
const EndpointParameters_1 = __webpack_require__(55396);
const runtimeConfig_1 = __webpack_require__(86308);
const runtimeExtensions_1 = __webpack_require__(82201);
class CognitoIdentityProviderClient extends smithy_client_1.Client {
    constructor(...[configuration]){
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration || {});
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_signing_1.resolveAwsAuthConfig)(_config_5);
        const _config_7 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_6);
        const _config_8 = (0, runtimeExtensions_1.resolveRuntimeExtensions)(_config_7, configuration?.extensions || []);
        super(_config_8);
        this.config = _config_8;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.CognitoIdentityProviderClient = CognitoIdentityProviderClient;


/***/ }),

/***/ 64502:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AddCustomAttributesCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class AddCustomAttributesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AddCustomAttributesCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AddCustomAttributesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AddCustomAttributesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AddCustomAttributesCommand)(output, context);
    }
}
exports.AddCustomAttributesCommand = AddCustomAttributesCommand;


/***/ }),

/***/ 66892:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminAddUserToGroupCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminAddUserToGroupCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminAddUserToGroupCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminAddUserToGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminAddUserToGroupRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminAddUserToGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminAddUserToGroupCommand)(output, context);
    }
}
exports.AdminAddUserToGroupCommand = AdminAddUserToGroupCommand;


/***/ }),

/***/ 36341:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminConfirmSignUpCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminConfirmSignUpCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminConfirmSignUpCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminConfirmSignUpCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminConfirmSignUpRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminConfirmSignUpCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminConfirmSignUpCommand)(output, context);
    }
}
exports.AdminConfirmSignUpCommand = AdminConfirmSignUpCommand;


/***/ }),

/***/ 84037:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminCreateUserCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminCreateUserCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminCreateUserCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminCreateUserCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminCreateUserRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.AdminCreateUserResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminCreateUserCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminCreateUserCommand)(output, context);
    }
}
exports.AdminCreateUserCommand = AdminCreateUserCommand;


/***/ }),

/***/ 34324:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminDeleteUserAttributesCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminDeleteUserAttributesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminDeleteUserAttributesCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminDeleteUserAttributesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminDeleteUserAttributesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminDeleteUserAttributesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminDeleteUserAttributesCommand)(output, context);
    }
}
exports.AdminDeleteUserAttributesCommand = AdminDeleteUserAttributesCommand;


/***/ }),

/***/ 85870:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminDeleteUserCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminDeleteUserCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminDeleteUserCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminDeleteUserCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminDeleteUserRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminDeleteUserCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminDeleteUserCommand)(output, context);
    }
}
exports.AdminDeleteUserCommand = AdminDeleteUserCommand;


/***/ }),

/***/ 27958:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminDisableProviderForUserCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminDisableProviderForUserCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminDisableProviderForUserCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminDisableProviderForUserCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminDisableProviderForUserCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminDisableProviderForUserCommand)(output, context);
    }
}
exports.AdminDisableProviderForUserCommand = AdminDisableProviderForUserCommand;


/***/ }),

/***/ 39730:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminDisableUserCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminDisableUserCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminDisableUserCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminDisableUserCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminDisableUserRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminDisableUserCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminDisableUserCommand)(output, context);
    }
}
exports.AdminDisableUserCommand = AdminDisableUserCommand;


/***/ }),

/***/ 66516:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminEnableUserCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminEnableUserCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminEnableUserCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminEnableUserCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminEnableUserRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminEnableUserCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminEnableUserCommand)(output, context);
    }
}
exports.AdminEnableUserCommand = AdminEnableUserCommand;


/***/ }),

/***/ 11040:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminForgetDeviceCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminForgetDeviceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminForgetDeviceCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminForgetDeviceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminForgetDeviceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminForgetDeviceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminForgetDeviceCommand)(output, context);
    }
}
exports.AdminForgetDeviceCommand = AdminForgetDeviceCommand;


/***/ }),

/***/ 49148:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminGetDeviceCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminGetDeviceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminGetDeviceCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminGetDeviceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminGetDeviceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.AdminGetDeviceResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminGetDeviceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminGetDeviceCommand)(output, context);
    }
}
exports.AdminGetDeviceCommand = AdminGetDeviceCommand;


/***/ }),

/***/ 30824:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminGetUserCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminGetUserCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminGetUserCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminGetUserCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminGetUserRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.AdminGetUserResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminGetUserCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminGetUserCommand)(output, context);
    }
}
exports.AdminGetUserCommand = AdminGetUserCommand;


/***/ }),

/***/ 6470:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminInitiateAuthCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminInitiateAuthCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminInitiateAuthCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminInitiateAuthCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminInitiateAuthRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.AdminInitiateAuthResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminInitiateAuthCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminInitiateAuthCommand)(output, context);
    }
}
exports.AdminInitiateAuthCommand = AdminInitiateAuthCommand;


/***/ }),

/***/ 97909:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminLinkProviderForUserCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminLinkProviderForUserCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminLinkProviderForUserCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminLinkProviderForUserCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminLinkProviderForUserCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminLinkProviderForUserCommand)(output, context);
    }
}
exports.AdminLinkProviderForUserCommand = AdminLinkProviderForUserCommand;


/***/ }),

/***/ 94207:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminListDevicesCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminListDevicesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminListDevicesCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminListDevicesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminListDevicesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.AdminListDevicesResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminListDevicesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminListDevicesCommand)(output, context);
    }
}
exports.AdminListDevicesCommand = AdminListDevicesCommand;


/***/ }),

/***/ 55328:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminListGroupsForUserCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminListGroupsForUserCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminListGroupsForUserCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminListGroupsForUserCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminListGroupsForUserRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminListGroupsForUserCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminListGroupsForUserCommand)(output, context);
    }
}
exports.AdminListGroupsForUserCommand = AdminListGroupsForUserCommand;


/***/ }),

/***/ 21606:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminListUserAuthEventsCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminListUserAuthEventsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminListUserAuthEventsCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminListUserAuthEventsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminListUserAuthEventsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminListUserAuthEventsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminListUserAuthEventsCommand)(output, context);
    }
}
exports.AdminListUserAuthEventsCommand = AdminListUserAuthEventsCommand;


/***/ }),

/***/ 19006:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminRemoveUserFromGroupCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminRemoveUserFromGroupCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminRemoveUserFromGroupCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminRemoveUserFromGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminRemoveUserFromGroupRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminRemoveUserFromGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminRemoveUserFromGroupCommand)(output, context);
    }
}
exports.AdminRemoveUserFromGroupCommand = AdminRemoveUserFromGroupCommand;


/***/ }),

/***/ 900:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminResetUserPasswordCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminResetUserPasswordCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminResetUserPasswordCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminResetUserPasswordCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminResetUserPasswordRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminResetUserPasswordCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminResetUserPasswordCommand)(output, context);
    }
}
exports.AdminResetUserPasswordCommand = AdminResetUserPasswordCommand;


/***/ }),

/***/ 47702:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminRespondToAuthChallengeCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminRespondToAuthChallengeCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminRespondToAuthChallengeCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminRespondToAuthChallengeCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminRespondToAuthChallengeRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.AdminRespondToAuthChallengeResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminRespondToAuthChallengeCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminRespondToAuthChallengeCommand)(output, context);
    }
}
exports.AdminRespondToAuthChallengeCommand = AdminRespondToAuthChallengeCommand;


/***/ }),

/***/ 4844:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminSetUserMFAPreferenceCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminSetUserMFAPreferenceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminSetUserMFAPreferenceCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminSetUserMFAPreferenceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminSetUserMFAPreferenceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminSetUserMFAPreferenceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminSetUserMFAPreferenceCommand)(output, context);
    }
}
exports.AdminSetUserMFAPreferenceCommand = AdminSetUserMFAPreferenceCommand;


/***/ }),

/***/ 53479:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminSetUserPasswordCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminSetUserPasswordCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminSetUserPasswordCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminSetUserPasswordCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminSetUserPasswordRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminSetUserPasswordCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminSetUserPasswordCommand)(output, context);
    }
}
exports.AdminSetUserPasswordCommand = AdminSetUserPasswordCommand;


/***/ }),

/***/ 18955:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminSetUserSettingsCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminSetUserSettingsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminSetUserSettingsCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminSetUserSettingsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminSetUserSettingsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminSetUserSettingsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminSetUserSettingsCommand)(output, context);
    }
}
exports.AdminSetUserSettingsCommand = AdminSetUserSettingsCommand;


/***/ }),

/***/ 70499:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminUpdateAuthEventFeedbackCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminUpdateAuthEventFeedbackCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminUpdateAuthEventFeedbackCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminUpdateAuthEventFeedbackCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminUpdateAuthEventFeedbackRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminUpdateAuthEventFeedbackCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminUpdateAuthEventFeedbackCommand)(output, context);
    }
}
exports.AdminUpdateAuthEventFeedbackCommand = AdminUpdateAuthEventFeedbackCommand;


/***/ }),

/***/ 49981:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminUpdateDeviceStatusCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminUpdateDeviceStatusCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminUpdateDeviceStatusCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminUpdateDeviceStatusCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminUpdateDeviceStatusRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminUpdateDeviceStatusCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminUpdateDeviceStatusCommand)(output, context);
    }
}
exports.AdminUpdateDeviceStatusCommand = AdminUpdateDeviceStatusCommand;


/***/ }),

/***/ 41849:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminUpdateUserAttributesCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminUpdateUserAttributesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminUpdateUserAttributesCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminUpdateUserAttributesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminUpdateUserAttributesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminUpdateUserAttributesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminUpdateUserAttributesCommand)(output, context);
    }
}
exports.AdminUpdateUserAttributesCommand = AdminUpdateUserAttributesCommand;


/***/ }),

/***/ 83344:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdminUserGlobalSignOutCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AdminUserGlobalSignOutCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AdminUserGlobalSignOutCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AdminUserGlobalSignOutCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AdminUserGlobalSignOutRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AdminUserGlobalSignOutCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AdminUserGlobalSignOutCommand)(output, context);
    }
}
exports.AdminUserGlobalSignOutCommand = AdminUserGlobalSignOutCommand;


/***/ }),

/***/ 91999:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AssociateSoftwareTokenCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class AssociateSoftwareTokenCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AssociateSoftwareTokenCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "AssociateSoftwareTokenCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AssociateSoftwareTokenRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.AssociateSoftwareTokenResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_AssociateSoftwareTokenCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_AssociateSoftwareTokenCommand)(output, context);
    }
}
exports.AssociateSoftwareTokenCommand = AssociateSoftwareTokenCommand;


/***/ }),

/***/ 6049:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ChangePasswordCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class ChangePasswordCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ChangePasswordCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "ChangePasswordCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ChangePasswordRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_ChangePasswordCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_ChangePasswordCommand)(output, context);
    }
}
exports.ChangePasswordCommand = ChangePasswordCommand;


/***/ }),

/***/ 70622:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ConfirmDeviceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class ConfirmDeviceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ConfirmDeviceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "ConfirmDeviceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ConfirmDeviceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_ConfirmDeviceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_ConfirmDeviceCommand)(output, context);
    }
}
exports.ConfirmDeviceCommand = ConfirmDeviceCommand;


/***/ }),

/***/ 19272:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ConfirmForgotPasswordCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class ConfirmForgotPasswordCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ConfirmForgotPasswordCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "ConfirmForgotPasswordCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ConfirmForgotPasswordRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_ConfirmForgotPasswordCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_ConfirmForgotPasswordCommand)(output, context);
    }
}
exports.ConfirmForgotPasswordCommand = ConfirmForgotPasswordCommand;


/***/ }),

/***/ 60368:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ConfirmSignUpCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class ConfirmSignUpCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ConfirmSignUpCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "ConfirmSignUpCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ConfirmSignUpRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_ConfirmSignUpCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_ConfirmSignUpCommand)(output, context);
    }
}
exports.ConfirmSignUpCommand = ConfirmSignUpCommand;


/***/ }),

/***/ 31788:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CreateGroupCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class CreateGroupCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateGroupCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "CreateGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_CreateGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_CreateGroupCommand)(output, context);
    }
}
exports.CreateGroupCommand = CreateGroupCommand;


/***/ }),

/***/ 13492:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CreateIdentityProviderCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class CreateIdentityProviderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateIdentityProviderCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "CreateIdentityProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_CreateIdentityProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_CreateIdentityProviderCommand)(output, context);
    }
}
exports.CreateIdentityProviderCommand = CreateIdentityProviderCommand;


/***/ }),

/***/ 92984:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CreateResourceServerCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class CreateResourceServerCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateResourceServerCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "CreateResourceServerCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_CreateResourceServerCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_CreateResourceServerCommand)(output, context);
    }
}
exports.CreateResourceServerCommand = CreateResourceServerCommand;


/***/ }),

/***/ 22510:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CreateUserImportJobCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class CreateUserImportJobCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateUserImportJobCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "CreateUserImportJobCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_CreateUserImportJobCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_CreateUserImportJobCommand)(output, context);
    }
}
exports.CreateUserImportJobCommand = CreateUserImportJobCommand;


/***/ }),

/***/ 53173:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CreateUserPoolClientCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class CreateUserPoolClientCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateUserPoolClientCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "CreateUserPoolClientCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: models_0_1.CreateUserPoolClientResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_CreateUserPoolClientCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_CreateUserPoolClientCommand)(output, context);
    }
}
exports.CreateUserPoolClientCommand = CreateUserPoolClientCommand;


/***/ }),

/***/ 35451:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CreateUserPoolCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class CreateUserPoolCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateUserPoolCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "CreateUserPoolCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_CreateUserPoolCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_CreateUserPoolCommand)(output, context);
    }
}
exports.CreateUserPoolCommand = CreateUserPoolCommand;


/***/ }),

/***/ 57509:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CreateUserPoolDomainCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class CreateUserPoolDomainCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, CreateUserPoolDomainCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "CreateUserPoolDomainCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_CreateUserPoolDomainCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_CreateUserPoolDomainCommand)(output, context);
    }
}
exports.CreateUserPoolDomainCommand = CreateUserPoolDomainCommand;


/***/ }),

/***/ 486:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DeleteGroupCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class DeleteGroupCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteGroupCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "DeleteGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_DeleteGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_DeleteGroupCommand)(output, context);
    }
}
exports.DeleteGroupCommand = DeleteGroupCommand;


/***/ }),

/***/ 93150:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DeleteIdentityProviderCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class DeleteIdentityProviderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteIdentityProviderCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "DeleteIdentityProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_DeleteIdentityProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_DeleteIdentityProviderCommand)(output, context);
    }
}
exports.DeleteIdentityProviderCommand = DeleteIdentityProviderCommand;


/***/ }),

/***/ 29456:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DeleteResourceServerCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class DeleteResourceServerCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteResourceServerCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "DeleteResourceServerCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_DeleteResourceServerCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_DeleteResourceServerCommand)(output, context);
    }
}
exports.DeleteResourceServerCommand = DeleteResourceServerCommand;


/***/ }),

/***/ 77643:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DeleteUserAttributesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class DeleteUserAttributesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteUserAttributesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "DeleteUserAttributesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteUserAttributesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_DeleteUserAttributesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_DeleteUserAttributesCommand)(output, context);
    }
}
exports.DeleteUserAttributesCommand = DeleteUserAttributesCommand;


/***/ }),

/***/ 85207:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DeleteUserCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class DeleteUserCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteUserCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "DeleteUserCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteUserRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_DeleteUserCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_DeleteUserCommand)(output, context);
    }
}
exports.DeleteUserCommand = DeleteUserCommand;


/***/ }),

/***/ 96418:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DeleteUserPoolClientCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class DeleteUserPoolClientCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteUserPoolClientCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "DeleteUserPoolClientCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DeleteUserPoolClientRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_DeleteUserPoolClientCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_DeleteUserPoolClientCommand)(output, context);
    }
}
exports.DeleteUserPoolClientCommand = DeleteUserPoolClientCommand;


/***/ }),

/***/ 87108:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DeleteUserPoolCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class DeleteUserPoolCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteUserPoolCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "DeleteUserPoolCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_DeleteUserPoolCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_DeleteUserPoolCommand)(output, context);
    }
}
exports.DeleteUserPoolCommand = DeleteUserPoolCommand;


/***/ }),

/***/ 46084:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DeleteUserPoolDomainCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class DeleteUserPoolDomainCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DeleteUserPoolDomainCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "DeleteUserPoolDomainCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_DeleteUserPoolDomainCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_DeleteUserPoolDomainCommand)(output, context);
    }
}
exports.DeleteUserPoolDomainCommand = DeleteUserPoolDomainCommand;


/***/ }),

/***/ 73972:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DescribeIdentityProviderCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class DescribeIdentityProviderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeIdentityProviderCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "DescribeIdentityProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_DescribeIdentityProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_DescribeIdentityProviderCommand)(output, context);
    }
}
exports.DescribeIdentityProviderCommand = DescribeIdentityProviderCommand;


/***/ }),

/***/ 46139:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DescribeResourceServerCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class DescribeResourceServerCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeResourceServerCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "DescribeResourceServerCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_DescribeResourceServerCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_DescribeResourceServerCommand)(output, context);
    }
}
exports.DescribeResourceServerCommand = DescribeResourceServerCommand;


/***/ }),

/***/ 54779:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DescribeRiskConfigurationCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class DescribeRiskConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeRiskConfigurationCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "DescribeRiskConfigurationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeRiskConfigurationRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeRiskConfigurationResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_DescribeRiskConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_DescribeRiskConfigurationCommand)(output, context);
    }
}
exports.DescribeRiskConfigurationCommand = DescribeRiskConfigurationCommand;


/***/ }),

/***/ 71992:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DescribeUserImportJobCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class DescribeUserImportJobCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeUserImportJobCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "DescribeUserImportJobCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_DescribeUserImportJobCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_DescribeUserImportJobCommand)(output, context);
    }
}
exports.DescribeUserImportJobCommand = DescribeUserImportJobCommand;


/***/ }),

/***/ 68420:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DescribeUserPoolClientCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class DescribeUserPoolClientCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeUserPoolClientCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "DescribeUserPoolClientCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.DescribeUserPoolClientRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.DescribeUserPoolClientResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_DescribeUserPoolClientCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_DescribeUserPoolClientCommand)(output, context);
    }
}
exports.DescribeUserPoolClientCommand = DescribeUserPoolClientCommand;


/***/ }),

/***/ 75913:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DescribeUserPoolCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class DescribeUserPoolCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeUserPoolCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "DescribeUserPoolCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_DescribeUserPoolCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_DescribeUserPoolCommand)(output, context);
    }
}
exports.DescribeUserPoolCommand = DescribeUserPoolCommand;


/***/ }),

/***/ 48684:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DescribeUserPoolDomainCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class DescribeUserPoolDomainCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DescribeUserPoolDomainCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "DescribeUserPoolDomainCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_DescribeUserPoolDomainCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_DescribeUserPoolDomainCommand)(output, context);
    }
}
exports.DescribeUserPoolDomainCommand = DescribeUserPoolDomainCommand;


/***/ }),

/***/ 33174:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ForgetDeviceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class ForgetDeviceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ForgetDeviceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "ForgetDeviceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ForgetDeviceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_ForgetDeviceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_ForgetDeviceCommand)(output, context);
    }
}
exports.ForgetDeviceCommand = ForgetDeviceCommand;


/***/ }),

/***/ 60474:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ForgotPasswordCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class ForgotPasswordCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ForgotPasswordCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "ForgotPasswordCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ForgotPasswordRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_ForgotPasswordCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_ForgotPasswordCommand)(output, context);
    }
}
exports.ForgotPasswordCommand = ForgotPasswordCommand;


/***/ }),

/***/ 34957:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GetCSVHeaderCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class GetCSVHeaderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetCSVHeaderCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "GetCSVHeaderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_GetCSVHeaderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_GetCSVHeaderCommand)(output, context);
    }
}
exports.GetCSVHeaderCommand = GetCSVHeaderCommand;


/***/ }),

/***/ 88362:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GetDeviceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class GetDeviceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetDeviceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "GetDeviceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetDeviceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetDeviceResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_GetDeviceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_GetDeviceCommand)(output, context);
    }
}
exports.GetDeviceCommand = GetDeviceCommand;


/***/ }),

/***/ 88960:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GetGroupCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class GetGroupCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetGroupCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "GetGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_GetGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_GetGroupCommand)(output, context);
    }
}
exports.GetGroupCommand = GetGroupCommand;


/***/ }),

/***/ 97790:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GetIdentityProviderByIdentifierCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class GetIdentityProviderByIdentifierCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetIdentityProviderByIdentifierCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "GetIdentityProviderByIdentifierCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_GetIdentityProviderByIdentifierCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_GetIdentityProviderByIdentifierCommand)(output, context);
    }
}
exports.GetIdentityProviderByIdentifierCommand = GetIdentityProviderByIdentifierCommand;


/***/ }),

/***/ 67417:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GetLogDeliveryConfigurationCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class GetLogDeliveryConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetLogDeliveryConfigurationCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "GetLogDeliveryConfigurationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_GetLogDeliveryConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_GetLogDeliveryConfigurationCommand)(output, context);
    }
}
exports.GetLogDeliveryConfigurationCommand = GetLogDeliveryConfigurationCommand;


/***/ }),

/***/ 65580:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GetSigningCertificateCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class GetSigningCertificateCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetSigningCertificateCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "GetSigningCertificateCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_GetSigningCertificateCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_GetSigningCertificateCommand)(output, context);
    }
}
exports.GetSigningCertificateCommand = GetSigningCertificateCommand;


/***/ }),

/***/ 26482:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GetUICustomizationCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class GetUICustomizationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetUICustomizationCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "GetUICustomizationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetUICustomizationRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetUICustomizationResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_GetUICustomizationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_GetUICustomizationCommand)(output, context);
    }
}
exports.GetUICustomizationCommand = GetUICustomizationCommand;


/***/ }),

/***/ 86502:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GetUserAttributeVerificationCodeCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class GetUserAttributeVerificationCodeCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetUserAttributeVerificationCodeCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "GetUserAttributeVerificationCodeCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetUserAttributeVerificationCodeRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_GetUserAttributeVerificationCodeCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_GetUserAttributeVerificationCodeCommand)(output, context);
    }
}
exports.GetUserAttributeVerificationCodeCommand = GetUserAttributeVerificationCodeCommand;


/***/ }),

/***/ 22294:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GetUserCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class GetUserCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetUserCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "GetUserCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetUserRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetUserResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_GetUserCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_GetUserCommand)(output, context);
    }
}
exports.GetUserCommand = GetUserCommand;


/***/ }),

/***/ 9084:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GetUserPoolMfaConfigCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class GetUserPoolMfaConfigCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetUserPoolMfaConfigCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "GetUserPoolMfaConfigCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_GetUserPoolMfaConfigCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_GetUserPoolMfaConfigCommand)(output, context);
    }
}
exports.GetUserPoolMfaConfigCommand = GetUserPoolMfaConfigCommand;


/***/ }),

/***/ 14524:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GlobalSignOutCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class GlobalSignOutCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GlobalSignOutCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "GlobalSignOutCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GlobalSignOutRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_GlobalSignOutCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_GlobalSignOutCommand)(output, context);
    }
}
exports.GlobalSignOutCommand = GlobalSignOutCommand;


/***/ }),

/***/ 97494:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.InitiateAuthCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class InitiateAuthCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, InitiateAuthCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "InitiateAuthCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.InitiateAuthRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.InitiateAuthResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_InitiateAuthCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_InitiateAuthCommand)(output, context);
    }
}
exports.InitiateAuthCommand = InitiateAuthCommand;


/***/ }),

/***/ 20131:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ListDevicesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class ListDevicesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListDevicesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "ListDevicesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListDevicesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.ListDevicesResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_ListDevicesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_ListDevicesCommand)(output, context);
    }
}
exports.ListDevicesCommand = ListDevicesCommand;


/***/ }),

/***/ 19010:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ListGroupsCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class ListGroupsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListGroupsCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "ListGroupsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_ListGroupsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_ListGroupsCommand)(output, context);
    }
}
exports.ListGroupsCommand = ListGroupsCommand;


/***/ }),

/***/ 40247:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ListIdentityProvidersCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class ListIdentityProvidersCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListIdentityProvidersCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "ListIdentityProvidersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_ListIdentityProvidersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_ListIdentityProvidersCommand)(output, context);
    }
}
exports.ListIdentityProvidersCommand = ListIdentityProvidersCommand;


/***/ }),

/***/ 67716:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ListResourceServersCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class ListResourceServersCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListResourceServersCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "ListResourceServersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_ListResourceServersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_ListResourceServersCommand)(output, context);
    }
}
exports.ListResourceServersCommand = ListResourceServersCommand;


/***/ }),

/***/ 53519:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ListTagsForResourceCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class ListTagsForResourceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListTagsForResourceCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "ListTagsForResourceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_ListTagsForResourceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_ListTagsForResourceCommand)(output, context);
    }
}
exports.ListTagsForResourceCommand = ListTagsForResourceCommand;


/***/ }),

/***/ 68786:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ListUserImportJobsCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class ListUserImportJobsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListUserImportJobsCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "ListUserImportJobsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_ListUserImportJobsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_ListUserImportJobsCommand)(output, context);
    }
}
exports.ListUserImportJobsCommand = ListUserImportJobsCommand;


/***/ }),

/***/ 48532:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ListUserPoolClientsCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class ListUserPoolClientsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListUserPoolClientsCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "ListUserPoolClientsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: models_0_1.ListUserPoolClientsResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_ListUserPoolClientsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_ListUserPoolClientsCommand)(output, context);
    }
}
exports.ListUserPoolClientsCommand = ListUserPoolClientsCommand;


/***/ }),

/***/ 42083:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ListUserPoolsCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class ListUserPoolsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListUserPoolsCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "ListUserPoolsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_ListUserPoolsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_ListUserPoolsCommand)(output, context);
    }
}
exports.ListUserPoolsCommand = ListUserPoolsCommand;


/***/ }),

/***/ 60086:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ListUsersCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class ListUsersCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListUsersCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "ListUsersCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: models_0_1.ListUsersResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_ListUsersCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_ListUsersCommand)(output, context);
    }
}
exports.ListUsersCommand = ListUsersCommand;


/***/ }),

/***/ 27102:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ListUsersInGroupCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class ListUsersInGroupCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListUsersInGroupCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "ListUsersInGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: models_0_1.ListUsersInGroupResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_ListUsersInGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_ListUsersInGroupCommand)(output, context);
    }
}
exports.ListUsersInGroupCommand = ListUsersInGroupCommand;


/***/ }),

/***/ 67520:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ResendConfirmationCodeCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class ResendConfirmationCodeCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ResendConfirmationCodeCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "ResendConfirmationCodeCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ResendConfirmationCodeRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_ResendConfirmationCodeCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_ResendConfirmationCodeCommand)(output, context);
    }
}
exports.ResendConfirmationCodeCommand = ResendConfirmationCodeCommand;


/***/ }),

/***/ 59539:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.RespondToAuthChallengeCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class RespondToAuthChallengeCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, RespondToAuthChallengeCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "RespondToAuthChallengeCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.RespondToAuthChallengeRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.RespondToAuthChallengeResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_RespondToAuthChallengeCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_RespondToAuthChallengeCommand)(output, context);
    }
}
exports.RespondToAuthChallengeCommand = RespondToAuthChallengeCommand;


/***/ }),

/***/ 51011:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.RevokeTokenCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const Aws_json1_1_1 = __webpack_require__(82965);
class RevokeTokenCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, RevokeTokenCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "RevokeTokenCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.RevokeTokenRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_RevokeTokenCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_RevokeTokenCommand)(output, context);
    }
}
exports.RevokeTokenCommand = RevokeTokenCommand;


/***/ }),

/***/ 48124:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SetLogDeliveryConfigurationCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class SetLogDeliveryConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, SetLogDeliveryConfigurationCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "SetLogDeliveryConfigurationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_SetLogDeliveryConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_SetLogDeliveryConfigurationCommand)(output, context);
    }
}
exports.SetLogDeliveryConfigurationCommand = SetLogDeliveryConfigurationCommand;


/***/ }),

/***/ 67422:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SetRiskConfigurationCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(8257);
const models_1_1 = __webpack_require__(50646);
const Aws_json1_1_1 = __webpack_require__(82965);
class SetRiskConfigurationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, SetRiskConfigurationCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "SetRiskConfigurationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.SetRiskConfigurationRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_1_1.SetRiskConfigurationResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_SetRiskConfigurationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_SetRiskConfigurationCommand)(output, context);
    }
}
exports.SetRiskConfigurationCommand = SetRiskConfigurationCommand;


/***/ }),

/***/ 83812:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SetUICustomizationCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_1_1 = __webpack_require__(50646);
const Aws_json1_1_1 = __webpack_require__(82965);
class SetUICustomizationCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, SetUICustomizationCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "SetUICustomizationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_1_1.SetUICustomizationRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_1_1.SetUICustomizationResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_SetUICustomizationCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_SetUICustomizationCommand)(output, context);
    }
}
exports.SetUICustomizationCommand = SetUICustomizationCommand;


/***/ }),

/***/ 22853:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SetUserMFAPreferenceCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_1_1 = __webpack_require__(50646);
const Aws_json1_1_1 = __webpack_require__(82965);
class SetUserMFAPreferenceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, SetUserMFAPreferenceCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "SetUserMFAPreferenceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_1_1.SetUserMFAPreferenceRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_SetUserMFAPreferenceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_SetUserMFAPreferenceCommand)(output, context);
    }
}
exports.SetUserMFAPreferenceCommand = SetUserMFAPreferenceCommand;


/***/ }),

/***/ 12417:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SetUserPoolMfaConfigCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class SetUserPoolMfaConfigCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, SetUserPoolMfaConfigCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "SetUserPoolMfaConfigCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_SetUserPoolMfaConfigCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_SetUserPoolMfaConfigCommand)(output, context);
    }
}
exports.SetUserPoolMfaConfigCommand = SetUserPoolMfaConfigCommand;


/***/ }),

/***/ 72598:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SetUserSettingsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_1_1 = __webpack_require__(50646);
const Aws_json1_1_1 = __webpack_require__(82965);
class SetUserSettingsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, SetUserSettingsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "SetUserSettingsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_1_1.SetUserSettingsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_SetUserSettingsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_SetUserSettingsCommand)(output, context);
    }
}
exports.SetUserSettingsCommand = SetUserSettingsCommand;


/***/ }),

/***/ 80766:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SignUpCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_1_1 = __webpack_require__(50646);
const Aws_json1_1_1 = __webpack_require__(82965);
class SignUpCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, SignUpCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "SignUpCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_1_1.SignUpRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_SignUpCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_SignUpCommand)(output, context);
    }
}
exports.SignUpCommand = SignUpCommand;


/***/ }),

/***/ 45449:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.StartUserImportJobCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class StartUserImportJobCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, StartUserImportJobCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "StartUserImportJobCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_StartUserImportJobCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_StartUserImportJobCommand)(output, context);
    }
}
exports.StartUserImportJobCommand = StartUserImportJobCommand;


/***/ }),

/***/ 54443:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.StopUserImportJobCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class StopUserImportJobCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, StopUserImportJobCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "StopUserImportJobCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_StopUserImportJobCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_StopUserImportJobCommand)(output, context);
    }
}
exports.StopUserImportJobCommand = StopUserImportJobCommand;


/***/ }),

/***/ 57095:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.TagResourceCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class TagResourceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, TagResourceCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "TagResourceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_TagResourceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_TagResourceCommand)(output, context);
    }
}
exports.TagResourceCommand = TagResourceCommand;


/***/ }),

/***/ 90036:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UntagResourceCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class UntagResourceCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UntagResourceCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "UntagResourceCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_UntagResourceCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_UntagResourceCommand)(output, context);
    }
}
exports.UntagResourceCommand = UntagResourceCommand;


/***/ }),

/***/ 64386:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UpdateAuthEventFeedbackCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_1_1 = __webpack_require__(50646);
const Aws_json1_1_1 = __webpack_require__(82965);
class UpdateAuthEventFeedbackCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateAuthEventFeedbackCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "UpdateAuthEventFeedbackCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_1_1.UpdateAuthEventFeedbackRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_UpdateAuthEventFeedbackCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_UpdateAuthEventFeedbackCommand)(output, context);
    }
}
exports.UpdateAuthEventFeedbackCommand = UpdateAuthEventFeedbackCommand;


/***/ }),

/***/ 48996:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UpdateDeviceStatusCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_1_1 = __webpack_require__(50646);
const Aws_json1_1_1 = __webpack_require__(82965);
class UpdateDeviceStatusCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateDeviceStatusCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "UpdateDeviceStatusCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_1_1.UpdateDeviceStatusRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_UpdateDeviceStatusCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_UpdateDeviceStatusCommand)(output, context);
    }
}
exports.UpdateDeviceStatusCommand = UpdateDeviceStatusCommand;


/***/ }),

/***/ 3265:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UpdateGroupCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class UpdateGroupCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateGroupCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "UpdateGroupCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_UpdateGroupCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_UpdateGroupCommand)(output, context);
    }
}
exports.UpdateGroupCommand = UpdateGroupCommand;


/***/ }),

/***/ 54409:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UpdateIdentityProviderCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class UpdateIdentityProviderCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateIdentityProviderCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "UpdateIdentityProviderCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_UpdateIdentityProviderCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_UpdateIdentityProviderCommand)(output, context);
    }
}
exports.UpdateIdentityProviderCommand = UpdateIdentityProviderCommand;


/***/ }),

/***/ 67223:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UpdateResourceServerCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class UpdateResourceServerCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateResourceServerCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "UpdateResourceServerCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_UpdateResourceServerCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_UpdateResourceServerCommand)(output, context);
    }
}
exports.UpdateResourceServerCommand = UpdateResourceServerCommand;


/***/ }),

/***/ 83973:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UpdateUserAttributesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_1_1 = __webpack_require__(50646);
const Aws_json1_1_1 = __webpack_require__(82965);
class UpdateUserAttributesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateUserAttributesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "UpdateUserAttributesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_1_1.UpdateUserAttributesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_UpdateUserAttributesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_UpdateUserAttributesCommand)(output, context);
    }
}
exports.UpdateUserAttributesCommand = UpdateUserAttributesCommand;


/***/ }),

/***/ 48505:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UpdateUserPoolClientCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_1_1 = __webpack_require__(50646);
const Aws_json1_1_1 = __webpack_require__(82965);
class UpdateUserPoolClientCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateUserPoolClientCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "UpdateUserPoolClientCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_1_1.UpdateUserPoolClientRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_1_1.UpdateUserPoolClientResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_UpdateUserPoolClientCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_UpdateUserPoolClientCommand)(output, context);
    }
}
exports.UpdateUserPoolClientCommand = UpdateUserPoolClientCommand;


/***/ }),

/***/ 37871:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UpdateUserPoolCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class UpdateUserPoolCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateUserPoolCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "UpdateUserPoolCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_UpdateUserPoolCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_UpdateUserPoolCommand)(output, context);
    }
}
exports.UpdateUserPoolCommand = UpdateUserPoolCommand;


/***/ }),

/***/ 80659:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UpdateUserPoolDomainCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_json1_1_1 = __webpack_require__(82965);
class UpdateUserPoolDomainCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, UpdateUserPoolDomainCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "UpdateUserPoolDomainCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_UpdateUserPoolDomainCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_UpdateUserPoolDomainCommand)(output, context);
    }
}
exports.UpdateUserPoolDomainCommand = UpdateUserPoolDomainCommand;


/***/ }),

/***/ 66249:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.VerifySoftwareTokenCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_1_1 = __webpack_require__(50646);
const Aws_json1_1_1 = __webpack_require__(82965);
class VerifySoftwareTokenCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, VerifySoftwareTokenCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "VerifySoftwareTokenCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_1_1.VerifySoftwareTokenRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_1_1.VerifySoftwareTokenResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_VerifySoftwareTokenCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_VerifySoftwareTokenCommand)(output, context);
    }
}
exports.VerifySoftwareTokenCommand = VerifySoftwareTokenCommand;


/***/ }),

/***/ 17584:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.VerifyUserAttributeCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_1_1 = __webpack_require__(50646);
const Aws_json1_1_1 = __webpack_require__(82965);
class VerifyUserAttributeCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, VerifyUserAttributeCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "CognitoIdentityProviderClient";
        const commandName = "VerifyUserAttributeCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_1_1.VerifyUserAttributeRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_json1_1_1.se_VerifyUserAttributeCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_json1_1_1.de_VerifyUserAttributeCommand)(output, context);
    }
}
exports.VerifyUserAttributeCommand = VerifyUserAttributeCommand;


/***/ }),

/***/ 2159:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(64502), exports);
tslib_1.__exportStar(__webpack_require__(66892), exports);
tslib_1.__exportStar(__webpack_require__(36341), exports);
tslib_1.__exportStar(__webpack_require__(84037), exports);
tslib_1.__exportStar(__webpack_require__(34324), exports);
tslib_1.__exportStar(__webpack_require__(85870), exports);
tslib_1.__exportStar(__webpack_require__(27958), exports);
tslib_1.__exportStar(__webpack_require__(39730), exports);
tslib_1.__exportStar(__webpack_require__(66516), exports);
tslib_1.__exportStar(__webpack_require__(11040), exports);
tslib_1.__exportStar(__webpack_require__(49148), exports);
tslib_1.__exportStar(__webpack_require__(30824), exports);
tslib_1.__exportStar(__webpack_require__(6470), exports);
tslib_1.__exportStar(__webpack_require__(97909), exports);
tslib_1.__exportStar(__webpack_require__(94207), exports);
tslib_1.__exportStar(__webpack_require__(55328), exports);
tslib_1.__exportStar(__webpack_require__(21606), exports);
tslib_1.__exportStar(__webpack_require__(19006), exports);
tslib_1.__exportStar(__webpack_require__(900), exports);
tslib_1.__exportStar(__webpack_require__(47702), exports);
tslib_1.__exportStar(__webpack_require__(4844), exports);
tslib_1.__exportStar(__webpack_require__(53479), exports);
tslib_1.__exportStar(__webpack_require__(18955), exports);
tslib_1.__exportStar(__webpack_require__(70499), exports);
tslib_1.__exportStar(__webpack_require__(49981), exports);
tslib_1.__exportStar(__webpack_require__(41849), exports);
tslib_1.__exportStar(__webpack_require__(83344), exports);
tslib_1.__exportStar(__webpack_require__(91999), exports);
tslib_1.__exportStar(__webpack_require__(6049), exports);
tslib_1.__exportStar(__webpack_require__(70622), exports);
tslib_1.__exportStar(__webpack_require__(19272), exports);
tslib_1.__exportStar(__webpack_require__(60368), exports);
tslib_1.__exportStar(__webpack_require__(31788), exports);
tslib_1.__exportStar(__webpack_require__(13492), exports);
tslib_1.__exportStar(__webpack_require__(92984), exports);
tslib_1.__exportStar(__webpack_require__(22510), exports);
tslib_1.__exportStar(__webpack_require__(53173), exports);
tslib_1.__exportStar(__webpack_require__(35451), exports);
tslib_1.__exportStar(__webpack_require__(57509), exports);
tslib_1.__exportStar(__webpack_require__(486), exports);
tslib_1.__exportStar(__webpack_require__(93150), exports);
tslib_1.__exportStar(__webpack_require__(29456), exports);
tslib_1.__exportStar(__webpack_require__(77643), exports);
tslib_1.__exportStar(__webpack_require__(85207), exports);
tslib_1.__exportStar(__webpack_require__(96418), exports);
tslib_1.__exportStar(__webpack_require__(87108), exports);
tslib_1.__exportStar(__webpack_require__(46084), exports);
tslib_1.__exportStar(__webpack_require__(73972), exports);
tslib_1.__exportStar(__webpack_require__(46139), exports);
tslib_1.__exportStar(__webpack_require__(54779), exports);
tslib_1.__exportStar(__webpack_require__(71992), exports);
tslib_1.__exportStar(__webpack_require__(68420), exports);
tslib_1.__exportStar(__webpack_require__(75913), exports);
tslib_1.__exportStar(__webpack_require__(48684), exports);
tslib_1.__exportStar(__webpack_require__(33174), exports);
tslib_1.__exportStar(__webpack_require__(60474), exports);
tslib_1.__exportStar(__webpack_require__(34957), exports);
tslib_1.__exportStar(__webpack_require__(88362), exports);
tslib_1.__exportStar(__webpack_require__(88960), exports);
tslib_1.__exportStar(__webpack_require__(97790), exports);
tslib_1.__exportStar(__webpack_require__(67417), exports);
tslib_1.__exportStar(__webpack_require__(65580), exports);
tslib_1.__exportStar(__webpack_require__(26482), exports);
tslib_1.__exportStar(__webpack_require__(86502), exports);
tslib_1.__exportStar(__webpack_require__(22294), exports);
tslib_1.__exportStar(__webpack_require__(9084), exports);
tslib_1.__exportStar(__webpack_require__(14524), exports);
tslib_1.__exportStar(__webpack_require__(97494), exports);
tslib_1.__exportStar(__webpack_require__(20131), exports);
tslib_1.__exportStar(__webpack_require__(19010), exports);
tslib_1.__exportStar(__webpack_require__(40247), exports);
tslib_1.__exportStar(__webpack_require__(67716), exports);
tslib_1.__exportStar(__webpack_require__(53519), exports);
tslib_1.__exportStar(__webpack_require__(68786), exports);
tslib_1.__exportStar(__webpack_require__(48532), exports);
tslib_1.__exportStar(__webpack_require__(42083), exports);
tslib_1.__exportStar(__webpack_require__(60086), exports);
tslib_1.__exportStar(__webpack_require__(27102), exports);
tslib_1.__exportStar(__webpack_require__(67520), exports);
tslib_1.__exportStar(__webpack_require__(59539), exports);
tslib_1.__exportStar(__webpack_require__(51011), exports);
tslib_1.__exportStar(__webpack_require__(48124), exports);
tslib_1.__exportStar(__webpack_require__(67422), exports);
tslib_1.__exportStar(__webpack_require__(83812), exports);
tslib_1.__exportStar(__webpack_require__(22853), exports);
tslib_1.__exportStar(__webpack_require__(12417), exports);
tslib_1.__exportStar(__webpack_require__(72598), exports);
tslib_1.__exportStar(__webpack_require__(80766), exports);
tslib_1.__exportStar(__webpack_require__(45449), exports);
tslib_1.__exportStar(__webpack_require__(54443), exports);
tslib_1.__exportStar(__webpack_require__(57095), exports);
tslib_1.__exportStar(__webpack_require__(90036), exports);
tslib_1.__exportStar(__webpack_require__(64386), exports);
tslib_1.__exportStar(__webpack_require__(48996), exports);
tslib_1.__exportStar(__webpack_require__(3265), exports);
tslib_1.__exportStar(__webpack_require__(54409), exports);
tslib_1.__exportStar(__webpack_require__(67223), exports);
tslib_1.__exportStar(__webpack_require__(83973), exports);
tslib_1.__exportStar(__webpack_require__(48505), exports);
tslib_1.__exportStar(__webpack_require__(37871), exports);
tslib_1.__exportStar(__webpack_require__(80659), exports);
tslib_1.__exportStar(__webpack_require__(66249), exports);
tslib_1.__exportStar(__webpack_require__(17584), exports);


/***/ }),

/***/ 55396:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options)=>{
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "cognito-idp"
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;


/***/ }),

/***/ 58867:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __webpack_require__(8059);
const ruleset_1 = __webpack_require__(44361);
const defaultEndpointResolver = (endpointParams, context = {})=>{
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 44361:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ruleSet = void 0;
const q = "required", r = "fn", s = "argv", t = "ref";
const a = "isSet", b = "tree", c = "error", d = "endpoint", e = "PartitionResult", f = {
    [q]: false,
    "type": "String"
}, g = {
    [q]: true,
    "default": false,
    "type": "Boolean"
}, h = {
    [t]: "Endpoint"
}, i = {
    [r]: "booleanEquals",
    [s]: [
        {
            [t]: "UseFIPS"
        },
        true
    ]
}, j = {
    [r]: "booleanEquals",
    [s]: [
        {
            [t]: "UseDualStack"
        },
        true
    ]
}, k = {}, l = {
    [r]: "booleanEquals",
    [s]: [
        true,
        {
            [r]: "getAttr",
            [s]: [
                {
                    [t]: e
                },
                "supportsFIPS"
            ]
        }
    ]
}, m = {
    [r]: "booleanEquals",
    [s]: [
        true,
        {
            [r]: "getAttr",
            [s]: [
                {
                    [t]: e
                },
                "supportsDualStack"
            ]
        }
    ]
}, n = [
    i
], o = [
    j
], p = [
    {
        [t]: "Region"
    }
];
const _data = {
    version: "1.0",
    parameters: {
        Region: f,
        UseDualStack: g,
        UseFIPS: g,
        Endpoint: f
    },
    rules: [
        {
            conditions: [
                {
                    [r]: a,
                    [s]: [
                        h
                    ]
                }
            ],
            type: b,
            rules: [
                {
                    conditions: n,
                    error: "Invalid Configuration: FIPS and custom endpoint are not supported",
                    type: c
                },
                {
                    conditions: o,
                    error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
                    type: c
                },
                {
                    endpoint: {
                        url: h,
                        properties: k,
                        headers: k
                    },
                    type: d
                }
            ]
        },
        {
            conditions: [
                {
                    [r]: a,
                    [s]: p
                }
            ],
            type: b,
            rules: [
                {
                    conditions: [
                        {
                            [r]: "aws.partition",
                            [s]: p,
                            assign: e
                        }
                    ],
                    type: b,
                    rules: [
                        {
                            conditions: [
                                i,
                                j
                            ],
                            type: b,
                            rules: [
                                {
                                    conditions: [
                                        l,
                                        m
                                    ],
                                    type: b,
                                    rules: [
                                        {
                                            endpoint: {
                                                url: "https://cognito-idp-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                                                properties: k,
                                                headers: k
                                            },
                                            type: d
                                        }
                                    ]
                                },
                                {
                                    error: "FIPS and DualStack are enabled, but this partition does not support one or both",
                                    type: c
                                }
                            ]
                        },
                        {
                            conditions: n,
                            type: b,
                            rules: [
                                {
                                    conditions: [
                                        l
                                    ],
                                    type: b,
                                    rules: [
                                        {
                                            endpoint: {
                                                url: "https://cognito-idp-fips.{Region}.{PartitionResult#dnsSuffix}",
                                                properties: k,
                                                headers: k
                                            },
                                            type: d
                                        }
                                    ]
                                },
                                {
                                    error: "FIPS is enabled but this partition does not support FIPS",
                                    type: c
                                }
                            ]
                        },
                        {
                            conditions: o,
                            type: b,
                            rules: [
                                {
                                    conditions: [
                                        m
                                    ],
                                    type: b,
                                    rules: [
                                        {
                                            endpoint: {
                                                url: "https://cognito-idp.{Region}.{PartitionResult#dualStackDnsSuffix}",
                                                properties: k,
                                                headers: k
                                            },
                                            type: d
                                        }
                                    ]
                                },
                                {
                                    error: "DualStack is enabled but this partition does not support DualStack",
                                    type: c
                                }
                            ]
                        },
                        {
                            endpoint: {
                                url: "https://cognito-idp.{Region}.{PartitionResult#dnsSuffix}",
                                properties: k,
                                headers: k
                            },
                            type: d
                        }
                    ]
                }
            ]
        },
        {
            error: "Invalid Configuration: Missing Region",
            type: c
        }
    ]
};
exports.ruleSet = _data;


/***/ }),

/***/ 48894:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CognitoIdentityProviderServiceException = void 0;
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(85228), exports);
tslib_1.__exportStar(__webpack_require__(69134), exports);
tslib_1.__exportStar(__webpack_require__(2159), exports);
tslib_1.__exportStar(__webpack_require__(67333), exports);
tslib_1.__exportStar(__webpack_require__(33818), exports);
var CognitoIdentityProviderServiceException_1 = __webpack_require__(69496);
Object.defineProperty(exports, "CognitoIdentityProviderServiceException", ({
    enumerable: true,
    get: function() {
        return CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException;
    }
}));


/***/ }),

/***/ 69496:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CognitoIdentityProviderServiceException = exports.__ServiceException = void 0;
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "__ServiceException", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.ServiceException;
    }
}));
class CognitoIdentityProviderServiceException extends smithy_client_1.ServiceException {
    constructor(options){
        super(options);
        Object.setPrototypeOf(this, CognitoIdentityProviderServiceException.prototype);
    }
}
exports.CognitoIdentityProviderServiceException = CognitoIdentityProviderServiceException;


/***/ }),

/***/ 33818:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(8257), exports);
tslib_1.__exportStar(__webpack_require__(50646), exports);


/***/ }),

/***/ 8257:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.VerifiedAttributeType = exports.ForbiddenException = exports.ConcurrentModificationException = exports.AliasAttributeType = exports.AdvancedSecurityModeType = exports.DeviceRememberedStatusType = exports.SoftwareTokenMFANotFoundException = exports.ExpiredCodeException = exports.CodeMismatchException = exports.InvalidEmailRoleAccessPolicyException = exports.UserPoolAddOnNotEnabledException = exports.EventType = exports.RiskLevelType = exports.RiskDecisionType = exports.EventResponseType = exports.FeedbackValueType = exports.ChallengeResponse = exports.ChallengeName = exports.UserNotConfirmedException = exports.PasswordResetRequiredException = exports.MFAMethodNotFoundException = exports.ChallengeNameType = exports.AuthFlowType = exports.InvalidUserPoolConfigurationException = exports.AliasExistsException = exports.UsernameExistsException = exports.UnsupportedUserStateException = exports.PreconditionNotMetException = exports.InvalidSmsRoleTrustRelationshipException = exports.InvalidSmsRoleAccessPolicyException = exports.InvalidPasswordException = exports.CodeDeliveryFailureException = exports.UserStatusType = exports.MessageActionType = exports.DeliveryMediumType = exports.UserLambdaValidationException = exports.UnexpectedLambdaException = exports.TooManyFailedAttemptsException = exports.LimitExceededException = exports.InvalidLambdaResponseException = exports.UserNotFoundException = exports.UserImportInProgressException = exports.TooManyRequestsException = exports.ResourceNotFoundException = exports.NotAuthorizedException = exports.InvalidParameterException = exports.InternalErrorException = exports.AttributeDataType = exports.AccountTakeoverEventActionType = exports.RecoveryOptionNameType = void 0;
exports.AdminListGroupsForUserRequestFilterSensitiveLog = exports.AdminListDevicesResponseFilterSensitiveLog = exports.AdminListDevicesRequestFilterSensitiveLog = exports.AdminInitiateAuthResponseFilterSensitiveLog = exports.AuthenticationResultTypeFilterSensitiveLog = exports.AdminInitiateAuthRequestFilterSensitiveLog = exports.AdminGetUserResponseFilterSensitiveLog = exports.AdminGetUserRequestFilterSensitiveLog = exports.AdminGetDeviceResponseFilterSensitiveLog = exports.DeviceTypeFilterSensitiveLog = exports.AdminGetDeviceRequestFilterSensitiveLog = exports.AdminForgetDeviceRequestFilterSensitiveLog = exports.AdminEnableUserRequestFilterSensitiveLog = exports.AdminDisableUserRequestFilterSensitiveLog = exports.AdminDeleteUserAttributesRequestFilterSensitiveLog = exports.AdminDeleteUserRequestFilterSensitiveLog = exports.AdminCreateUserResponseFilterSensitiveLog = exports.UserTypeFilterSensitiveLog = exports.AdminCreateUserRequestFilterSensitiveLog = exports.AttributeTypeFilterSensitiveLog = exports.AdminConfirmSignUpRequestFilterSensitiveLog = exports.AdminAddUserToGroupRequestFilterSensitiveLog = exports.UnsupportedTokenTypeException = exports.UnsupportedOperationException = exports.UnauthorizedException = exports.LogLevel = exports.EventSourceName = exports.DomainStatusType = exports.EventFilterType = exports.CompromisedCredentialsEventActionType = exports.UnsupportedIdentityProviderException = exports.ScopeDoesNotExistException = exports.InvalidOAuthFlowException = exports.TimeUnitsType = exports.PreventUserExistenceErrorTypes = exports.ExplicitAuthFlowsType = exports.OAuthFlowType = exports.UserPoolTaggingException = exports.StatusType = exports.DefaultEmailOptionType = exports.UsernameAttributeType = exports.UserPoolMfaType = exports.CustomSMSSenderLambdaVersionType = exports.CustomEmailSenderLambdaVersionType = exports.EmailSendingAccountType = exports.DeletionProtectionType = exports.UserImportJobStatusType = exports.DuplicateProviderException = exports.IdentityProviderTypeType = exports.GroupExistsException = void 0;
exports.RespondToAuthChallengeRequestFilterSensitiveLog = exports.ResendConfirmationCodeRequestFilterSensitiveLog = exports.ListUsersInGroupResponseFilterSensitiveLog = exports.ListUsersResponseFilterSensitiveLog = exports.ListUserPoolClientsResponseFilterSensitiveLog = exports.UserPoolClientDescriptionFilterSensitiveLog = exports.ListDevicesResponseFilterSensitiveLog = exports.ListDevicesRequestFilterSensitiveLog = exports.InitiateAuthResponseFilterSensitiveLog = exports.InitiateAuthRequestFilterSensitiveLog = exports.GlobalSignOutRequestFilterSensitiveLog = exports.GetUserAttributeVerificationCodeRequestFilterSensitiveLog = exports.GetUserResponseFilterSensitiveLog = exports.GetUserRequestFilterSensitiveLog = exports.GetUICustomizationResponseFilterSensitiveLog = exports.UICustomizationTypeFilterSensitiveLog = exports.GetUICustomizationRequestFilterSensitiveLog = exports.GetDeviceResponseFilterSensitiveLog = exports.GetDeviceRequestFilterSensitiveLog = exports.ForgotPasswordRequestFilterSensitiveLog = exports.ForgetDeviceRequestFilterSensitiveLog = exports.DescribeUserPoolClientResponseFilterSensitiveLog = exports.DescribeUserPoolClientRequestFilterSensitiveLog = exports.DescribeRiskConfigurationResponseFilterSensitiveLog = exports.RiskConfigurationTypeFilterSensitiveLog = exports.DescribeRiskConfigurationRequestFilterSensitiveLog = exports.DeleteUserPoolClientRequestFilterSensitiveLog = exports.DeleteUserAttributesRequestFilterSensitiveLog = exports.DeleteUserRequestFilterSensitiveLog = exports.CreateUserPoolClientResponseFilterSensitiveLog = exports.UserPoolClientTypeFilterSensitiveLog = exports.ConfirmSignUpRequestFilterSensitiveLog = exports.ConfirmForgotPasswordRequestFilterSensitiveLog = exports.UserContextDataTypeFilterSensitiveLog = exports.ConfirmDeviceRequestFilterSensitiveLog = exports.ChangePasswordRequestFilterSensitiveLog = exports.AssociateSoftwareTokenResponseFilterSensitiveLog = exports.AssociateSoftwareTokenRequestFilterSensitiveLog = exports.AdminUserGlobalSignOutRequestFilterSensitiveLog = exports.AdminUpdateUserAttributesRequestFilterSensitiveLog = exports.AdminUpdateDeviceStatusRequestFilterSensitiveLog = exports.AdminUpdateAuthEventFeedbackRequestFilterSensitiveLog = exports.AdminSetUserSettingsRequestFilterSensitiveLog = exports.AdminSetUserPasswordRequestFilterSensitiveLog = exports.AdminSetUserMFAPreferenceRequestFilterSensitiveLog = exports.AdminRespondToAuthChallengeResponseFilterSensitiveLog = exports.AdminRespondToAuthChallengeRequestFilterSensitiveLog = exports.AdminResetUserPasswordRequestFilterSensitiveLog = exports.AdminRemoveUserFromGroupRequestFilterSensitiveLog = exports.AdminListUserAuthEventsRequestFilterSensitiveLog = void 0;
exports.SetRiskConfigurationRequestFilterSensitiveLog = exports.RevokeTokenRequestFilterSensitiveLog = exports.RespondToAuthChallengeResponseFilterSensitiveLog = void 0;
const smithy_client_1 = __webpack_require__(18851);
const CognitoIdentityProviderServiceException_1 = __webpack_require__(69496);
exports.RecoveryOptionNameType = {
    ADMIN_ONLY: "admin_only",
    VERIFIED_EMAIL: "verified_email",
    VERIFIED_PHONE_NUMBER: "verified_phone_number"
};
exports.AccountTakeoverEventActionType = {
    BLOCK: "BLOCK",
    MFA_IF_CONFIGURED: "MFA_IF_CONFIGURED",
    MFA_REQUIRED: "MFA_REQUIRED",
    NO_ACTION: "NO_ACTION"
};
exports.AttributeDataType = {
    BOOLEAN: "Boolean",
    DATETIME: "DateTime",
    NUMBER: "Number",
    STRING: "String"
};
class InternalErrorException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "InternalErrorException",
            $fault: "server",
            ...opts
        });
        this.name = "InternalErrorException";
        this.$fault = "server";
        Object.setPrototypeOf(this, InternalErrorException.prototype);
    }
}
exports.InternalErrorException = InternalErrorException;
class InvalidParameterException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "InvalidParameterException",
            $fault: "client",
            ...opts
        });
        this.name = "InvalidParameterException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidParameterException.prototype);
    }
}
exports.InvalidParameterException = InvalidParameterException;
class NotAuthorizedException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "NotAuthorizedException",
            $fault: "client",
            ...opts
        });
        this.name = "NotAuthorizedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, NotAuthorizedException.prototype);
    }
}
exports.NotAuthorizedException = NotAuthorizedException;
class ResourceNotFoundException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    }
}
exports.ResourceNotFoundException = ResourceNotFoundException;
class TooManyRequestsException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "TooManyRequestsException",
            $fault: "client",
            ...opts
        });
        this.name = "TooManyRequestsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyRequestsException.prototype);
    }
}
exports.TooManyRequestsException = TooManyRequestsException;
class UserImportInProgressException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "UserImportInProgressException",
            $fault: "client",
            ...opts
        });
        this.name = "UserImportInProgressException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UserImportInProgressException.prototype);
    }
}
exports.UserImportInProgressException = UserImportInProgressException;
class UserNotFoundException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "UserNotFoundException",
            $fault: "client",
            ...opts
        });
        this.name = "UserNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UserNotFoundException.prototype);
    }
}
exports.UserNotFoundException = UserNotFoundException;
class InvalidLambdaResponseException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "InvalidLambdaResponseException",
            $fault: "client",
            ...opts
        });
        this.name = "InvalidLambdaResponseException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidLambdaResponseException.prototype);
    }
}
exports.InvalidLambdaResponseException = InvalidLambdaResponseException;
class LimitExceededException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "LimitExceededException",
            $fault: "client",
            ...opts
        });
        this.name = "LimitExceededException";
        this.$fault = "client";
        Object.setPrototypeOf(this, LimitExceededException.prototype);
    }
}
exports.LimitExceededException = LimitExceededException;
class TooManyFailedAttemptsException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "TooManyFailedAttemptsException",
            $fault: "client",
            ...opts
        });
        this.name = "TooManyFailedAttemptsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyFailedAttemptsException.prototype);
    }
}
exports.TooManyFailedAttemptsException = TooManyFailedAttemptsException;
class UnexpectedLambdaException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "UnexpectedLambdaException",
            $fault: "client",
            ...opts
        });
        this.name = "UnexpectedLambdaException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnexpectedLambdaException.prototype);
    }
}
exports.UnexpectedLambdaException = UnexpectedLambdaException;
class UserLambdaValidationException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "UserLambdaValidationException",
            $fault: "client",
            ...opts
        });
        this.name = "UserLambdaValidationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UserLambdaValidationException.prototype);
    }
}
exports.UserLambdaValidationException = UserLambdaValidationException;
exports.DeliveryMediumType = {
    EMAIL: "EMAIL",
    SMS: "SMS"
};
exports.MessageActionType = {
    RESEND: "RESEND",
    SUPPRESS: "SUPPRESS"
};
exports.UserStatusType = {
    ARCHIVED: "ARCHIVED",
    COMPROMISED: "COMPROMISED",
    CONFIRMED: "CONFIRMED",
    FORCE_CHANGE_PASSWORD: "FORCE_CHANGE_PASSWORD",
    RESET_REQUIRED: "RESET_REQUIRED",
    UNCONFIRMED: "UNCONFIRMED",
    UNKNOWN: "UNKNOWN"
};
class CodeDeliveryFailureException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "CodeDeliveryFailureException",
            $fault: "client",
            ...opts
        });
        this.name = "CodeDeliveryFailureException";
        this.$fault = "client";
        Object.setPrototypeOf(this, CodeDeliveryFailureException.prototype);
    }
}
exports.CodeDeliveryFailureException = CodeDeliveryFailureException;
class InvalidPasswordException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "InvalidPasswordException",
            $fault: "client",
            ...opts
        });
        this.name = "InvalidPasswordException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidPasswordException.prototype);
    }
}
exports.InvalidPasswordException = InvalidPasswordException;
class InvalidSmsRoleAccessPolicyException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "InvalidSmsRoleAccessPolicyException",
            $fault: "client",
            ...opts
        });
        this.name = "InvalidSmsRoleAccessPolicyException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidSmsRoleAccessPolicyException.prototype);
    }
}
exports.InvalidSmsRoleAccessPolicyException = InvalidSmsRoleAccessPolicyException;
class InvalidSmsRoleTrustRelationshipException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "InvalidSmsRoleTrustRelationshipException",
            $fault: "client",
            ...opts
        });
        this.name = "InvalidSmsRoleTrustRelationshipException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidSmsRoleTrustRelationshipException.prototype);
    }
}
exports.InvalidSmsRoleTrustRelationshipException = InvalidSmsRoleTrustRelationshipException;
class PreconditionNotMetException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "PreconditionNotMetException",
            $fault: "client",
            ...opts
        });
        this.name = "PreconditionNotMetException";
        this.$fault = "client";
        Object.setPrototypeOf(this, PreconditionNotMetException.prototype);
    }
}
exports.PreconditionNotMetException = PreconditionNotMetException;
class UnsupportedUserStateException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "UnsupportedUserStateException",
            $fault: "client",
            ...opts
        });
        this.name = "UnsupportedUserStateException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnsupportedUserStateException.prototype);
    }
}
exports.UnsupportedUserStateException = UnsupportedUserStateException;
class UsernameExistsException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "UsernameExistsException",
            $fault: "client",
            ...opts
        });
        this.name = "UsernameExistsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UsernameExistsException.prototype);
    }
}
exports.UsernameExistsException = UsernameExistsException;
class AliasExistsException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "AliasExistsException",
            $fault: "client",
            ...opts
        });
        this.name = "AliasExistsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, AliasExistsException.prototype);
    }
}
exports.AliasExistsException = AliasExistsException;
class InvalidUserPoolConfigurationException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "InvalidUserPoolConfigurationException",
            $fault: "client",
            ...opts
        });
        this.name = "InvalidUserPoolConfigurationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidUserPoolConfigurationException.prototype);
    }
}
exports.InvalidUserPoolConfigurationException = InvalidUserPoolConfigurationException;
exports.AuthFlowType = {
    ADMIN_NO_SRP_AUTH: "ADMIN_NO_SRP_AUTH",
    ADMIN_USER_PASSWORD_AUTH: "ADMIN_USER_PASSWORD_AUTH",
    CUSTOM_AUTH: "CUSTOM_AUTH",
    REFRESH_TOKEN: "REFRESH_TOKEN",
    REFRESH_TOKEN_AUTH: "REFRESH_TOKEN_AUTH",
    USER_PASSWORD_AUTH: "USER_PASSWORD_AUTH",
    USER_SRP_AUTH: "USER_SRP_AUTH"
};
exports.ChallengeNameType = {
    ADMIN_NO_SRP_AUTH: "ADMIN_NO_SRP_AUTH",
    CUSTOM_CHALLENGE: "CUSTOM_CHALLENGE",
    DEVICE_PASSWORD_VERIFIER: "DEVICE_PASSWORD_VERIFIER",
    DEVICE_SRP_AUTH: "DEVICE_SRP_AUTH",
    MFA_SETUP: "MFA_SETUP",
    NEW_PASSWORD_REQUIRED: "NEW_PASSWORD_REQUIRED",
    PASSWORD_VERIFIER: "PASSWORD_VERIFIER",
    SELECT_MFA_TYPE: "SELECT_MFA_TYPE",
    SMS_MFA: "SMS_MFA",
    SOFTWARE_TOKEN_MFA: "SOFTWARE_TOKEN_MFA"
};
class MFAMethodNotFoundException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "MFAMethodNotFoundException",
            $fault: "client",
            ...opts
        });
        this.name = "MFAMethodNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, MFAMethodNotFoundException.prototype);
    }
}
exports.MFAMethodNotFoundException = MFAMethodNotFoundException;
class PasswordResetRequiredException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "PasswordResetRequiredException",
            $fault: "client",
            ...opts
        });
        this.name = "PasswordResetRequiredException";
        this.$fault = "client";
        Object.setPrototypeOf(this, PasswordResetRequiredException.prototype);
    }
}
exports.PasswordResetRequiredException = PasswordResetRequiredException;
class UserNotConfirmedException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "UserNotConfirmedException",
            $fault: "client",
            ...opts
        });
        this.name = "UserNotConfirmedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UserNotConfirmedException.prototype);
    }
}
exports.UserNotConfirmedException = UserNotConfirmedException;
exports.ChallengeName = {
    Mfa: "Mfa",
    Password: "Password"
};
exports.ChallengeResponse = {
    Failure: "Failure",
    Success: "Success"
};
exports.FeedbackValueType = {
    INVALID: "Invalid",
    VALID: "Valid"
};
exports.EventResponseType = {
    Fail: "Fail",
    InProgress: "InProgress",
    Pass: "Pass"
};
exports.RiskDecisionType = {
    AccountTakeover: "AccountTakeover",
    Block: "Block",
    NoRisk: "NoRisk"
};
exports.RiskLevelType = {
    High: "High",
    Low: "Low",
    Medium: "Medium"
};
exports.EventType = {
    ForgotPassword: "ForgotPassword",
    PasswordChange: "PasswordChange",
    ResendCode: "ResendCode",
    SignIn: "SignIn",
    SignUp: "SignUp"
};
class UserPoolAddOnNotEnabledException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "UserPoolAddOnNotEnabledException",
            $fault: "client",
            ...opts
        });
        this.name = "UserPoolAddOnNotEnabledException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UserPoolAddOnNotEnabledException.prototype);
    }
}
exports.UserPoolAddOnNotEnabledException = UserPoolAddOnNotEnabledException;
class InvalidEmailRoleAccessPolicyException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "InvalidEmailRoleAccessPolicyException",
            $fault: "client",
            ...opts
        });
        this.name = "InvalidEmailRoleAccessPolicyException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidEmailRoleAccessPolicyException.prototype);
    }
}
exports.InvalidEmailRoleAccessPolicyException = InvalidEmailRoleAccessPolicyException;
class CodeMismatchException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "CodeMismatchException",
            $fault: "client",
            ...opts
        });
        this.name = "CodeMismatchException";
        this.$fault = "client";
        Object.setPrototypeOf(this, CodeMismatchException.prototype);
    }
}
exports.CodeMismatchException = CodeMismatchException;
class ExpiredCodeException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "ExpiredCodeException",
            $fault: "client",
            ...opts
        });
        this.name = "ExpiredCodeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ExpiredCodeException.prototype);
    }
}
exports.ExpiredCodeException = ExpiredCodeException;
class SoftwareTokenMFANotFoundException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "SoftwareTokenMFANotFoundException",
            $fault: "client",
            ...opts
        });
        this.name = "SoftwareTokenMFANotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, SoftwareTokenMFANotFoundException.prototype);
    }
}
exports.SoftwareTokenMFANotFoundException = SoftwareTokenMFANotFoundException;
exports.DeviceRememberedStatusType = {
    NOT_REMEMBERED: "not_remembered",
    REMEMBERED: "remembered"
};
exports.AdvancedSecurityModeType = {
    AUDIT: "AUDIT",
    ENFORCED: "ENFORCED",
    OFF: "OFF"
};
exports.AliasAttributeType = {
    EMAIL: "email",
    PHONE_NUMBER: "phone_number",
    PREFERRED_USERNAME: "preferred_username"
};
class ConcurrentModificationException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "ConcurrentModificationException",
            $fault: "client",
            ...opts
        });
        this.name = "ConcurrentModificationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ConcurrentModificationException.prototype);
    }
}
exports.ConcurrentModificationException = ConcurrentModificationException;
class ForbiddenException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "ForbiddenException",
            $fault: "client",
            ...opts
        });
        this.name = "ForbiddenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ForbiddenException.prototype);
    }
}
exports.ForbiddenException = ForbiddenException;
exports.VerifiedAttributeType = {
    EMAIL: "email",
    PHONE_NUMBER: "phone_number"
};
class GroupExistsException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "GroupExistsException",
            $fault: "client",
            ...opts
        });
        this.name = "GroupExistsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, GroupExistsException.prototype);
    }
}
exports.GroupExistsException = GroupExistsException;
exports.IdentityProviderTypeType = {
    Facebook: "Facebook",
    Google: "Google",
    LoginWithAmazon: "LoginWithAmazon",
    OIDC: "OIDC",
    SAML: "SAML",
    SignInWithApple: "SignInWithApple"
};
class DuplicateProviderException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "DuplicateProviderException",
            $fault: "client",
            ...opts
        });
        this.name = "DuplicateProviderException";
        this.$fault = "client";
        Object.setPrototypeOf(this, DuplicateProviderException.prototype);
    }
}
exports.DuplicateProviderException = DuplicateProviderException;
exports.UserImportJobStatusType = {
    Created: "Created",
    Expired: "Expired",
    Failed: "Failed",
    InProgress: "InProgress",
    Pending: "Pending",
    Stopped: "Stopped",
    Stopping: "Stopping",
    Succeeded: "Succeeded"
};
exports.DeletionProtectionType = {
    ACTIVE: "ACTIVE",
    INACTIVE: "INACTIVE"
};
exports.EmailSendingAccountType = {
    COGNITO_DEFAULT: "COGNITO_DEFAULT",
    DEVELOPER: "DEVELOPER"
};
exports.CustomEmailSenderLambdaVersionType = {
    V1_0: "V1_0"
};
exports.CustomSMSSenderLambdaVersionType = {
    V1_0: "V1_0"
};
exports.UserPoolMfaType = {
    OFF: "OFF",
    ON: "ON",
    OPTIONAL: "OPTIONAL"
};
exports.UsernameAttributeType = {
    EMAIL: "email",
    PHONE_NUMBER: "phone_number"
};
exports.DefaultEmailOptionType = {
    CONFIRM_WITH_CODE: "CONFIRM_WITH_CODE",
    CONFIRM_WITH_LINK: "CONFIRM_WITH_LINK"
};
exports.StatusType = {
    Disabled: "Disabled",
    Enabled: "Enabled"
};
class UserPoolTaggingException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "UserPoolTaggingException",
            $fault: "client",
            ...opts
        });
        this.name = "UserPoolTaggingException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UserPoolTaggingException.prototype);
    }
}
exports.UserPoolTaggingException = UserPoolTaggingException;
exports.OAuthFlowType = {
    client_credentials: "client_credentials",
    code: "code",
    implicit: "implicit"
};
exports.ExplicitAuthFlowsType = {
    ADMIN_NO_SRP_AUTH: "ADMIN_NO_SRP_AUTH",
    ALLOW_ADMIN_USER_PASSWORD_AUTH: "ALLOW_ADMIN_USER_PASSWORD_AUTH",
    ALLOW_CUSTOM_AUTH: "ALLOW_CUSTOM_AUTH",
    ALLOW_REFRESH_TOKEN_AUTH: "ALLOW_REFRESH_TOKEN_AUTH",
    ALLOW_USER_PASSWORD_AUTH: "ALLOW_USER_PASSWORD_AUTH",
    ALLOW_USER_SRP_AUTH: "ALLOW_USER_SRP_AUTH",
    CUSTOM_AUTH_FLOW_ONLY: "CUSTOM_AUTH_FLOW_ONLY",
    USER_PASSWORD_AUTH: "USER_PASSWORD_AUTH"
};
exports.PreventUserExistenceErrorTypes = {
    ENABLED: "ENABLED",
    LEGACY: "LEGACY"
};
exports.TimeUnitsType = {
    DAYS: "days",
    HOURS: "hours",
    MINUTES: "minutes",
    SECONDS: "seconds"
};
class InvalidOAuthFlowException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "InvalidOAuthFlowException",
            $fault: "client",
            ...opts
        });
        this.name = "InvalidOAuthFlowException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidOAuthFlowException.prototype);
    }
}
exports.InvalidOAuthFlowException = InvalidOAuthFlowException;
class ScopeDoesNotExistException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "ScopeDoesNotExistException",
            $fault: "client",
            ...opts
        });
        this.name = "ScopeDoesNotExistException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ScopeDoesNotExistException.prototype);
    }
}
exports.ScopeDoesNotExistException = ScopeDoesNotExistException;
class UnsupportedIdentityProviderException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "UnsupportedIdentityProviderException",
            $fault: "client",
            ...opts
        });
        this.name = "UnsupportedIdentityProviderException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnsupportedIdentityProviderException.prototype);
    }
}
exports.UnsupportedIdentityProviderException = UnsupportedIdentityProviderException;
exports.CompromisedCredentialsEventActionType = {
    BLOCK: "BLOCK",
    NO_ACTION: "NO_ACTION"
};
exports.EventFilterType = {
    PASSWORD_CHANGE: "PASSWORD_CHANGE",
    SIGN_IN: "SIGN_IN",
    SIGN_UP: "SIGN_UP"
};
exports.DomainStatusType = {
    ACTIVE: "ACTIVE",
    CREATING: "CREATING",
    DELETING: "DELETING",
    FAILED: "FAILED",
    UPDATING: "UPDATING"
};
exports.EventSourceName = {
    USER_NOTIFICATION: "userNotification"
};
exports.LogLevel = {
    ERROR: "ERROR"
};
class UnauthorizedException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "UnauthorizedException",
            $fault: "client",
            ...opts
        });
        this.name = "UnauthorizedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnauthorizedException.prototype);
    }
}
exports.UnauthorizedException = UnauthorizedException;
class UnsupportedOperationException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "UnsupportedOperationException",
            $fault: "client",
            ...opts
        });
        this.name = "UnsupportedOperationException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnsupportedOperationException.prototype);
    }
}
exports.UnsupportedOperationException = UnsupportedOperationException;
class UnsupportedTokenTypeException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "UnsupportedTokenTypeException",
            $fault: "client",
            ...opts
        });
        this.name = "UnsupportedTokenTypeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnsupportedTokenTypeException.prototype);
    }
}
exports.UnsupportedTokenTypeException = UnsupportedTokenTypeException;
const AdminAddUserToGroupRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminAddUserToGroupRequestFilterSensitiveLog = AdminAddUserToGroupRequestFilterSensitiveLog;
const AdminConfirmSignUpRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminConfirmSignUpRequestFilterSensitiveLog = AdminConfirmSignUpRequestFilterSensitiveLog;
const AttributeTypeFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Value && {
            Value: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AttributeTypeFilterSensitiveLog = AttributeTypeFilterSensitiveLog;
const AdminCreateUserRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.UserAttributes && {
            UserAttributes: obj.UserAttributes.map((item)=>(0, exports.AttributeTypeFilterSensitiveLog)(item))
        },
        ...obj.ValidationData && {
            ValidationData: obj.ValidationData.map((item)=>(0, exports.AttributeTypeFilterSensitiveLog)(item))
        },
        ...obj.TemporaryPassword && {
            TemporaryPassword: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminCreateUserRequestFilterSensitiveLog = AdminCreateUserRequestFilterSensitiveLog;
const UserTypeFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.Attributes && {
            Attributes: obj.Attributes.map((item)=>(0, exports.AttributeTypeFilterSensitiveLog)(item))
        }
    });
exports.UserTypeFilterSensitiveLog = UserTypeFilterSensitiveLog;
const AdminCreateUserResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.User && {
            User: (0, exports.UserTypeFilterSensitiveLog)(obj.User)
        }
    });
exports.AdminCreateUserResponseFilterSensitiveLog = AdminCreateUserResponseFilterSensitiveLog;
const AdminDeleteUserRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminDeleteUserRequestFilterSensitiveLog = AdminDeleteUserRequestFilterSensitiveLog;
const AdminDeleteUserAttributesRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminDeleteUserAttributesRequestFilterSensitiveLog = AdminDeleteUserAttributesRequestFilterSensitiveLog;
const AdminDisableUserRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminDisableUserRequestFilterSensitiveLog = AdminDisableUserRequestFilterSensitiveLog;
const AdminEnableUserRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminEnableUserRequestFilterSensitiveLog = AdminEnableUserRequestFilterSensitiveLog;
const AdminForgetDeviceRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminForgetDeviceRequestFilterSensitiveLog = AdminForgetDeviceRequestFilterSensitiveLog;
const AdminGetDeviceRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminGetDeviceRequestFilterSensitiveLog = AdminGetDeviceRequestFilterSensitiveLog;
const DeviceTypeFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.DeviceAttributes && {
            DeviceAttributes: obj.DeviceAttributes.map((item)=>(0, exports.AttributeTypeFilterSensitiveLog)(item))
        }
    });
exports.DeviceTypeFilterSensitiveLog = DeviceTypeFilterSensitiveLog;
const AdminGetDeviceResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Device && {
            Device: (0, exports.DeviceTypeFilterSensitiveLog)(obj.Device)
        }
    });
exports.AdminGetDeviceResponseFilterSensitiveLog = AdminGetDeviceResponseFilterSensitiveLog;
const AdminGetUserRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminGetUserRequestFilterSensitiveLog = AdminGetUserRequestFilterSensitiveLog;
const AdminGetUserResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.UserAttributes && {
            UserAttributes: obj.UserAttributes.map((item)=>(0, exports.AttributeTypeFilterSensitiveLog)(item))
        }
    });
exports.AdminGetUserResponseFilterSensitiveLog = AdminGetUserResponseFilterSensitiveLog;
const AdminInitiateAuthRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.AuthParameters && {
            AuthParameters: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminInitiateAuthRequestFilterSensitiveLog = AdminInitiateAuthRequestFilterSensitiveLog;
const AuthenticationResultTypeFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.RefreshToken && {
            RefreshToken: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.IdToken && {
            IdToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AuthenticationResultTypeFilterSensitiveLog = AuthenticationResultTypeFilterSensitiveLog;
const AdminInitiateAuthResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Session && {
            Session: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.AuthenticationResult && {
            AuthenticationResult: (0, exports.AuthenticationResultTypeFilterSensitiveLog)(obj.AuthenticationResult)
        }
    });
exports.AdminInitiateAuthResponseFilterSensitiveLog = AdminInitiateAuthResponseFilterSensitiveLog;
const AdminListDevicesRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminListDevicesRequestFilterSensitiveLog = AdminListDevicesRequestFilterSensitiveLog;
const AdminListDevicesResponseFilterSensitiveLog = (obj)=>({
        ...obj
    });
exports.AdminListDevicesResponseFilterSensitiveLog = AdminListDevicesResponseFilterSensitiveLog;
const AdminListGroupsForUserRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminListGroupsForUserRequestFilterSensitiveLog = AdminListGroupsForUserRequestFilterSensitiveLog;
const AdminListUserAuthEventsRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminListUserAuthEventsRequestFilterSensitiveLog = AdminListUserAuthEventsRequestFilterSensitiveLog;
const AdminRemoveUserFromGroupRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminRemoveUserFromGroupRequestFilterSensitiveLog = AdminRemoveUserFromGroupRequestFilterSensitiveLog;
const AdminResetUserPasswordRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminResetUserPasswordRequestFilterSensitiveLog = AdminResetUserPasswordRequestFilterSensitiveLog;
const AdminRespondToAuthChallengeRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.ChallengeResponses && {
            ChallengeResponses: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.Session && {
            Session: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminRespondToAuthChallengeRequestFilterSensitiveLog = AdminRespondToAuthChallengeRequestFilterSensitiveLog;
const AdminRespondToAuthChallengeResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Session && {
            Session: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.AuthenticationResult && {
            AuthenticationResult: (0, exports.AuthenticationResultTypeFilterSensitiveLog)(obj.AuthenticationResult)
        }
    });
exports.AdminRespondToAuthChallengeResponseFilterSensitiveLog = AdminRespondToAuthChallengeResponseFilterSensitiveLog;
const AdminSetUserMFAPreferenceRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminSetUserMFAPreferenceRequestFilterSensitiveLog = AdminSetUserMFAPreferenceRequestFilterSensitiveLog;
const AdminSetUserPasswordRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.Password && {
            Password: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminSetUserPasswordRequestFilterSensitiveLog = AdminSetUserPasswordRequestFilterSensitiveLog;
const AdminSetUserSettingsRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminSetUserSettingsRequestFilterSensitiveLog = AdminSetUserSettingsRequestFilterSensitiveLog;
const AdminUpdateAuthEventFeedbackRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminUpdateAuthEventFeedbackRequestFilterSensitiveLog = AdminUpdateAuthEventFeedbackRequestFilterSensitiveLog;
const AdminUpdateDeviceStatusRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminUpdateDeviceStatusRequestFilterSensitiveLog = AdminUpdateDeviceStatusRequestFilterSensitiveLog;
const AdminUpdateUserAttributesRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.UserAttributes && {
            UserAttributes: obj.UserAttributes.map((item)=>(0, exports.AttributeTypeFilterSensitiveLog)(item))
        }
    });
exports.AdminUpdateUserAttributesRequestFilterSensitiveLog = AdminUpdateUserAttributesRequestFilterSensitiveLog;
const AdminUserGlobalSignOutRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AdminUserGlobalSignOutRequestFilterSensitiveLog = AdminUserGlobalSignOutRequestFilterSensitiveLog;
const AssociateSoftwareTokenRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.Session && {
            Session: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AssociateSoftwareTokenRequestFilterSensitiveLog = AssociateSoftwareTokenRequestFilterSensitiveLog;
const AssociateSoftwareTokenResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.SecretCode && {
            SecretCode: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.Session && {
            Session: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AssociateSoftwareTokenResponseFilterSensitiveLog = AssociateSoftwareTokenResponseFilterSensitiveLog;
const ChangePasswordRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.PreviousPassword && {
            PreviousPassword: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.ProposedPassword && {
            ProposedPassword: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.ChangePasswordRequestFilterSensitiveLog = ChangePasswordRequestFilterSensitiveLog;
const ConfirmDeviceRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.ConfirmDeviceRequestFilterSensitiveLog = ConfirmDeviceRequestFilterSensitiveLog;
const UserContextDataTypeFilterSensitiveLog = (obj)=>({
        ...obj
    });
exports.UserContextDataTypeFilterSensitiveLog = UserContextDataTypeFilterSensitiveLog;
const ConfirmForgotPasswordRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.SecretHash && {
            SecretHash: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.Password && {
            Password: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.UserContextData && {
            UserContextData: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.ConfirmForgotPasswordRequestFilterSensitiveLog = ConfirmForgotPasswordRequestFilterSensitiveLog;
const ConfirmSignUpRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.SecretHash && {
            SecretHash: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.UserContextData && {
            UserContextData: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.ConfirmSignUpRequestFilterSensitiveLog = ConfirmSignUpRequestFilterSensitiveLog;
const UserPoolClientTypeFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.ClientSecret && {
            ClientSecret: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.UserPoolClientTypeFilterSensitiveLog = UserPoolClientTypeFilterSensitiveLog;
const CreateUserPoolClientResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.UserPoolClient && {
            UserPoolClient: (0, exports.UserPoolClientTypeFilterSensitiveLog)(obj.UserPoolClient)
        }
    });
exports.CreateUserPoolClientResponseFilterSensitiveLog = CreateUserPoolClientResponseFilterSensitiveLog;
const DeleteUserRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.DeleteUserRequestFilterSensitiveLog = DeleteUserRequestFilterSensitiveLog;
const DeleteUserAttributesRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.DeleteUserAttributesRequestFilterSensitiveLog = DeleteUserAttributesRequestFilterSensitiveLog;
const DeleteUserPoolClientRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.DeleteUserPoolClientRequestFilterSensitiveLog = DeleteUserPoolClientRequestFilterSensitiveLog;
const DescribeRiskConfigurationRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.DescribeRiskConfigurationRequestFilterSensitiveLog = DescribeRiskConfigurationRequestFilterSensitiveLog;
const RiskConfigurationTypeFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.RiskConfigurationTypeFilterSensitiveLog = RiskConfigurationTypeFilterSensitiveLog;
const DescribeRiskConfigurationResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.RiskConfiguration && {
            RiskConfiguration: (0, exports.RiskConfigurationTypeFilterSensitiveLog)(obj.RiskConfiguration)
        }
    });
exports.DescribeRiskConfigurationResponseFilterSensitiveLog = DescribeRiskConfigurationResponseFilterSensitiveLog;
const DescribeUserPoolClientRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.DescribeUserPoolClientRequestFilterSensitiveLog = DescribeUserPoolClientRequestFilterSensitiveLog;
const DescribeUserPoolClientResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.UserPoolClient && {
            UserPoolClient: (0, exports.UserPoolClientTypeFilterSensitiveLog)(obj.UserPoolClient)
        }
    });
exports.DescribeUserPoolClientResponseFilterSensitiveLog = DescribeUserPoolClientResponseFilterSensitiveLog;
const ForgetDeviceRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.ForgetDeviceRequestFilterSensitiveLog = ForgetDeviceRequestFilterSensitiveLog;
const ForgotPasswordRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.SecretHash && {
            SecretHash: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.UserContextData && {
            UserContextData: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.ForgotPasswordRequestFilterSensitiveLog = ForgotPasswordRequestFilterSensitiveLog;
const GetDeviceRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.GetDeviceRequestFilterSensitiveLog = GetDeviceRequestFilterSensitiveLog;
const GetDeviceResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Device && {
            Device: (0, exports.DeviceTypeFilterSensitiveLog)(obj.Device)
        }
    });
exports.GetDeviceResponseFilterSensitiveLog = GetDeviceResponseFilterSensitiveLog;
const GetUICustomizationRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.GetUICustomizationRequestFilterSensitiveLog = GetUICustomizationRequestFilterSensitiveLog;
const UICustomizationTypeFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.UICustomizationTypeFilterSensitiveLog = UICustomizationTypeFilterSensitiveLog;
const GetUICustomizationResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.UICustomization && {
            UICustomization: (0, exports.UICustomizationTypeFilterSensitiveLog)(obj.UICustomization)
        }
    });
exports.GetUICustomizationResponseFilterSensitiveLog = GetUICustomizationResponseFilterSensitiveLog;
const GetUserRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.GetUserRequestFilterSensitiveLog = GetUserRequestFilterSensitiveLog;
const GetUserResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.UserAttributes && {
            UserAttributes: obj.UserAttributes.map((item)=>(0, exports.AttributeTypeFilterSensitiveLog)(item))
        }
    });
exports.GetUserResponseFilterSensitiveLog = GetUserResponseFilterSensitiveLog;
const GetUserAttributeVerificationCodeRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.GetUserAttributeVerificationCodeRequestFilterSensitiveLog = GetUserAttributeVerificationCodeRequestFilterSensitiveLog;
const GlobalSignOutRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.GlobalSignOutRequestFilterSensitiveLog = GlobalSignOutRequestFilterSensitiveLog;
const InitiateAuthRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.AuthParameters && {
            AuthParameters: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.UserContextData && {
            UserContextData: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.InitiateAuthRequestFilterSensitiveLog = InitiateAuthRequestFilterSensitiveLog;
const InitiateAuthResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Session && {
            Session: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.AuthenticationResult && {
            AuthenticationResult: (0, exports.AuthenticationResultTypeFilterSensitiveLog)(obj.AuthenticationResult)
        }
    });
exports.InitiateAuthResponseFilterSensitiveLog = InitiateAuthResponseFilterSensitiveLog;
const ListDevicesRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.ListDevicesRequestFilterSensitiveLog = ListDevicesRequestFilterSensitiveLog;
const ListDevicesResponseFilterSensitiveLog = (obj)=>({
        ...obj
    });
exports.ListDevicesResponseFilterSensitiveLog = ListDevicesResponseFilterSensitiveLog;
const UserPoolClientDescriptionFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.UserPoolClientDescriptionFilterSensitiveLog = UserPoolClientDescriptionFilterSensitiveLog;
const ListUserPoolClientsResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.UserPoolClients && {
            UserPoolClients: obj.UserPoolClients.map((item)=>(0, exports.UserPoolClientDescriptionFilterSensitiveLog)(item))
        }
    });
exports.ListUserPoolClientsResponseFilterSensitiveLog = ListUserPoolClientsResponseFilterSensitiveLog;
const ListUsersResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Users && {
            Users: obj.Users.map((item)=>(0, exports.UserTypeFilterSensitiveLog)(item))
        }
    });
exports.ListUsersResponseFilterSensitiveLog = ListUsersResponseFilterSensitiveLog;
const ListUsersInGroupResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Users && {
            Users: obj.Users.map((item)=>(0, exports.UserTypeFilterSensitiveLog)(item))
        }
    });
exports.ListUsersInGroupResponseFilterSensitiveLog = ListUsersInGroupResponseFilterSensitiveLog;
const ResendConfirmationCodeRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.SecretHash && {
            SecretHash: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.UserContextData && {
            UserContextData: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.ResendConfirmationCodeRequestFilterSensitiveLog = ResendConfirmationCodeRequestFilterSensitiveLog;
const RespondToAuthChallengeRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.Session && {
            Session: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.ChallengeResponses && {
            ChallengeResponses: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.UserContextData && {
            UserContextData: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.RespondToAuthChallengeRequestFilterSensitiveLog = RespondToAuthChallengeRequestFilterSensitiveLog;
const RespondToAuthChallengeResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Session && {
            Session: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.AuthenticationResult && {
            AuthenticationResult: (0, exports.AuthenticationResultTypeFilterSensitiveLog)(obj.AuthenticationResult)
        }
    });
exports.RespondToAuthChallengeResponseFilterSensitiveLog = RespondToAuthChallengeResponseFilterSensitiveLog;
const RevokeTokenRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Token && {
            Token: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.ClientSecret && {
            ClientSecret: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.RevokeTokenRequestFilterSensitiveLog = RevokeTokenRequestFilterSensitiveLog;
const SetRiskConfigurationRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.SetRiskConfigurationRequestFilterSensitiveLog = SetRiskConfigurationRequestFilterSensitiveLog;


/***/ }),

/***/ 50646:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.VerifyUserAttributeRequestFilterSensitiveLog = exports.VerifySoftwareTokenResponseFilterSensitiveLog = exports.VerifySoftwareTokenRequestFilterSensitiveLog = exports.UpdateUserPoolClientResponseFilterSensitiveLog = exports.UpdateUserPoolClientRequestFilterSensitiveLog = exports.UpdateUserAttributesRequestFilterSensitiveLog = exports.UpdateDeviceStatusRequestFilterSensitiveLog = exports.UpdateAuthEventFeedbackRequestFilterSensitiveLog = exports.SignUpRequestFilterSensitiveLog = exports.SetUserSettingsRequestFilterSensitiveLog = exports.SetUserMFAPreferenceRequestFilterSensitiveLog = exports.SetUICustomizationResponseFilterSensitiveLog = exports.SetUICustomizationRequestFilterSensitiveLog = exports.SetRiskConfigurationResponseFilterSensitiveLog = exports.VerifySoftwareTokenResponseType = exports.EnableSoftwareTokenMFAException = void 0;
const smithy_client_1 = __webpack_require__(18851);
const CognitoIdentityProviderServiceException_1 = __webpack_require__(69496);
const models_0_1 = __webpack_require__(8257);
class EnableSoftwareTokenMFAException extends CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException {
    constructor(opts){
        super({
            name: "EnableSoftwareTokenMFAException",
            $fault: "client",
            ...opts
        });
        this.name = "EnableSoftwareTokenMFAException";
        this.$fault = "client";
        Object.setPrototypeOf(this, EnableSoftwareTokenMFAException.prototype);
    }
}
exports.EnableSoftwareTokenMFAException = EnableSoftwareTokenMFAException;
exports.VerifySoftwareTokenResponseType = {
    ERROR: "ERROR",
    SUCCESS: "SUCCESS"
};
const SetRiskConfigurationResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.RiskConfiguration && {
            RiskConfiguration: (0, models_0_1.RiskConfigurationTypeFilterSensitiveLog)(obj.RiskConfiguration)
        }
    });
exports.SetRiskConfigurationResponseFilterSensitiveLog = SetRiskConfigurationResponseFilterSensitiveLog;
const SetUICustomizationRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.SetUICustomizationRequestFilterSensitiveLog = SetUICustomizationRequestFilterSensitiveLog;
const SetUICustomizationResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.UICustomization && {
            UICustomization: (0, models_0_1.UICustomizationTypeFilterSensitiveLog)(obj.UICustomization)
        }
    });
exports.SetUICustomizationResponseFilterSensitiveLog = SetUICustomizationResponseFilterSensitiveLog;
const SetUserMFAPreferenceRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.SetUserMFAPreferenceRequestFilterSensitiveLog = SetUserMFAPreferenceRequestFilterSensitiveLog;
const SetUserSettingsRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.SetUserSettingsRequestFilterSensitiveLog = SetUserSettingsRequestFilterSensitiveLog;
const SignUpRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.SecretHash && {
            SecretHash: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.Password && {
            Password: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.UserAttributes && {
            UserAttributes: obj.UserAttributes.map((item)=>(0, models_0_1.AttributeTypeFilterSensitiveLog)(item))
        },
        ...obj.ValidationData && {
            ValidationData: obj.ValidationData.map((item)=>(0, models_0_1.AttributeTypeFilterSensitiveLog)(item))
        },
        ...obj.UserContextData && {
            UserContextData: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.SignUpRequestFilterSensitiveLog = SignUpRequestFilterSensitiveLog;
const UpdateAuthEventFeedbackRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Username && {
            Username: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.FeedbackToken && {
            FeedbackToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.UpdateAuthEventFeedbackRequestFilterSensitiveLog = UpdateAuthEventFeedbackRequestFilterSensitiveLog;
const UpdateDeviceStatusRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.UpdateDeviceStatusRequestFilterSensitiveLog = UpdateDeviceStatusRequestFilterSensitiveLog;
const UpdateUserAttributesRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.UserAttributes && {
            UserAttributes: obj.UserAttributes.map((item)=>(0, models_0_1.AttributeTypeFilterSensitiveLog)(item))
        },
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.UpdateUserAttributesRequestFilterSensitiveLog = UpdateUserAttributesRequestFilterSensitiveLog;
const UpdateUserPoolClientRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.ClientId && {
            ClientId: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.UpdateUserPoolClientRequestFilterSensitiveLog = UpdateUserPoolClientRequestFilterSensitiveLog;
const UpdateUserPoolClientResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.UserPoolClient && {
            UserPoolClient: (0, models_0_1.UserPoolClientTypeFilterSensitiveLog)(obj.UserPoolClient)
        }
    });
exports.UpdateUserPoolClientResponseFilterSensitiveLog = UpdateUserPoolClientResponseFilterSensitiveLog;
const VerifySoftwareTokenRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.Session && {
            Session: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.UserCode && {
            UserCode: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.VerifySoftwareTokenRequestFilterSensitiveLog = VerifySoftwareTokenRequestFilterSensitiveLog;
const VerifySoftwareTokenResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Session && {
            Session: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.VerifySoftwareTokenResponseFilterSensitiveLog = VerifySoftwareTokenResponseFilterSensitiveLog;
const VerifyUserAttributeRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.AccessToken && {
            AccessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.VerifyUserAttributeRequestFilterSensitiveLog = VerifyUserAttributeRequestFilterSensitiveLog;


/***/ }),

/***/ 71126:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.paginateAdminListGroupsForUser = void 0;
const CognitoIdentityProviderClient_1 = __webpack_require__(85228);
const AdminListGroupsForUserCommand_1 = __webpack_require__(55328);
const makePagedClientRequest = async (client, input, ...args)=>{
    return await client.send(new AdminListGroupsForUserCommand_1.AdminListGroupsForUserCommand(input), ...args);
};
async function* paginateAdminListGroupsForUser(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while(hasNext){
        input.NextToken = token;
        input["Limit"] = config.pageSize;
        if (config.client instanceof CognitoIdentityProviderClient_1.CognitoIdentityProviderClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateAdminListGroupsForUser = paginateAdminListGroupsForUser;


/***/ }),

/***/ 10363:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.paginateAdminListUserAuthEvents = void 0;
const CognitoIdentityProviderClient_1 = __webpack_require__(85228);
const AdminListUserAuthEventsCommand_1 = __webpack_require__(21606);
const makePagedClientRequest = async (client, input, ...args)=>{
    return await client.send(new AdminListUserAuthEventsCommand_1.AdminListUserAuthEventsCommand(input), ...args);
};
async function* paginateAdminListUserAuthEvents(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while(hasNext){
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof CognitoIdentityProviderClient_1.CognitoIdentityProviderClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateAdminListUserAuthEvents = paginateAdminListUserAuthEvents;


/***/ }),

/***/ 80098:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 98947:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.paginateListGroups = void 0;
const CognitoIdentityProviderClient_1 = __webpack_require__(85228);
const ListGroupsCommand_1 = __webpack_require__(19010);
const makePagedClientRequest = async (client, input, ...args)=>{
    return await client.send(new ListGroupsCommand_1.ListGroupsCommand(input), ...args);
};
async function* paginateListGroups(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while(hasNext){
        input.NextToken = token;
        input["Limit"] = config.pageSize;
        if (config.client instanceof CognitoIdentityProviderClient_1.CognitoIdentityProviderClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListGroups = paginateListGroups;


/***/ }),

/***/ 28449:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.paginateListIdentityProviders = void 0;
const CognitoIdentityProviderClient_1 = __webpack_require__(85228);
const ListIdentityProvidersCommand_1 = __webpack_require__(40247);
const makePagedClientRequest = async (client, input, ...args)=>{
    return await client.send(new ListIdentityProvidersCommand_1.ListIdentityProvidersCommand(input), ...args);
};
async function* paginateListIdentityProviders(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while(hasNext){
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof CognitoIdentityProviderClient_1.CognitoIdentityProviderClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListIdentityProviders = paginateListIdentityProviders;


/***/ }),

/***/ 28791:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.paginateListResourceServers = void 0;
const CognitoIdentityProviderClient_1 = __webpack_require__(85228);
const ListResourceServersCommand_1 = __webpack_require__(67716);
const makePagedClientRequest = async (client, input, ...args)=>{
    return await client.send(new ListResourceServersCommand_1.ListResourceServersCommand(input), ...args);
};
async function* paginateListResourceServers(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while(hasNext){
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof CognitoIdentityProviderClient_1.CognitoIdentityProviderClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListResourceServers = paginateListResourceServers;


/***/ }),

/***/ 61978:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.paginateListUserPoolClients = void 0;
const CognitoIdentityProviderClient_1 = __webpack_require__(85228);
const ListUserPoolClientsCommand_1 = __webpack_require__(48532);
const makePagedClientRequest = async (client, input, ...args)=>{
    return await client.send(new ListUserPoolClientsCommand_1.ListUserPoolClientsCommand(input), ...args);
};
async function* paginateListUserPoolClients(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while(hasNext){
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof CognitoIdentityProviderClient_1.CognitoIdentityProviderClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListUserPoolClients = paginateListUserPoolClients;


/***/ }),

/***/ 11292:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.paginateListUserPools = void 0;
const CognitoIdentityProviderClient_1 = __webpack_require__(85228);
const ListUserPoolsCommand_1 = __webpack_require__(42083);
const makePagedClientRequest = async (client, input, ...args)=>{
    return await client.send(new ListUserPoolsCommand_1.ListUserPoolsCommand(input), ...args);
};
async function* paginateListUserPools(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while(hasNext){
        input.NextToken = token;
        input["MaxResults"] = config.pageSize;
        if (config.client instanceof CognitoIdentityProviderClient_1.CognitoIdentityProviderClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListUserPools = paginateListUserPools;


/***/ }),

/***/ 95491:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.paginateListUsersInGroup = void 0;
const CognitoIdentityProviderClient_1 = __webpack_require__(85228);
const ListUsersInGroupCommand_1 = __webpack_require__(27102);
const makePagedClientRequest = async (client, input, ...args)=>{
    return await client.send(new ListUsersInGroupCommand_1.ListUsersInGroupCommand(input), ...args);
};
async function* paginateListUsersInGroup(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while(hasNext){
        input.NextToken = token;
        input["Limit"] = config.pageSize;
        if (config.client instanceof CognitoIdentityProviderClient_1.CognitoIdentityProviderClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
        }
        yield page;
        const prevToken = token;
        token = page.NextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListUsersInGroup = paginateListUsersInGroup;


/***/ }),

/***/ 69112:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.paginateListUsers = void 0;
const CognitoIdentityProviderClient_1 = __webpack_require__(85228);
const ListUsersCommand_1 = __webpack_require__(60086);
const makePagedClientRequest = async (client, input, ...args)=>{
    return await client.send(new ListUsersCommand_1.ListUsersCommand(input), ...args);
};
async function* paginateListUsers(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while(hasNext){
        input.PaginationToken = token;
        input["Limit"] = config.pageSize;
        if (config.client instanceof CognitoIdentityProviderClient_1.CognitoIdentityProviderClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        } else {
            throw new Error("Invalid client, expected CognitoIdentityProvider | CognitoIdentityProviderClient");
        }
        yield page;
        const prevToken = token;
        token = page.PaginationToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListUsers = paginateListUsers;


/***/ }),

/***/ 67333:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(71126), exports);
tslib_1.__exportStar(__webpack_require__(10363), exports);
tslib_1.__exportStar(__webpack_require__(80098), exports);
tslib_1.__exportStar(__webpack_require__(98947), exports);
tslib_1.__exportStar(__webpack_require__(28449), exports);
tslib_1.__exportStar(__webpack_require__(28791), exports);
tslib_1.__exportStar(__webpack_require__(61978), exports);
tslib_1.__exportStar(__webpack_require__(11292), exports);
tslib_1.__exportStar(__webpack_require__(95491), exports);
tslib_1.__exportStar(__webpack_require__(69112), exports);


/***/ }),

/***/ 82965:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.se_DescribeRiskConfigurationCommand = exports.se_DescribeResourceServerCommand = exports.se_DescribeIdentityProviderCommand = exports.se_DeleteUserPoolDomainCommand = exports.se_DeleteUserPoolClientCommand = exports.se_DeleteUserPoolCommand = exports.se_DeleteUserAttributesCommand = exports.se_DeleteUserCommand = exports.se_DeleteResourceServerCommand = exports.se_DeleteIdentityProviderCommand = exports.se_DeleteGroupCommand = exports.se_CreateUserPoolDomainCommand = exports.se_CreateUserPoolClientCommand = exports.se_CreateUserPoolCommand = exports.se_CreateUserImportJobCommand = exports.se_CreateResourceServerCommand = exports.se_CreateIdentityProviderCommand = exports.se_CreateGroupCommand = exports.se_ConfirmSignUpCommand = exports.se_ConfirmForgotPasswordCommand = exports.se_ConfirmDeviceCommand = exports.se_ChangePasswordCommand = exports.se_AssociateSoftwareTokenCommand = exports.se_AdminUserGlobalSignOutCommand = exports.se_AdminUpdateUserAttributesCommand = exports.se_AdminUpdateDeviceStatusCommand = exports.se_AdminUpdateAuthEventFeedbackCommand = exports.se_AdminSetUserSettingsCommand = exports.se_AdminSetUserPasswordCommand = exports.se_AdminSetUserMFAPreferenceCommand = exports.se_AdminRespondToAuthChallengeCommand = exports.se_AdminResetUserPasswordCommand = exports.se_AdminRemoveUserFromGroupCommand = exports.se_AdminListUserAuthEventsCommand = exports.se_AdminListGroupsForUserCommand = exports.se_AdminListDevicesCommand = exports.se_AdminLinkProviderForUserCommand = exports.se_AdminInitiateAuthCommand = exports.se_AdminGetUserCommand = exports.se_AdminGetDeviceCommand = exports.se_AdminForgetDeviceCommand = exports.se_AdminEnableUserCommand = exports.se_AdminDisableUserCommand = exports.se_AdminDisableProviderForUserCommand = exports.se_AdminDeleteUserAttributesCommand = exports.se_AdminDeleteUserCommand = exports.se_AdminCreateUserCommand = exports.se_AdminConfirmSignUpCommand = exports.se_AdminAddUserToGroupCommand = exports.se_AddCustomAttributesCommand = void 0;
exports.se_UpdateUserPoolClientCommand = exports.se_UpdateUserPoolCommand = exports.se_UpdateUserAttributesCommand = exports.se_UpdateResourceServerCommand = exports.se_UpdateIdentityProviderCommand = exports.se_UpdateGroupCommand = exports.se_UpdateDeviceStatusCommand = exports.se_UpdateAuthEventFeedbackCommand = exports.se_UntagResourceCommand = exports.se_TagResourceCommand = exports.se_StopUserImportJobCommand = exports.se_StartUserImportJobCommand = exports.se_SignUpCommand = exports.se_SetUserSettingsCommand = exports.se_SetUserPoolMfaConfigCommand = exports.se_SetUserMFAPreferenceCommand = exports.se_SetUICustomizationCommand = exports.se_SetRiskConfigurationCommand = exports.se_SetLogDeliveryConfigurationCommand = exports.se_RevokeTokenCommand = exports.se_RespondToAuthChallengeCommand = exports.se_ResendConfirmationCodeCommand = exports.se_ListUsersInGroupCommand = exports.se_ListUsersCommand = exports.se_ListUserPoolsCommand = exports.se_ListUserPoolClientsCommand = exports.se_ListUserImportJobsCommand = exports.se_ListTagsForResourceCommand = exports.se_ListResourceServersCommand = exports.se_ListIdentityProvidersCommand = exports.se_ListGroupsCommand = exports.se_ListDevicesCommand = exports.se_InitiateAuthCommand = exports.se_GlobalSignOutCommand = exports.se_GetUserPoolMfaConfigCommand = exports.se_GetUserAttributeVerificationCodeCommand = exports.se_GetUserCommand = exports.se_GetUICustomizationCommand = exports.se_GetSigningCertificateCommand = exports.se_GetLogDeliveryConfigurationCommand = exports.se_GetIdentityProviderByIdentifierCommand = exports.se_GetGroupCommand = exports.se_GetDeviceCommand = exports.se_GetCSVHeaderCommand = exports.se_ForgotPasswordCommand = exports.se_ForgetDeviceCommand = exports.se_DescribeUserPoolDomainCommand = exports.se_DescribeUserPoolClientCommand = exports.se_DescribeUserPoolCommand = exports.se_DescribeUserImportJobCommand = void 0;
exports.de_DeleteUserPoolDomainCommand = exports.de_DeleteUserPoolClientCommand = exports.de_DeleteUserPoolCommand = exports.de_DeleteUserAttributesCommand = exports.de_DeleteUserCommand = exports.de_DeleteResourceServerCommand = exports.de_DeleteIdentityProviderCommand = exports.de_DeleteGroupCommand = exports.de_CreateUserPoolDomainCommand = exports.de_CreateUserPoolClientCommand = exports.de_CreateUserPoolCommand = exports.de_CreateUserImportJobCommand = exports.de_CreateResourceServerCommand = exports.de_CreateIdentityProviderCommand = exports.de_CreateGroupCommand = exports.de_ConfirmSignUpCommand = exports.de_ConfirmForgotPasswordCommand = exports.de_ConfirmDeviceCommand = exports.de_ChangePasswordCommand = exports.de_AssociateSoftwareTokenCommand = exports.de_AdminUserGlobalSignOutCommand = exports.de_AdminUpdateUserAttributesCommand = exports.de_AdminUpdateDeviceStatusCommand = exports.de_AdminUpdateAuthEventFeedbackCommand = exports.de_AdminSetUserSettingsCommand = exports.de_AdminSetUserPasswordCommand = exports.de_AdminSetUserMFAPreferenceCommand = exports.de_AdminRespondToAuthChallengeCommand = exports.de_AdminResetUserPasswordCommand = exports.de_AdminRemoveUserFromGroupCommand = exports.de_AdminListUserAuthEventsCommand = exports.de_AdminListGroupsForUserCommand = exports.de_AdminListDevicesCommand = exports.de_AdminLinkProviderForUserCommand = exports.de_AdminInitiateAuthCommand = exports.de_AdminGetUserCommand = exports.de_AdminGetDeviceCommand = exports.de_AdminForgetDeviceCommand = exports.de_AdminEnableUserCommand = exports.de_AdminDisableUserCommand = exports.de_AdminDisableProviderForUserCommand = exports.de_AdminDeleteUserAttributesCommand = exports.de_AdminDeleteUserCommand = exports.de_AdminCreateUserCommand = exports.de_AdminConfirmSignUpCommand = exports.de_AdminAddUserToGroupCommand = exports.de_AddCustomAttributesCommand = exports.se_VerifyUserAttributeCommand = exports.se_VerifySoftwareTokenCommand = exports.se_UpdateUserPoolDomainCommand = void 0;
exports.de_UpdateResourceServerCommand = exports.de_UpdateIdentityProviderCommand = exports.de_UpdateGroupCommand = exports.de_UpdateDeviceStatusCommand = exports.de_UpdateAuthEventFeedbackCommand = exports.de_UntagResourceCommand = exports.de_TagResourceCommand = exports.de_StopUserImportJobCommand = exports.de_StartUserImportJobCommand = exports.de_SignUpCommand = exports.de_SetUserSettingsCommand = exports.de_SetUserPoolMfaConfigCommand = exports.de_SetUserMFAPreferenceCommand = exports.de_SetUICustomizationCommand = exports.de_SetRiskConfigurationCommand = exports.de_SetLogDeliveryConfigurationCommand = exports.de_RevokeTokenCommand = exports.de_RespondToAuthChallengeCommand = exports.de_ResendConfirmationCodeCommand = exports.de_ListUsersInGroupCommand = exports.de_ListUsersCommand = exports.de_ListUserPoolsCommand = exports.de_ListUserPoolClientsCommand = exports.de_ListUserImportJobsCommand = exports.de_ListTagsForResourceCommand = exports.de_ListResourceServersCommand = exports.de_ListIdentityProvidersCommand = exports.de_ListGroupsCommand = exports.de_ListDevicesCommand = exports.de_InitiateAuthCommand = exports.de_GlobalSignOutCommand = exports.de_GetUserPoolMfaConfigCommand = exports.de_GetUserAttributeVerificationCodeCommand = exports.de_GetUserCommand = exports.de_GetUICustomizationCommand = exports.de_GetSigningCertificateCommand = exports.de_GetLogDeliveryConfigurationCommand = exports.de_GetIdentityProviderByIdentifierCommand = exports.de_GetGroupCommand = exports.de_GetDeviceCommand = exports.de_GetCSVHeaderCommand = exports.de_ForgotPasswordCommand = exports.de_ForgetDeviceCommand = exports.de_DescribeUserPoolDomainCommand = exports.de_DescribeUserPoolClientCommand = exports.de_DescribeUserPoolCommand = exports.de_DescribeUserImportJobCommand = exports.de_DescribeRiskConfigurationCommand = exports.de_DescribeResourceServerCommand = exports.de_DescribeIdentityProviderCommand = void 0;
exports.de_VerifyUserAttributeCommand = exports.de_VerifySoftwareTokenCommand = exports.de_UpdateUserPoolDomainCommand = exports.de_UpdateUserPoolClientCommand = exports.de_UpdateUserPoolCommand = exports.de_UpdateUserAttributesCommand = void 0;
const protocol_http_1 = __webpack_require__(64082);
const smithy_client_1 = __webpack_require__(18851);
const CognitoIdentityProviderServiceException_1 = __webpack_require__(69496);
const models_0_1 = __webpack_require__(8257);
const models_1_1 = __webpack_require__(50646);
const se_AddCustomAttributesCommand = async (input, context)=>{
    const headers = sharedHeaders("AddCustomAttributes");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AddCustomAttributesCommand = se_AddCustomAttributesCommand;
const se_AdminAddUserToGroupCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminAddUserToGroup");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminAddUserToGroupCommand = se_AdminAddUserToGroupCommand;
const se_AdminConfirmSignUpCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminConfirmSignUp");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminConfirmSignUpCommand = se_AdminConfirmSignUpCommand;
const se_AdminCreateUserCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminCreateUser");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminCreateUserCommand = se_AdminCreateUserCommand;
const se_AdminDeleteUserCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminDeleteUser");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminDeleteUserCommand = se_AdminDeleteUserCommand;
const se_AdminDeleteUserAttributesCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminDeleteUserAttributes");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminDeleteUserAttributesCommand = se_AdminDeleteUserAttributesCommand;
const se_AdminDisableProviderForUserCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminDisableProviderForUser");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminDisableProviderForUserCommand = se_AdminDisableProviderForUserCommand;
const se_AdminDisableUserCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminDisableUser");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminDisableUserCommand = se_AdminDisableUserCommand;
const se_AdminEnableUserCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminEnableUser");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminEnableUserCommand = se_AdminEnableUserCommand;
const se_AdminForgetDeviceCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminForgetDevice");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminForgetDeviceCommand = se_AdminForgetDeviceCommand;
const se_AdminGetDeviceCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminGetDevice");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminGetDeviceCommand = se_AdminGetDeviceCommand;
const se_AdminGetUserCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminGetUser");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminGetUserCommand = se_AdminGetUserCommand;
const se_AdminInitiateAuthCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminInitiateAuth");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminInitiateAuthCommand = se_AdminInitiateAuthCommand;
const se_AdminLinkProviderForUserCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminLinkProviderForUser");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminLinkProviderForUserCommand = se_AdminLinkProviderForUserCommand;
const se_AdminListDevicesCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminListDevices");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminListDevicesCommand = se_AdminListDevicesCommand;
const se_AdminListGroupsForUserCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminListGroupsForUser");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminListGroupsForUserCommand = se_AdminListGroupsForUserCommand;
const se_AdminListUserAuthEventsCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminListUserAuthEvents");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminListUserAuthEventsCommand = se_AdminListUserAuthEventsCommand;
const se_AdminRemoveUserFromGroupCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminRemoveUserFromGroup");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminRemoveUserFromGroupCommand = se_AdminRemoveUserFromGroupCommand;
const se_AdminResetUserPasswordCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminResetUserPassword");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminResetUserPasswordCommand = se_AdminResetUserPasswordCommand;
const se_AdminRespondToAuthChallengeCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminRespondToAuthChallenge");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminRespondToAuthChallengeCommand = se_AdminRespondToAuthChallengeCommand;
const se_AdminSetUserMFAPreferenceCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminSetUserMFAPreference");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminSetUserMFAPreferenceCommand = se_AdminSetUserMFAPreferenceCommand;
const se_AdminSetUserPasswordCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminSetUserPassword");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminSetUserPasswordCommand = se_AdminSetUserPasswordCommand;
const se_AdminSetUserSettingsCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminSetUserSettings");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminSetUserSettingsCommand = se_AdminSetUserSettingsCommand;
const se_AdminUpdateAuthEventFeedbackCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminUpdateAuthEventFeedback");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminUpdateAuthEventFeedbackCommand = se_AdminUpdateAuthEventFeedbackCommand;
const se_AdminUpdateDeviceStatusCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminUpdateDeviceStatus");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminUpdateDeviceStatusCommand = se_AdminUpdateDeviceStatusCommand;
const se_AdminUpdateUserAttributesCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminUpdateUserAttributes");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminUpdateUserAttributesCommand = se_AdminUpdateUserAttributesCommand;
const se_AdminUserGlobalSignOutCommand = async (input, context)=>{
    const headers = sharedHeaders("AdminUserGlobalSignOut");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AdminUserGlobalSignOutCommand = se_AdminUserGlobalSignOutCommand;
const se_AssociateSoftwareTokenCommand = async (input, context)=>{
    const headers = sharedHeaders("AssociateSoftwareToken");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AssociateSoftwareTokenCommand = se_AssociateSoftwareTokenCommand;
const se_ChangePasswordCommand = async (input, context)=>{
    const headers = sharedHeaders("ChangePassword");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ChangePasswordCommand = se_ChangePasswordCommand;
const se_ConfirmDeviceCommand = async (input, context)=>{
    const headers = sharedHeaders("ConfirmDevice");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ConfirmDeviceCommand = se_ConfirmDeviceCommand;
const se_ConfirmForgotPasswordCommand = async (input, context)=>{
    const headers = sharedHeaders("ConfirmForgotPassword");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ConfirmForgotPasswordCommand = se_ConfirmForgotPasswordCommand;
const se_ConfirmSignUpCommand = async (input, context)=>{
    const headers = sharedHeaders("ConfirmSignUp");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ConfirmSignUpCommand = se_ConfirmSignUpCommand;
const se_CreateGroupCommand = async (input, context)=>{
    const headers = sharedHeaders("CreateGroup");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateGroupCommand = se_CreateGroupCommand;
const se_CreateIdentityProviderCommand = async (input, context)=>{
    const headers = sharedHeaders("CreateIdentityProvider");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateIdentityProviderCommand = se_CreateIdentityProviderCommand;
const se_CreateResourceServerCommand = async (input, context)=>{
    const headers = sharedHeaders("CreateResourceServer");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateResourceServerCommand = se_CreateResourceServerCommand;
const se_CreateUserImportJobCommand = async (input, context)=>{
    const headers = sharedHeaders("CreateUserImportJob");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateUserImportJobCommand = se_CreateUserImportJobCommand;
const se_CreateUserPoolCommand = async (input, context)=>{
    const headers = sharedHeaders("CreateUserPool");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateUserPoolCommand = se_CreateUserPoolCommand;
const se_CreateUserPoolClientCommand = async (input, context)=>{
    const headers = sharedHeaders("CreateUserPoolClient");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateUserPoolClientCommand = se_CreateUserPoolClientCommand;
const se_CreateUserPoolDomainCommand = async (input, context)=>{
    const headers = sharedHeaders("CreateUserPoolDomain");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_CreateUserPoolDomainCommand = se_CreateUserPoolDomainCommand;
const se_DeleteGroupCommand = async (input, context)=>{
    const headers = sharedHeaders("DeleteGroup");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteGroupCommand = se_DeleteGroupCommand;
const se_DeleteIdentityProviderCommand = async (input, context)=>{
    const headers = sharedHeaders("DeleteIdentityProvider");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteIdentityProviderCommand = se_DeleteIdentityProviderCommand;
const se_DeleteResourceServerCommand = async (input, context)=>{
    const headers = sharedHeaders("DeleteResourceServer");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteResourceServerCommand = se_DeleteResourceServerCommand;
const se_DeleteUserCommand = async (input, context)=>{
    const headers = sharedHeaders("DeleteUser");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteUserCommand = se_DeleteUserCommand;
const se_DeleteUserAttributesCommand = async (input, context)=>{
    const headers = sharedHeaders("DeleteUserAttributes");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteUserAttributesCommand = se_DeleteUserAttributesCommand;
const se_DeleteUserPoolCommand = async (input, context)=>{
    const headers = sharedHeaders("DeleteUserPool");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteUserPoolCommand = se_DeleteUserPoolCommand;
const se_DeleteUserPoolClientCommand = async (input, context)=>{
    const headers = sharedHeaders("DeleteUserPoolClient");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteUserPoolClientCommand = se_DeleteUserPoolClientCommand;
const se_DeleteUserPoolDomainCommand = async (input, context)=>{
    const headers = sharedHeaders("DeleteUserPoolDomain");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DeleteUserPoolDomainCommand = se_DeleteUserPoolDomainCommand;
const se_DescribeIdentityProviderCommand = async (input, context)=>{
    const headers = sharedHeaders("DescribeIdentityProvider");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeIdentityProviderCommand = se_DescribeIdentityProviderCommand;
const se_DescribeResourceServerCommand = async (input, context)=>{
    const headers = sharedHeaders("DescribeResourceServer");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeResourceServerCommand = se_DescribeResourceServerCommand;
const se_DescribeRiskConfigurationCommand = async (input, context)=>{
    const headers = sharedHeaders("DescribeRiskConfiguration");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeRiskConfigurationCommand = se_DescribeRiskConfigurationCommand;
const se_DescribeUserImportJobCommand = async (input, context)=>{
    const headers = sharedHeaders("DescribeUserImportJob");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeUserImportJobCommand = se_DescribeUserImportJobCommand;
const se_DescribeUserPoolCommand = async (input, context)=>{
    const headers = sharedHeaders("DescribeUserPool");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeUserPoolCommand = se_DescribeUserPoolCommand;
const se_DescribeUserPoolClientCommand = async (input, context)=>{
    const headers = sharedHeaders("DescribeUserPoolClient");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeUserPoolClientCommand = se_DescribeUserPoolClientCommand;
const se_DescribeUserPoolDomainCommand = async (input, context)=>{
    const headers = sharedHeaders("DescribeUserPoolDomain");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DescribeUserPoolDomainCommand = se_DescribeUserPoolDomainCommand;
const se_ForgetDeviceCommand = async (input, context)=>{
    const headers = sharedHeaders("ForgetDevice");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ForgetDeviceCommand = se_ForgetDeviceCommand;
const se_ForgotPasswordCommand = async (input, context)=>{
    const headers = sharedHeaders("ForgotPassword");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ForgotPasswordCommand = se_ForgotPasswordCommand;
const se_GetCSVHeaderCommand = async (input, context)=>{
    const headers = sharedHeaders("GetCSVHeader");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetCSVHeaderCommand = se_GetCSVHeaderCommand;
const se_GetDeviceCommand = async (input, context)=>{
    const headers = sharedHeaders("GetDevice");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetDeviceCommand = se_GetDeviceCommand;
const se_GetGroupCommand = async (input, context)=>{
    const headers = sharedHeaders("GetGroup");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetGroupCommand = se_GetGroupCommand;
const se_GetIdentityProviderByIdentifierCommand = async (input, context)=>{
    const headers = sharedHeaders("GetIdentityProviderByIdentifier");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetIdentityProviderByIdentifierCommand = se_GetIdentityProviderByIdentifierCommand;
const se_GetLogDeliveryConfigurationCommand = async (input, context)=>{
    const headers = sharedHeaders("GetLogDeliveryConfiguration");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetLogDeliveryConfigurationCommand = se_GetLogDeliveryConfigurationCommand;
const se_GetSigningCertificateCommand = async (input, context)=>{
    const headers = sharedHeaders("GetSigningCertificate");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetSigningCertificateCommand = se_GetSigningCertificateCommand;
const se_GetUICustomizationCommand = async (input, context)=>{
    const headers = sharedHeaders("GetUICustomization");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetUICustomizationCommand = se_GetUICustomizationCommand;
const se_GetUserCommand = async (input, context)=>{
    const headers = sharedHeaders("GetUser");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetUserCommand = se_GetUserCommand;
const se_GetUserAttributeVerificationCodeCommand = async (input, context)=>{
    const headers = sharedHeaders("GetUserAttributeVerificationCode");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetUserAttributeVerificationCodeCommand = se_GetUserAttributeVerificationCodeCommand;
const se_GetUserPoolMfaConfigCommand = async (input, context)=>{
    const headers = sharedHeaders("GetUserPoolMfaConfig");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetUserPoolMfaConfigCommand = se_GetUserPoolMfaConfigCommand;
const se_GlobalSignOutCommand = async (input, context)=>{
    const headers = sharedHeaders("GlobalSignOut");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GlobalSignOutCommand = se_GlobalSignOutCommand;
const se_InitiateAuthCommand = async (input, context)=>{
    const headers = sharedHeaders("InitiateAuth");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_InitiateAuthCommand = se_InitiateAuthCommand;
const se_ListDevicesCommand = async (input, context)=>{
    const headers = sharedHeaders("ListDevices");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListDevicesCommand = se_ListDevicesCommand;
const se_ListGroupsCommand = async (input, context)=>{
    const headers = sharedHeaders("ListGroups");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListGroupsCommand = se_ListGroupsCommand;
const se_ListIdentityProvidersCommand = async (input, context)=>{
    const headers = sharedHeaders("ListIdentityProviders");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListIdentityProvidersCommand = se_ListIdentityProvidersCommand;
const se_ListResourceServersCommand = async (input, context)=>{
    const headers = sharedHeaders("ListResourceServers");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListResourceServersCommand = se_ListResourceServersCommand;
const se_ListTagsForResourceCommand = async (input, context)=>{
    const headers = sharedHeaders("ListTagsForResource");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListTagsForResourceCommand = se_ListTagsForResourceCommand;
const se_ListUserImportJobsCommand = async (input, context)=>{
    const headers = sharedHeaders("ListUserImportJobs");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListUserImportJobsCommand = se_ListUserImportJobsCommand;
const se_ListUserPoolClientsCommand = async (input, context)=>{
    const headers = sharedHeaders("ListUserPoolClients");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListUserPoolClientsCommand = se_ListUserPoolClientsCommand;
const se_ListUserPoolsCommand = async (input, context)=>{
    const headers = sharedHeaders("ListUserPools");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListUserPoolsCommand = se_ListUserPoolsCommand;
const se_ListUsersCommand = async (input, context)=>{
    const headers = sharedHeaders("ListUsers");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListUsersCommand = se_ListUsersCommand;
const se_ListUsersInGroupCommand = async (input, context)=>{
    const headers = sharedHeaders("ListUsersInGroup");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ListUsersInGroupCommand = se_ListUsersInGroupCommand;
const se_ResendConfirmationCodeCommand = async (input, context)=>{
    const headers = sharedHeaders("ResendConfirmationCode");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_ResendConfirmationCodeCommand = se_ResendConfirmationCodeCommand;
const se_RespondToAuthChallengeCommand = async (input, context)=>{
    const headers = sharedHeaders("RespondToAuthChallenge");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_RespondToAuthChallengeCommand = se_RespondToAuthChallengeCommand;
const se_RevokeTokenCommand = async (input, context)=>{
    const headers = sharedHeaders("RevokeToken");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_RevokeTokenCommand = se_RevokeTokenCommand;
const se_SetLogDeliveryConfigurationCommand = async (input, context)=>{
    const headers = sharedHeaders("SetLogDeliveryConfiguration");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_SetLogDeliveryConfigurationCommand = se_SetLogDeliveryConfigurationCommand;
const se_SetRiskConfigurationCommand = async (input, context)=>{
    const headers = sharedHeaders("SetRiskConfiguration");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_SetRiskConfigurationCommand = se_SetRiskConfigurationCommand;
const se_SetUICustomizationCommand = async (input, context)=>{
    const headers = sharedHeaders("SetUICustomization");
    let body;
    body = JSON.stringify(se_SetUICustomizationRequest(input, context));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_SetUICustomizationCommand = se_SetUICustomizationCommand;
const se_SetUserMFAPreferenceCommand = async (input, context)=>{
    const headers = sharedHeaders("SetUserMFAPreference");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_SetUserMFAPreferenceCommand = se_SetUserMFAPreferenceCommand;
const se_SetUserPoolMfaConfigCommand = async (input, context)=>{
    const headers = sharedHeaders("SetUserPoolMfaConfig");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_SetUserPoolMfaConfigCommand = se_SetUserPoolMfaConfigCommand;
const se_SetUserSettingsCommand = async (input, context)=>{
    const headers = sharedHeaders("SetUserSettings");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_SetUserSettingsCommand = se_SetUserSettingsCommand;
const se_SignUpCommand = async (input, context)=>{
    const headers = sharedHeaders("SignUp");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_SignUpCommand = se_SignUpCommand;
const se_StartUserImportJobCommand = async (input, context)=>{
    const headers = sharedHeaders("StartUserImportJob");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_StartUserImportJobCommand = se_StartUserImportJobCommand;
const se_StopUserImportJobCommand = async (input, context)=>{
    const headers = sharedHeaders("StopUserImportJob");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_StopUserImportJobCommand = se_StopUserImportJobCommand;
const se_TagResourceCommand = async (input, context)=>{
    const headers = sharedHeaders("TagResource");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_TagResourceCommand = se_TagResourceCommand;
const se_UntagResourceCommand = async (input, context)=>{
    const headers = sharedHeaders("UntagResource");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UntagResourceCommand = se_UntagResourceCommand;
const se_UpdateAuthEventFeedbackCommand = async (input, context)=>{
    const headers = sharedHeaders("UpdateAuthEventFeedback");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateAuthEventFeedbackCommand = se_UpdateAuthEventFeedbackCommand;
const se_UpdateDeviceStatusCommand = async (input, context)=>{
    const headers = sharedHeaders("UpdateDeviceStatus");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateDeviceStatusCommand = se_UpdateDeviceStatusCommand;
const se_UpdateGroupCommand = async (input, context)=>{
    const headers = sharedHeaders("UpdateGroup");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateGroupCommand = se_UpdateGroupCommand;
const se_UpdateIdentityProviderCommand = async (input, context)=>{
    const headers = sharedHeaders("UpdateIdentityProvider");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateIdentityProviderCommand = se_UpdateIdentityProviderCommand;
const se_UpdateResourceServerCommand = async (input, context)=>{
    const headers = sharedHeaders("UpdateResourceServer");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateResourceServerCommand = se_UpdateResourceServerCommand;
const se_UpdateUserAttributesCommand = async (input, context)=>{
    const headers = sharedHeaders("UpdateUserAttributes");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateUserAttributesCommand = se_UpdateUserAttributesCommand;
const se_UpdateUserPoolCommand = async (input, context)=>{
    const headers = sharedHeaders("UpdateUserPool");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateUserPoolCommand = se_UpdateUserPoolCommand;
const se_UpdateUserPoolClientCommand = async (input, context)=>{
    const headers = sharedHeaders("UpdateUserPoolClient");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateUserPoolClientCommand = se_UpdateUserPoolClientCommand;
const se_UpdateUserPoolDomainCommand = async (input, context)=>{
    const headers = sharedHeaders("UpdateUserPoolDomain");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_UpdateUserPoolDomainCommand = se_UpdateUserPoolDomainCommand;
const se_VerifySoftwareTokenCommand = async (input, context)=>{
    const headers = sharedHeaders("VerifySoftwareToken");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_VerifySoftwareTokenCommand = se_VerifySoftwareTokenCommand;
const se_VerifyUserAttributeCommand = async (input, context)=>{
    const headers = sharedHeaders("VerifyUserAttribute");
    let body;
    body = JSON.stringify((0, smithy_client_1._json)(input));
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_VerifyUserAttributeCommand = se_VerifyUserAttributeCommand;
const de_AddCustomAttributesCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AddCustomAttributesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AddCustomAttributesCommand = de_AddCustomAttributesCommand;
const de_AddCustomAttributesCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserImportInProgressException":
        case "com.amazonaws.cognitoidentityprovider#UserImportInProgressException":
            throw await de_UserImportInProgressExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminAddUserToGroupCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminAddUserToGroupCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return response;
};
exports.de_AdminAddUserToGroupCommand = de_AdminAddUserToGroupCommand;
const de_AdminAddUserToGroupCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminConfirmSignUpCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminConfirmSignUpCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminConfirmSignUpCommand = de_AdminConfirmSignUpCommand;
const de_AdminConfirmSignUpCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidLambdaResponseException":
        case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyFailedAttemptsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyFailedAttemptsException":
            throw await de_TooManyFailedAttemptsExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnexpectedLambdaException":
        case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
        case "UserLambdaValidationException":
        case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminCreateUserCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminCreateUserCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AdminCreateUserResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminCreateUserCommand = de_AdminCreateUserCommand;
const de_AdminCreateUserCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "CodeDeliveryFailureException":
        case "com.amazonaws.cognitoidentityprovider#CodeDeliveryFailureException":
            throw await de_CodeDeliveryFailureExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidLambdaResponseException":
        case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidPasswordException":
        case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
            throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleTrustRelationshipException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PreconditionNotMetException":
        case "com.amazonaws.cognitoidentityprovider#PreconditionNotMetException":
            throw await de_PreconditionNotMetExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnexpectedLambdaException":
        case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
        case "UnsupportedUserStateException":
        case "com.amazonaws.cognitoidentityprovider#UnsupportedUserStateException":
            throw await de_UnsupportedUserStateExceptionRes(parsedOutput, context);
        case "UserLambdaValidationException":
        case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        case "UsernameExistsException":
        case "com.amazonaws.cognitoidentityprovider#UsernameExistsException":
            throw await de_UsernameExistsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminDeleteUserCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminDeleteUserCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return response;
};
exports.de_AdminDeleteUserCommand = de_AdminDeleteUserCommand;
const de_AdminDeleteUserCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminDeleteUserAttributesCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminDeleteUserAttributesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminDeleteUserAttributesCommand = de_AdminDeleteUserAttributesCommand;
const de_AdminDeleteUserAttributesCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminDisableProviderForUserCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminDisableProviderForUserCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminDisableProviderForUserCommand = de_AdminDisableProviderForUserCommand;
const de_AdminDisableProviderForUserCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "AliasExistsException":
        case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
            throw await de_AliasExistsExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminDisableUserCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminDisableUserCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminDisableUserCommand = de_AdminDisableUserCommand;
const de_AdminDisableUserCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminEnableUserCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminEnableUserCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminEnableUserCommand = de_AdminEnableUserCommand;
const de_AdminEnableUserCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminForgetDeviceCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminForgetDeviceCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return response;
};
exports.de_AdminForgetDeviceCommand = de_AdminForgetDeviceCommand;
const de_AdminForgetDeviceCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidUserPoolConfigurationException":
        case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminGetDeviceCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminGetDeviceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AdminGetDeviceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminGetDeviceCommand = de_AdminGetDeviceCommand;
const de_AdminGetDeviceCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidUserPoolConfigurationException":
        case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminGetUserCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminGetUserCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AdminGetUserResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminGetUserCommand = de_AdminGetUserCommand;
const de_AdminGetUserCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminInitiateAuthCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminInitiateAuthCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminInitiateAuthCommand = de_AdminInitiateAuthCommand;
const de_AdminInitiateAuthCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidLambdaResponseException":
        case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleTrustRelationshipException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
        case "InvalidUserPoolConfigurationException":
        case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
        case "MFAMethodNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#MFAMethodNotFoundException":
            throw await de_MFAMethodNotFoundExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnexpectedLambdaException":
        case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
        case "UserLambdaValidationException":
        case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminLinkProviderForUserCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminLinkProviderForUserCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminLinkProviderForUserCommand = de_AdminLinkProviderForUserCommand;
const de_AdminLinkProviderForUserCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "AliasExistsException":
        case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
            throw await de_AliasExistsExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminListDevicesCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminListDevicesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AdminListDevicesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminListDevicesCommand = de_AdminListDevicesCommand;
const de_AdminListDevicesCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidUserPoolConfigurationException":
        case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminListGroupsForUserCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminListGroupsForUserCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AdminListGroupsForUserResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminListGroupsForUserCommand = de_AdminListGroupsForUserCommand;
const de_AdminListGroupsForUserCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminListUserAuthEventsCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminListUserAuthEventsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AdminListUserAuthEventsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminListUserAuthEventsCommand = de_AdminListUserAuthEventsCommand;
const de_AdminListUserAuthEventsCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        case "UserPoolAddOnNotEnabledException":
        case "com.amazonaws.cognitoidentityprovider#UserPoolAddOnNotEnabledException":
            throw await de_UserPoolAddOnNotEnabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminRemoveUserFromGroupCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminRemoveUserFromGroupCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return response;
};
exports.de_AdminRemoveUserFromGroupCommand = de_AdminRemoveUserFromGroupCommand;
const de_AdminRemoveUserFromGroupCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminResetUserPasswordCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminResetUserPasswordCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminResetUserPasswordCommand = de_AdminResetUserPasswordCommand;
const de_AdminResetUserPasswordCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidEmailRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidLambdaResponseException":
        case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleTrustRelationshipException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnexpectedLambdaException":
        case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
        case "UserLambdaValidationException":
        case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminRespondToAuthChallengeCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminRespondToAuthChallengeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminRespondToAuthChallengeCommand = de_AdminRespondToAuthChallengeCommand;
const de_AdminRespondToAuthChallengeCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "AliasExistsException":
        case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
            throw await de_AliasExistsExceptionRes(parsedOutput, context);
        case "CodeMismatchException":
        case "com.amazonaws.cognitoidentityprovider#CodeMismatchException":
            throw await de_CodeMismatchExceptionRes(parsedOutput, context);
        case "ExpiredCodeException":
        case "com.amazonaws.cognitoidentityprovider#ExpiredCodeException":
            throw await de_ExpiredCodeExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidLambdaResponseException":
        case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidPasswordException":
        case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
            throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleTrustRelationshipException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
        case "InvalidUserPoolConfigurationException":
        case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
        case "MFAMethodNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#MFAMethodNotFoundException":
            throw await de_MFAMethodNotFoundExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "SoftwareTokenMFANotFoundException":
        case "com.amazonaws.cognitoidentityprovider#SoftwareTokenMFANotFoundException":
            throw await de_SoftwareTokenMFANotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnexpectedLambdaException":
        case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
        case "UserLambdaValidationException":
        case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminSetUserMFAPreferenceCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminSetUserMFAPreferenceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminSetUserMFAPreferenceCommand = de_AdminSetUserMFAPreferenceCommand;
const de_AdminSetUserMFAPreferenceCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminSetUserPasswordCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminSetUserPasswordCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminSetUserPasswordCommand = de_AdminSetUserPasswordCommand;
const de_AdminSetUserPasswordCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidPasswordException":
        case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
            throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminSetUserSettingsCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminSetUserSettingsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminSetUserSettingsCommand = de_AdminSetUserSettingsCommand;
const de_AdminSetUserSettingsCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminUpdateAuthEventFeedbackCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminUpdateAuthEventFeedbackCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminUpdateAuthEventFeedbackCommand = de_AdminUpdateAuthEventFeedbackCommand;
const de_AdminUpdateAuthEventFeedbackCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        case "UserPoolAddOnNotEnabledException":
        case "com.amazonaws.cognitoidentityprovider#UserPoolAddOnNotEnabledException":
            throw await de_UserPoolAddOnNotEnabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminUpdateDeviceStatusCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminUpdateDeviceStatusCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminUpdateDeviceStatusCommand = de_AdminUpdateDeviceStatusCommand;
const de_AdminUpdateDeviceStatusCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidUserPoolConfigurationException":
        case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminUpdateUserAttributesCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminUpdateUserAttributesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminUpdateUserAttributesCommand = de_AdminUpdateUserAttributesCommand;
const de_AdminUpdateUserAttributesCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "AliasExistsException":
        case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
            throw await de_AliasExistsExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidEmailRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidLambdaResponseException":
        case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleTrustRelationshipException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnexpectedLambdaException":
        case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
        case "UserLambdaValidationException":
        case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AdminUserGlobalSignOutCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AdminUserGlobalSignOutCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AdminUserGlobalSignOutCommand = de_AdminUserGlobalSignOutCommand;
const de_AdminUserGlobalSignOutCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AssociateSoftwareTokenCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AssociateSoftwareTokenCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AssociateSoftwareTokenCommand = de_AssociateSoftwareTokenCommand;
const de_AssociateSoftwareTokenCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ConcurrentModificationException":
        case "com.amazonaws.cognitoidentityprovider#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "SoftwareTokenMFANotFoundException":
        case "com.amazonaws.cognitoidentityprovider#SoftwareTokenMFANotFoundException":
            throw await de_SoftwareTokenMFANotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ChangePasswordCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_ChangePasswordCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_ChangePasswordCommand = de_ChangePasswordCommand;
const de_ChangePasswordCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidPasswordException":
        case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
            throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ConfirmDeviceCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_ConfirmDeviceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_ConfirmDeviceCommand = de_ConfirmDeviceCommand;
const de_ConfirmDeviceCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidLambdaResponseException":
        case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidPasswordException":
        case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
            throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
        case "InvalidUserPoolConfigurationException":
        case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        case "UsernameExistsException":
        case "com.amazonaws.cognitoidentityprovider#UsernameExistsException":
            throw await de_UsernameExistsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ConfirmForgotPasswordCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_ConfirmForgotPasswordCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_ConfirmForgotPasswordCommand = de_ConfirmForgotPasswordCommand;
const de_ConfirmForgotPasswordCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "CodeMismatchException":
        case "com.amazonaws.cognitoidentityprovider#CodeMismatchException":
            throw await de_CodeMismatchExceptionRes(parsedOutput, context);
        case "ExpiredCodeException":
        case "com.amazonaws.cognitoidentityprovider#ExpiredCodeException":
            throw await de_ExpiredCodeExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidLambdaResponseException":
        case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidPasswordException":
        case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
            throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyFailedAttemptsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyFailedAttemptsException":
            throw await de_TooManyFailedAttemptsExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnexpectedLambdaException":
        case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
        case "UserLambdaValidationException":
        case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ConfirmSignUpCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_ConfirmSignUpCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_ConfirmSignUpCommand = de_ConfirmSignUpCommand;
const de_ConfirmSignUpCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "AliasExistsException":
        case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
            throw await de_AliasExistsExceptionRes(parsedOutput, context);
        case "CodeMismatchException":
        case "com.amazonaws.cognitoidentityprovider#CodeMismatchException":
            throw await de_CodeMismatchExceptionRes(parsedOutput, context);
        case "ExpiredCodeException":
        case "com.amazonaws.cognitoidentityprovider#ExpiredCodeException":
            throw await de_ExpiredCodeExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidLambdaResponseException":
        case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyFailedAttemptsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyFailedAttemptsException":
            throw await de_TooManyFailedAttemptsExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnexpectedLambdaException":
        case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
        case "UserLambdaValidationException":
        case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_CreateGroupCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_CreateGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateGroupResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_CreateGroupCommand = de_CreateGroupCommand;
const de_CreateGroupCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "GroupExistsException":
        case "com.amazonaws.cognitoidentityprovider#GroupExistsException":
            throw await de_GroupExistsExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_CreateIdentityProviderCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_CreateIdentityProviderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateIdentityProviderResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_CreateIdentityProviderCommand = de_CreateIdentityProviderCommand;
const de_CreateIdentityProviderCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "DuplicateProviderException":
        case "com.amazonaws.cognitoidentityprovider#DuplicateProviderException":
            throw await de_DuplicateProviderExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_CreateResourceServerCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_CreateResourceServerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_CreateResourceServerCommand = de_CreateResourceServerCommand;
const de_CreateResourceServerCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_CreateUserImportJobCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_CreateUserImportJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateUserImportJobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_CreateUserImportJobCommand = de_CreateUserImportJobCommand;
const de_CreateUserImportJobCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PreconditionNotMetException":
        case "com.amazonaws.cognitoidentityprovider#PreconditionNotMetException":
            throw await de_PreconditionNotMetExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_CreateUserPoolCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_CreateUserPoolCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateUserPoolResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_CreateUserPoolCommand = de_CreateUserPoolCommand;
const de_CreateUserPoolCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidEmailRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleTrustRelationshipException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserPoolTaggingException":
        case "com.amazonaws.cognitoidentityprovider#UserPoolTaggingException":
            throw await de_UserPoolTaggingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_CreateUserPoolClientCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_CreateUserPoolClientCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_CreateUserPoolClientResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_CreateUserPoolClientCommand = de_CreateUserPoolClientCommand;
const de_CreateUserPoolClientCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidOAuthFlowException":
        case "com.amazonaws.cognitoidentityprovider#InvalidOAuthFlowException":
            throw await de_InvalidOAuthFlowExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ScopeDoesNotExistException":
        case "com.amazonaws.cognitoidentityprovider#ScopeDoesNotExistException":
            throw await de_ScopeDoesNotExistExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_CreateUserPoolDomainCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_CreateUserPoolDomainCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_CreateUserPoolDomainCommand = de_CreateUserPoolDomainCommand;
const de_CreateUserPoolDomainCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_DeleteGroupCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_DeleteGroupCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return response;
};
exports.de_DeleteGroupCommand = de_DeleteGroupCommand;
const de_DeleteGroupCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_DeleteIdentityProviderCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_DeleteIdentityProviderCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return response;
};
exports.de_DeleteIdentityProviderCommand = de_DeleteIdentityProviderCommand;
const de_DeleteIdentityProviderCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ConcurrentModificationException":
        case "com.amazonaws.cognitoidentityprovider#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnsupportedIdentityProviderException":
        case "com.amazonaws.cognitoidentityprovider#UnsupportedIdentityProviderException":
            throw await de_UnsupportedIdentityProviderExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_DeleteResourceServerCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_DeleteResourceServerCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return response;
};
exports.de_DeleteResourceServerCommand = de_DeleteResourceServerCommand;
const de_DeleteResourceServerCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_DeleteUserCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_DeleteUserCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return response;
};
exports.de_DeleteUserCommand = de_DeleteUserCommand;
const de_DeleteUserCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_DeleteUserAttributesCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_DeleteUserAttributesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_DeleteUserAttributesCommand = de_DeleteUserAttributesCommand;
const de_DeleteUserAttributesCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_DeleteUserPoolCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_DeleteUserPoolCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return response;
};
exports.de_DeleteUserPoolCommand = de_DeleteUserPoolCommand;
const de_DeleteUserPoolCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserImportInProgressException":
        case "com.amazonaws.cognitoidentityprovider#UserImportInProgressException":
            throw await de_UserImportInProgressExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_DeleteUserPoolClientCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_DeleteUserPoolClientCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return response;
};
exports.de_DeleteUserPoolClientCommand = de_DeleteUserPoolClientCommand;
const de_DeleteUserPoolClientCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ConcurrentModificationException":
        case "com.amazonaws.cognitoidentityprovider#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_DeleteUserPoolDomainCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_DeleteUserPoolDomainCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_DeleteUserPoolDomainCommand = de_DeleteUserPoolDomainCommand;
const de_DeleteUserPoolDomainCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_DescribeIdentityProviderCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_DescribeIdentityProviderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeIdentityProviderResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_DescribeIdentityProviderCommand = de_DescribeIdentityProviderCommand;
const de_DescribeIdentityProviderCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_DescribeResourceServerCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_DescribeResourceServerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_DescribeResourceServerCommand = de_DescribeResourceServerCommand;
const de_DescribeResourceServerCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_DescribeRiskConfigurationCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_DescribeRiskConfigurationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeRiskConfigurationResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_DescribeRiskConfigurationCommand = de_DescribeRiskConfigurationCommand;
const de_DescribeRiskConfigurationCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserPoolAddOnNotEnabledException":
        case "com.amazonaws.cognitoidentityprovider#UserPoolAddOnNotEnabledException":
            throw await de_UserPoolAddOnNotEnabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_DescribeUserImportJobCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_DescribeUserImportJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeUserImportJobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_DescribeUserImportJobCommand = de_DescribeUserImportJobCommand;
const de_DescribeUserImportJobCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_DescribeUserPoolCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_DescribeUserPoolCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeUserPoolResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_DescribeUserPoolCommand = de_DescribeUserPoolCommand;
const de_DescribeUserPoolCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserPoolTaggingException":
        case "com.amazonaws.cognitoidentityprovider#UserPoolTaggingException":
            throw await de_UserPoolTaggingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_DescribeUserPoolClientCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_DescribeUserPoolClientCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DescribeUserPoolClientResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_DescribeUserPoolClientCommand = de_DescribeUserPoolClientCommand;
const de_DescribeUserPoolClientCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_DescribeUserPoolDomainCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_DescribeUserPoolDomainCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_DescribeUserPoolDomainCommand = de_DescribeUserPoolDomainCommand;
const de_DescribeUserPoolDomainCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ForgetDeviceCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_ForgetDeviceCommandError(output, context);
    }
    await (0, smithy_client_1.collectBody)(output.body, context);
    const response = {
        $metadata: deserializeMetadata(output)
    };
    return response;
};
exports.de_ForgetDeviceCommand = de_ForgetDeviceCommand;
const de_ForgetDeviceCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidUserPoolConfigurationException":
        case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ForgotPasswordCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_ForgotPasswordCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_ForgotPasswordCommand = de_ForgotPasswordCommand;
const de_ForgotPasswordCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "CodeDeliveryFailureException":
        case "com.amazonaws.cognitoidentityprovider#CodeDeliveryFailureException":
            throw await de_CodeDeliveryFailureExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidEmailRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidLambdaResponseException":
        case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleTrustRelationshipException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnexpectedLambdaException":
        case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
        case "UserLambdaValidationException":
        case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_GetCSVHeaderCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_GetCSVHeaderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_GetCSVHeaderCommand = de_GetCSVHeaderCommand;
const de_GetCSVHeaderCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_GetDeviceCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_GetDeviceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetDeviceResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_GetDeviceCommand = de_GetDeviceCommand;
const de_GetDeviceCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidUserPoolConfigurationException":
        case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_GetGroupCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_GetGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetGroupResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_GetGroupCommand = de_GetGroupCommand;
const de_GetGroupCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_GetIdentityProviderByIdentifierCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_GetIdentityProviderByIdentifierCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetIdentityProviderByIdentifierResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_GetIdentityProviderByIdentifierCommand = de_GetIdentityProviderByIdentifierCommand;
const de_GetIdentityProviderByIdentifierCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_GetLogDeliveryConfigurationCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_GetLogDeliveryConfigurationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_GetLogDeliveryConfigurationCommand = de_GetLogDeliveryConfigurationCommand;
const de_GetLogDeliveryConfigurationCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_GetSigningCertificateCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_GetSigningCertificateCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_GetSigningCertificateCommand = de_GetSigningCertificateCommand;
const de_GetSigningCertificateCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_GetUICustomizationCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_GetUICustomizationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetUICustomizationResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_GetUICustomizationCommand = de_GetUICustomizationCommand;
const de_GetUICustomizationCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_GetUserCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_GetUserCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_GetUserCommand = de_GetUserCommand;
const de_GetUserCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_GetUserAttributeVerificationCodeCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_GetUserAttributeVerificationCodeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_GetUserAttributeVerificationCodeCommand = de_GetUserAttributeVerificationCodeCommand;
const de_GetUserAttributeVerificationCodeCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "CodeDeliveryFailureException":
        case "com.amazonaws.cognitoidentityprovider#CodeDeliveryFailureException":
            throw await de_CodeDeliveryFailureExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidEmailRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidLambdaResponseException":
        case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleTrustRelationshipException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnexpectedLambdaException":
        case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
        case "UserLambdaValidationException":
        case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_GetUserPoolMfaConfigCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_GetUserPoolMfaConfigCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_GetUserPoolMfaConfigCommand = de_GetUserPoolMfaConfigCommand;
const de_GetUserPoolMfaConfigCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_GlobalSignOutCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_GlobalSignOutCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_GlobalSignOutCommand = de_GlobalSignOutCommand;
const de_GlobalSignOutCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_InitiateAuthCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_InitiateAuthCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_InitiateAuthCommand = de_InitiateAuthCommand;
const de_InitiateAuthCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidLambdaResponseException":
        case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleTrustRelationshipException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
        case "InvalidUserPoolConfigurationException":
        case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnexpectedLambdaException":
        case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
        case "UserLambdaValidationException":
        case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ListDevicesCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_ListDevicesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListDevicesResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_ListDevicesCommand = de_ListDevicesCommand;
const de_ListDevicesCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidUserPoolConfigurationException":
        case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ListGroupsCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_ListGroupsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListGroupsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_ListGroupsCommand = de_ListGroupsCommand;
const de_ListGroupsCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ListIdentityProvidersCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_ListIdentityProvidersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListIdentityProvidersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_ListIdentityProvidersCommand = de_ListIdentityProvidersCommand;
const de_ListIdentityProvidersCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ListResourceServersCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_ListResourceServersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_ListResourceServersCommand = de_ListResourceServersCommand;
const de_ListResourceServersCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ListTagsForResourceCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_ListTagsForResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_ListTagsForResourceCommand = de_ListTagsForResourceCommand;
const de_ListTagsForResourceCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ListUserImportJobsCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_ListUserImportJobsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListUserImportJobsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_ListUserImportJobsCommand = de_ListUserImportJobsCommand;
const de_ListUserImportJobsCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ListUserPoolClientsCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_ListUserPoolClientsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_ListUserPoolClientsCommand = de_ListUserPoolClientsCommand;
const de_ListUserPoolClientsCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ListUserPoolsCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_ListUserPoolsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListUserPoolsResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_ListUserPoolsCommand = de_ListUserPoolsCommand;
const de_ListUserPoolsCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ListUsersCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_ListUsersCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListUsersResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_ListUsersCommand = de_ListUsersCommand;
const de_ListUsersCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ListUsersInGroupCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_ListUsersInGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_ListUsersInGroupResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_ListUsersInGroupCommand = de_ListUsersInGroupCommand;
const de_ListUsersInGroupCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ResendConfirmationCodeCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_ResendConfirmationCodeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_ResendConfirmationCodeCommand = de_ResendConfirmationCodeCommand;
const de_ResendConfirmationCodeCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "CodeDeliveryFailureException":
        case "com.amazonaws.cognitoidentityprovider#CodeDeliveryFailureException":
            throw await de_CodeDeliveryFailureExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidEmailRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidLambdaResponseException":
        case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleTrustRelationshipException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnexpectedLambdaException":
        case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
        case "UserLambdaValidationException":
        case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_RespondToAuthChallengeCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_RespondToAuthChallengeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_RespondToAuthChallengeCommand = de_RespondToAuthChallengeCommand;
const de_RespondToAuthChallengeCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "AliasExistsException":
        case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
            throw await de_AliasExistsExceptionRes(parsedOutput, context);
        case "CodeMismatchException":
        case "com.amazonaws.cognitoidentityprovider#CodeMismatchException":
            throw await de_CodeMismatchExceptionRes(parsedOutput, context);
        case "ExpiredCodeException":
        case "com.amazonaws.cognitoidentityprovider#ExpiredCodeException":
            throw await de_ExpiredCodeExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidLambdaResponseException":
        case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidPasswordException":
        case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
            throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleTrustRelationshipException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
        case "InvalidUserPoolConfigurationException":
        case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
        case "MFAMethodNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#MFAMethodNotFoundException":
            throw await de_MFAMethodNotFoundExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "SoftwareTokenMFANotFoundException":
        case "com.amazonaws.cognitoidentityprovider#SoftwareTokenMFANotFoundException":
            throw await de_SoftwareTokenMFANotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnexpectedLambdaException":
        case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
        case "UserLambdaValidationException":
        case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_RevokeTokenCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_RevokeTokenCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_RevokeTokenCommand = de_RevokeTokenCommand;
const de_RevokeTokenCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.cognitoidentityprovider#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        case "UnsupportedOperationException":
        case "com.amazonaws.cognitoidentityprovider#UnsupportedOperationException":
            throw await de_UnsupportedOperationExceptionRes(parsedOutput, context);
        case "UnsupportedTokenTypeException":
        case "com.amazonaws.cognitoidentityprovider#UnsupportedTokenTypeException":
            throw await de_UnsupportedTokenTypeExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_SetLogDeliveryConfigurationCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_SetLogDeliveryConfigurationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_SetLogDeliveryConfigurationCommand = de_SetLogDeliveryConfigurationCommand;
const de_SetLogDeliveryConfigurationCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_SetRiskConfigurationCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_SetRiskConfigurationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SetRiskConfigurationResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_SetRiskConfigurationCommand = de_SetRiskConfigurationCommand;
const de_SetRiskConfigurationCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "CodeDeliveryFailureException":
        case "com.amazonaws.cognitoidentityprovider#CodeDeliveryFailureException":
            throw await de_CodeDeliveryFailureExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidEmailRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserPoolAddOnNotEnabledException":
        case "com.amazonaws.cognitoidentityprovider#UserPoolAddOnNotEnabledException":
            throw await de_UserPoolAddOnNotEnabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_SetUICustomizationCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_SetUICustomizationCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_SetUICustomizationResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_SetUICustomizationCommand = de_SetUICustomizationCommand;
const de_SetUICustomizationCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_SetUserMFAPreferenceCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_SetUserMFAPreferenceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_SetUserMFAPreferenceCommand = de_SetUserMFAPreferenceCommand;
const de_SetUserMFAPreferenceCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_SetUserPoolMfaConfigCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_SetUserPoolMfaConfigCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_SetUserPoolMfaConfigCommand = de_SetUserPoolMfaConfigCommand;
const de_SetUserPoolMfaConfigCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleTrustRelationshipException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_SetUserSettingsCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_SetUserSettingsCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_SetUserSettingsCommand = de_SetUserSettingsCommand;
const de_SetUserSettingsCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_SignUpCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_SignUpCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_SignUpCommand = de_SignUpCommand;
const de_SignUpCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "CodeDeliveryFailureException":
        case "com.amazonaws.cognitoidentityprovider#CodeDeliveryFailureException":
            throw await de_CodeDeliveryFailureExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidEmailRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidLambdaResponseException":
        case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidPasswordException":
        case "com.amazonaws.cognitoidentityprovider#InvalidPasswordException":
            throw await de_InvalidPasswordExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleTrustRelationshipException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnexpectedLambdaException":
        case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
        case "UserLambdaValidationException":
        case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
        case "UsernameExistsException":
        case "com.amazonaws.cognitoidentityprovider#UsernameExistsException":
            throw await de_UsernameExistsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_StartUserImportJobCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_StartUserImportJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StartUserImportJobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_StartUserImportJobCommand = de_StartUserImportJobCommand;
const de_StartUserImportJobCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PreconditionNotMetException":
        case "com.amazonaws.cognitoidentityprovider#PreconditionNotMetException":
            throw await de_PreconditionNotMetExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_StopUserImportJobCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_StopUserImportJobCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_StopUserImportJobResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_StopUserImportJobCommand = de_StopUserImportJobCommand;
const de_StopUserImportJobCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PreconditionNotMetException":
        case "com.amazonaws.cognitoidentityprovider#PreconditionNotMetException":
            throw await de_PreconditionNotMetExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_TagResourceCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_TagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_TagResourceCommand = de_TagResourceCommand;
const de_TagResourceCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_UntagResourceCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_UntagResourceCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_UntagResourceCommand = de_UntagResourceCommand;
const de_UntagResourceCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_UpdateAuthEventFeedbackCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_UpdateAuthEventFeedbackCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_UpdateAuthEventFeedbackCommand = de_UpdateAuthEventFeedbackCommand;
const de_UpdateAuthEventFeedbackCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        case "UserPoolAddOnNotEnabledException":
        case "com.amazonaws.cognitoidentityprovider#UserPoolAddOnNotEnabledException":
            throw await de_UserPoolAddOnNotEnabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_UpdateDeviceStatusCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_UpdateDeviceStatusCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_UpdateDeviceStatusCommand = de_UpdateDeviceStatusCommand;
const de_UpdateDeviceStatusCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidUserPoolConfigurationException":
        case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_UpdateGroupCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_UpdateGroupCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateGroupResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_UpdateGroupCommand = de_UpdateGroupCommand;
const de_UpdateGroupCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_UpdateIdentityProviderCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_UpdateIdentityProviderCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateIdentityProviderResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_UpdateIdentityProviderCommand = de_UpdateIdentityProviderCommand;
const de_UpdateIdentityProviderCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ConcurrentModificationException":
        case "com.amazonaws.cognitoidentityprovider#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnsupportedIdentityProviderException":
        case "com.amazonaws.cognitoidentityprovider#UnsupportedIdentityProviderException":
            throw await de_UnsupportedIdentityProviderExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_UpdateResourceServerCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_UpdateResourceServerCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_UpdateResourceServerCommand = de_UpdateResourceServerCommand;
const de_UpdateResourceServerCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_UpdateUserAttributesCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_UpdateUserAttributesCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_UpdateUserAttributesCommand = de_UpdateUserAttributesCommand;
const de_UpdateUserAttributesCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "AliasExistsException":
        case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
            throw await de_AliasExistsExceptionRes(parsedOutput, context);
        case "CodeDeliveryFailureException":
        case "com.amazonaws.cognitoidentityprovider#CodeDeliveryFailureException":
            throw await de_CodeDeliveryFailureExceptionRes(parsedOutput, context);
        case "CodeMismatchException":
        case "com.amazonaws.cognitoidentityprovider#CodeMismatchException":
            throw await de_CodeMismatchExceptionRes(parsedOutput, context);
        case "ExpiredCodeException":
        case "com.amazonaws.cognitoidentityprovider#ExpiredCodeException":
            throw await de_ExpiredCodeExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidEmailRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidLambdaResponseException":
        case "com.amazonaws.cognitoidentityprovider#InvalidLambdaResponseException":
            throw await de_InvalidLambdaResponseExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleTrustRelationshipException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnexpectedLambdaException":
        case "com.amazonaws.cognitoidentityprovider#UnexpectedLambdaException":
            throw await de_UnexpectedLambdaExceptionRes(parsedOutput, context);
        case "UserLambdaValidationException":
        case "com.amazonaws.cognitoidentityprovider#UserLambdaValidationException":
            throw await de_UserLambdaValidationExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_UpdateUserPoolCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_UpdateUserPoolCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_UpdateUserPoolCommand = de_UpdateUserPoolCommand;
const de_UpdateUserPoolCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ConcurrentModificationException":
        case "com.amazonaws.cognitoidentityprovider#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidEmailRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidEmailRoleAccessPolicyException":
            throw await de_InvalidEmailRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleAccessPolicyException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleAccessPolicyException":
            throw await de_InvalidSmsRoleAccessPolicyExceptionRes(parsedOutput, context);
        case "InvalidSmsRoleTrustRelationshipException":
        case "com.amazonaws.cognitoidentityprovider#InvalidSmsRoleTrustRelationshipException":
            throw await de_InvalidSmsRoleTrustRelationshipExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserImportInProgressException":
        case "com.amazonaws.cognitoidentityprovider#UserImportInProgressException":
            throw await de_UserImportInProgressExceptionRes(parsedOutput, context);
        case "UserPoolTaggingException":
        case "com.amazonaws.cognitoidentityprovider#UserPoolTaggingException":
            throw await de_UserPoolTaggingExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_UpdateUserPoolClientCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_UpdateUserPoolClientCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_UpdateUserPoolClientResponse(data, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_UpdateUserPoolClientCommand = de_UpdateUserPoolClientCommand;
const de_UpdateUserPoolClientCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ConcurrentModificationException":
        case "com.amazonaws.cognitoidentityprovider#ConcurrentModificationException":
            throw await de_ConcurrentModificationExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidOAuthFlowException":
        case "com.amazonaws.cognitoidentityprovider#InvalidOAuthFlowException":
            throw await de_InvalidOAuthFlowExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "ScopeDoesNotExistException":
        case "com.amazonaws.cognitoidentityprovider#ScopeDoesNotExistException":
            throw await de_ScopeDoesNotExistExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_UpdateUserPoolDomainCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_UpdateUserPoolDomainCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_UpdateUserPoolDomainCommand = de_UpdateUserPoolDomainCommand;
const de_UpdateUserPoolDomainCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_VerifySoftwareTokenCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_VerifySoftwareTokenCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_VerifySoftwareTokenCommand = de_VerifySoftwareTokenCommand;
const de_VerifySoftwareTokenCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "CodeMismatchException":
        case "com.amazonaws.cognitoidentityprovider#CodeMismatchException":
            throw await de_CodeMismatchExceptionRes(parsedOutput, context);
        case "EnableSoftwareTokenMFAException":
        case "com.amazonaws.cognitoidentityprovider#EnableSoftwareTokenMFAException":
            throw await de_EnableSoftwareTokenMFAExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "InvalidUserPoolConfigurationException":
        case "com.amazonaws.cognitoidentityprovider#InvalidUserPoolConfigurationException":
            throw await de_InvalidUserPoolConfigurationExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "SoftwareTokenMFANotFoundException":
        case "com.amazonaws.cognitoidentityprovider#SoftwareTokenMFANotFoundException":
            throw await de_SoftwareTokenMFANotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_VerifyUserAttributeCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_VerifyUserAttributeCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = (0, smithy_client_1._json)(data);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_VerifyUserAttributeCommand = de_VerifyUserAttributeCommand;
const de_VerifyUserAttributeCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "AliasExistsException":
        case "com.amazonaws.cognitoidentityprovider#AliasExistsException":
            throw await de_AliasExistsExceptionRes(parsedOutput, context);
        case "CodeMismatchException":
        case "com.amazonaws.cognitoidentityprovider#CodeMismatchException":
            throw await de_CodeMismatchExceptionRes(parsedOutput, context);
        case "ExpiredCodeException":
        case "com.amazonaws.cognitoidentityprovider#ExpiredCodeException":
            throw await de_ExpiredCodeExceptionRes(parsedOutput, context);
        case "ForbiddenException":
        case "com.amazonaws.cognitoidentityprovider#ForbiddenException":
            throw await de_ForbiddenExceptionRes(parsedOutput, context);
        case "InternalErrorException":
        case "com.amazonaws.cognitoidentityprovider#InternalErrorException":
            throw await de_InternalErrorExceptionRes(parsedOutput, context);
        case "InvalidParameterException":
        case "com.amazonaws.cognitoidentityprovider#InvalidParameterException":
            throw await de_InvalidParameterExceptionRes(parsedOutput, context);
        case "LimitExceededException":
        case "com.amazonaws.cognitoidentityprovider#LimitExceededException":
            throw await de_LimitExceededExceptionRes(parsedOutput, context);
        case "NotAuthorizedException":
        case "com.amazonaws.cognitoidentityprovider#NotAuthorizedException":
            throw await de_NotAuthorizedExceptionRes(parsedOutput, context);
        case "PasswordResetRequiredException":
        case "com.amazonaws.cognitoidentityprovider#PasswordResetRequiredException":
            throw await de_PasswordResetRequiredExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.cognitoidentityprovider#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UserNotConfirmedException":
        case "com.amazonaws.cognitoidentityprovider#UserNotConfirmedException":
            throw await de_UserNotConfirmedExceptionRes(parsedOutput, context);
        case "UserNotFoundException":
        case "com.amazonaws.cognitoidentityprovider#UserNotFoundException":
            throw await de_UserNotFoundExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_AliasExistsExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.AliasExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CodeDeliveryFailureExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CodeDeliveryFailureException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_CodeMismatchExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.CodeMismatchException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ConcurrentModificationExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ConcurrentModificationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_DuplicateProviderExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.DuplicateProviderException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_EnableSoftwareTokenMFAExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_1_1.EnableSoftwareTokenMFAException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ExpiredCodeExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ExpiredCodeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ForbiddenExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ForbiddenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_GroupExistsExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.GroupExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InternalErrorExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InternalErrorException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidEmailRoleAccessPolicyExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidEmailRoleAccessPolicyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidLambdaResponseExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidLambdaResponseException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidOAuthFlowExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidOAuthFlowException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidParameterExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidParameterException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidPasswordExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidPasswordException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidSmsRoleAccessPolicyExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidSmsRoleAccessPolicyException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidSmsRoleTrustRelationshipExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidSmsRoleTrustRelationshipException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidUserPoolConfigurationExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.InvalidUserPoolConfigurationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_LimitExceededExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.LimitExceededException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MFAMethodNotFoundExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.MFAMethodNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_NotAuthorizedExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.NotAuthorizedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PasswordResetRequiredExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.PasswordResetRequiredException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PreconditionNotMetExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.PreconditionNotMetException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_ScopeDoesNotExistExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.ScopeDoesNotExistException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_SoftwareTokenMFANotFoundExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.SoftwareTokenMFANotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TooManyFailedAttemptsExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.TooManyFailedAttemptsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UnauthorizedExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.UnauthorizedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UnexpectedLambdaExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.UnexpectedLambdaException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UnsupportedIdentityProviderExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.UnsupportedIdentityProviderException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UnsupportedOperationExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.UnsupportedOperationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UnsupportedTokenTypeExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.UnsupportedTokenTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UnsupportedUserStateExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.UnsupportedUserStateException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UserImportInProgressExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.UserImportInProgressException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UserLambdaValidationExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.UserLambdaValidationException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UsernameExistsExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.UsernameExistsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UserNotConfirmedExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.UserNotConfirmedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UserNotFoundExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.UserNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UserPoolAddOnNotEnabledExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.UserPoolAddOnNotEnabledException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_UserPoolTaggingExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = (0, smithy_client_1._json)(body);
    const exception = new models_0_1.UserPoolTaggingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const se_SetUICustomizationRequest = (input, context)=>{
    return (0, smithy_client_1.take)(input, {
        CSS: [],
        ClientId: [],
        ImageFile: context.base64Encoder,
        UserPoolId: []
    });
};
const de_AdminCreateUserResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        User: (_)=>de_UserType(_, context)
    });
};
const de_AdminGetDeviceResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        Device: (_)=>de_DeviceType(_, context)
    });
};
const de_AdminGetUserResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        Enabled: smithy_client_1.expectBoolean,
        MFAOptions: smithy_client_1._json,
        PreferredMfaSetting: smithy_client_1.expectString,
        UserAttributes: smithy_client_1._json,
        UserCreateDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        UserLastModifiedDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        UserMFASettingList: smithy_client_1._json,
        UserStatus: smithy_client_1.expectString,
        Username: smithy_client_1.expectString
    });
};
const de_AdminListDevicesResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        Devices: (_)=>de_DeviceListType(_, context),
        PaginationToken: smithy_client_1.expectString
    });
};
const de_AdminListGroupsForUserResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        Groups: (_)=>de_GroupListType(_, context),
        NextToken: smithy_client_1.expectString
    });
};
const de_AdminListUserAuthEventsResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        AuthEvents: (_)=>de_AuthEventsType(_, context),
        NextToken: smithy_client_1.expectString
    });
};
const de_AuthEventsType = (output, context)=>{
    const retVal = (output || []).filter((e)=>e != null).map((entry)=>{
        return de_AuthEventType(entry, context);
    });
    return retVal;
};
const de_AuthEventType = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        ChallengeResponses: smithy_client_1._json,
        CreationDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        EventContextData: smithy_client_1._json,
        EventFeedback: (_)=>de_EventFeedbackType(_, context),
        EventId: smithy_client_1.expectString,
        EventResponse: smithy_client_1.expectString,
        EventRisk: smithy_client_1._json,
        EventType: smithy_client_1.expectString
    });
};
const de_CreateGroupResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        Group: (_)=>de_GroupType(_, context)
    });
};
const de_CreateIdentityProviderResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        IdentityProvider: (_)=>de_IdentityProviderType(_, context)
    });
};
const de_CreateUserImportJobResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        UserImportJob: (_)=>de_UserImportJobType(_, context)
    });
};
const de_CreateUserPoolClientResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        UserPoolClient: (_)=>de_UserPoolClientType(_, context)
    });
};
const de_CreateUserPoolResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        UserPool: (_)=>de_UserPoolType(_, context)
    });
};
const de_DescribeIdentityProviderResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        IdentityProvider: (_)=>de_IdentityProviderType(_, context)
    });
};
const de_DescribeRiskConfigurationResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        RiskConfiguration: (_)=>de_RiskConfigurationType(_, context)
    });
};
const de_DescribeUserImportJobResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        UserImportJob: (_)=>de_UserImportJobType(_, context)
    });
};
const de_DescribeUserPoolClientResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        UserPoolClient: (_)=>de_UserPoolClientType(_, context)
    });
};
const de_DescribeUserPoolResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        UserPool: (_)=>de_UserPoolType(_, context)
    });
};
const de_DeviceListType = (output, context)=>{
    const retVal = (output || []).filter((e)=>e != null).map((entry)=>{
        return de_DeviceType(entry, context);
    });
    return retVal;
};
const de_DeviceType = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        DeviceAttributes: smithy_client_1._json,
        DeviceCreateDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        DeviceKey: smithy_client_1.expectString,
        DeviceLastAuthenticatedDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        DeviceLastModifiedDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_)))
    });
};
const de_EventFeedbackType = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        FeedbackDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        FeedbackValue: smithy_client_1.expectString,
        Provider: smithy_client_1.expectString
    });
};
const de_GetDeviceResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        Device: (_)=>de_DeviceType(_, context)
    });
};
const de_GetGroupResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        Group: (_)=>de_GroupType(_, context)
    });
};
const de_GetIdentityProviderByIdentifierResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        IdentityProvider: (_)=>de_IdentityProviderType(_, context)
    });
};
const de_GetUICustomizationResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        UICustomization: (_)=>de_UICustomizationType(_, context)
    });
};
const de_GroupListType = (output, context)=>{
    const retVal = (output || []).filter((e)=>e != null).map((entry)=>{
        return de_GroupType(entry, context);
    });
    return retVal;
};
const de_GroupType = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        CreationDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        Description: smithy_client_1.expectString,
        GroupName: smithy_client_1.expectString,
        LastModifiedDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        Precedence: smithy_client_1.expectInt32,
        RoleArn: smithy_client_1.expectString,
        UserPoolId: smithy_client_1.expectString
    });
};
const de_IdentityProviderType = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        AttributeMapping: smithy_client_1._json,
        CreationDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        IdpIdentifiers: smithy_client_1._json,
        LastModifiedDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        ProviderDetails: smithy_client_1._json,
        ProviderName: smithy_client_1.expectString,
        ProviderType: smithy_client_1.expectString,
        UserPoolId: smithy_client_1.expectString
    });
};
const de_ListDevicesResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        Devices: (_)=>de_DeviceListType(_, context),
        PaginationToken: smithy_client_1.expectString
    });
};
const de_ListGroupsResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        Groups: (_)=>de_GroupListType(_, context),
        NextToken: smithy_client_1.expectString
    });
};
const de_ListIdentityProvidersResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        NextToken: smithy_client_1.expectString,
        Providers: (_)=>de_ProvidersListType(_, context)
    });
};
const de_ListUserImportJobsResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        PaginationToken: smithy_client_1.expectString,
        UserImportJobs: (_)=>de_UserImportJobsListType(_, context)
    });
};
const de_ListUserPoolsResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        NextToken: smithy_client_1.expectString,
        UserPools: (_)=>de_UserPoolListType(_, context)
    });
};
const de_ListUsersInGroupResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        NextToken: smithy_client_1.expectString,
        Users: (_)=>de_UsersListType(_, context)
    });
};
const de_ListUsersResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        PaginationToken: smithy_client_1.expectString,
        Users: (_)=>de_UsersListType(_, context)
    });
};
const de_ProviderDescription = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        CreationDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        LastModifiedDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        ProviderName: smithy_client_1.expectString,
        ProviderType: smithy_client_1.expectString
    });
};
const de_ProvidersListType = (output, context)=>{
    const retVal = (output || []).filter((e)=>e != null).map((entry)=>{
        return de_ProviderDescription(entry, context);
    });
    return retVal;
};
const de_RiskConfigurationType = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        AccountTakeoverRiskConfiguration: smithy_client_1._json,
        ClientId: smithy_client_1.expectString,
        CompromisedCredentialsRiskConfiguration: smithy_client_1._json,
        LastModifiedDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        RiskExceptionConfiguration: smithy_client_1._json,
        UserPoolId: smithy_client_1.expectString
    });
};
const de_SetRiskConfigurationResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        RiskConfiguration: (_)=>de_RiskConfigurationType(_, context)
    });
};
const de_SetUICustomizationResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        UICustomization: (_)=>de_UICustomizationType(_, context)
    });
};
const de_StartUserImportJobResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        UserImportJob: (_)=>de_UserImportJobType(_, context)
    });
};
const de_StopUserImportJobResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        UserImportJob: (_)=>de_UserImportJobType(_, context)
    });
};
const de_UICustomizationType = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        CSS: smithy_client_1.expectString,
        CSSVersion: smithy_client_1.expectString,
        ClientId: smithy_client_1.expectString,
        CreationDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        ImageUrl: smithy_client_1.expectString,
        LastModifiedDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        UserPoolId: smithy_client_1.expectString
    });
};
const de_UpdateGroupResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        Group: (_)=>de_GroupType(_, context)
    });
};
const de_UpdateIdentityProviderResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        IdentityProvider: (_)=>de_IdentityProviderType(_, context)
    });
};
const de_UpdateUserPoolClientResponse = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        UserPoolClient: (_)=>de_UserPoolClientType(_, context)
    });
};
const de_UserImportJobsListType = (output, context)=>{
    const retVal = (output || []).filter((e)=>e != null).map((entry)=>{
        return de_UserImportJobType(entry, context);
    });
    return retVal;
};
const de_UserImportJobType = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        CloudWatchLogsRoleArn: smithy_client_1.expectString,
        CompletionDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        CompletionMessage: smithy_client_1.expectString,
        CreationDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        FailedUsers: smithy_client_1.expectLong,
        ImportedUsers: smithy_client_1.expectLong,
        JobId: smithy_client_1.expectString,
        JobName: smithy_client_1.expectString,
        PreSignedUrl: smithy_client_1.expectString,
        SkippedUsers: smithy_client_1.expectLong,
        StartDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        Status: smithy_client_1.expectString,
        UserPoolId: smithy_client_1.expectString
    });
};
const de_UserPoolClientType = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        AccessTokenValidity: smithy_client_1.expectInt32,
        AllowedOAuthFlows: smithy_client_1._json,
        AllowedOAuthFlowsUserPoolClient: smithy_client_1.expectBoolean,
        AllowedOAuthScopes: smithy_client_1._json,
        AnalyticsConfiguration: smithy_client_1._json,
        AuthSessionValidity: smithy_client_1.expectInt32,
        CallbackURLs: smithy_client_1._json,
        ClientId: smithy_client_1.expectString,
        ClientName: smithy_client_1.expectString,
        ClientSecret: smithy_client_1.expectString,
        CreationDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        DefaultRedirectURI: smithy_client_1.expectString,
        EnablePropagateAdditionalUserContextData: smithy_client_1.expectBoolean,
        EnableTokenRevocation: smithy_client_1.expectBoolean,
        ExplicitAuthFlows: smithy_client_1._json,
        IdTokenValidity: smithy_client_1.expectInt32,
        LastModifiedDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        LogoutURLs: smithy_client_1._json,
        PreventUserExistenceErrors: smithy_client_1.expectString,
        ReadAttributes: smithy_client_1._json,
        RefreshTokenValidity: smithy_client_1.expectInt32,
        SupportedIdentityProviders: smithy_client_1._json,
        TokenValidityUnits: smithy_client_1._json,
        UserPoolId: smithy_client_1.expectString,
        WriteAttributes: smithy_client_1._json
    });
};
const de_UserPoolDescriptionType = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        CreationDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        Id: smithy_client_1.expectString,
        LambdaConfig: smithy_client_1._json,
        LastModifiedDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        Name: smithy_client_1.expectString,
        Status: smithy_client_1.expectString
    });
};
const de_UserPoolListType = (output, context)=>{
    const retVal = (output || []).filter((e)=>e != null).map((entry)=>{
        return de_UserPoolDescriptionType(entry, context);
    });
    return retVal;
};
const de_UserPoolType = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        AccountRecoverySetting: smithy_client_1._json,
        AdminCreateUserConfig: smithy_client_1._json,
        AliasAttributes: smithy_client_1._json,
        Arn: smithy_client_1.expectString,
        AutoVerifiedAttributes: smithy_client_1._json,
        CreationDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        CustomDomain: smithy_client_1.expectString,
        DeletionProtection: smithy_client_1.expectString,
        DeviceConfiguration: smithy_client_1._json,
        Domain: smithy_client_1.expectString,
        EmailConfiguration: smithy_client_1._json,
        EmailConfigurationFailure: smithy_client_1.expectString,
        EmailVerificationMessage: smithy_client_1.expectString,
        EmailVerificationSubject: smithy_client_1.expectString,
        EstimatedNumberOfUsers: smithy_client_1.expectInt32,
        Id: smithy_client_1.expectString,
        LambdaConfig: smithy_client_1._json,
        LastModifiedDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        MfaConfiguration: smithy_client_1.expectString,
        Name: smithy_client_1.expectString,
        Policies: smithy_client_1._json,
        SchemaAttributes: smithy_client_1._json,
        SmsAuthenticationMessage: smithy_client_1.expectString,
        SmsConfiguration: smithy_client_1._json,
        SmsConfigurationFailure: smithy_client_1.expectString,
        SmsVerificationMessage: smithy_client_1.expectString,
        Status: smithy_client_1.expectString,
        UserAttributeUpdateSettings: smithy_client_1._json,
        UserPoolAddOns: smithy_client_1._json,
        UserPoolTags: smithy_client_1._json,
        UsernameAttributes: smithy_client_1._json,
        UsernameConfiguration: smithy_client_1._json,
        VerificationMessageTemplate: smithy_client_1._json
    });
};
const de_UsersListType = (output, context)=>{
    const retVal = (output || []).filter((e)=>e != null).map((entry)=>{
        return de_UserType(entry, context);
    });
    return retVal;
};
const de_UserType = (output, context)=>{
    return (0, smithy_client_1.take)(output, {
        Attributes: smithy_client_1._json,
        Enabled: smithy_client_1.expectBoolean,
        MFAOptions: smithy_client_1._json,
        UserCreateDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        UserLastModifiedDate: (_)=>(0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseEpochTimestamp)((0, smithy_client_1.expectNumber)(_))),
        UserStatus: smithy_client_1.expectString,
        Username: smithy_client_1.expectString
    });
};
const deserializeMetadata = (output)=>({
        httpStatusCode: output.statusCode,
        requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"]
    });
const collectBodyString = (streamBody, context)=>(0, smithy_client_1.collectBody)(streamBody, context).then((body)=>context.utf8Encoder(body));
const throwDefaultError = (0, smithy_client_1.withBaseException)(CognitoIdentityProviderServiceException_1.CognitoIdentityProviderServiceException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body)=>{
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
function sharedHeaders(operation) {
    return {
        "content-type": "application/x-amz-json-1.1",
        "x-amz-target": `AWSCognitoIdentityProviderService.${operation}`
    };
}
const parseBody = (streamBody, context)=>collectBodyString(streamBody, context).then((encoded)=>{
        if (encoded.length) {
            return JSON.parse(encoded);
        }
        return {};
    });
const parseErrorBody = async (errorBody, context)=>{
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data)=>{
    const findKey = (object, key)=>Object.keys(object).find((k)=>k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue)=>{
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};


/***/ }),

/***/ 86308:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getRuntimeConfig = void 0;
const tslib_1 = __webpack_require__(35092);
const package_json_1 = tslib_1.__importDefault(__webpack_require__(21467));
const client_sts_1 = __webpack_require__(15590);
const credential_provider_node_1 = __webpack_require__(55116);
const util_user_agent_node_1 = __webpack_require__(62850);
const config_resolver_1 = __webpack_require__(25708);
const hash_node_1 = __webpack_require__(44341);
const middleware_retry_1 = __webpack_require__(75567);
const node_config_provider_1 = __webpack_require__(15829);
const node_http_handler_1 = __webpack_require__(44025);
const util_body_length_node_1 = __webpack_require__(2414);
const util_retry_1 = __webpack_require__(7885);
const runtimeConfig_shared_1 = __webpack_require__(74753);
const smithy_client_1 = __webpack_require__(18851);
const util_defaults_mode_node_1 = __webpack_require__(87393);
const smithy_client_2 = __webpack_require__(18851);
const getRuntimeConfig = (config)=>{
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = ()=>defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? (0, client_sts_1.decorateDefaultCredentialProvider)(credential_provider_node_1.defaultProvider),
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.defaultUserAgent)({
            serviceId: clientSharedValues.serviceId,
            clientVersion: package_json_1.default.version
        }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
            ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
            default: async ()=>(await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
        }),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 74753:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getRuntimeConfig = void 0;
const smithy_client_1 = __webpack_require__(18851);
const url_parser_1 = __webpack_require__(45110);
const util_base64_1 = __webpack_require__(53013);
const util_utf8_1 = __webpack_require__(66120);
const endpointResolver_1 = __webpack_require__(58867);
const getRuntimeConfig = (config)=>({
        apiVersion: "2016-04-18",
        base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
        base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
        serviceId: config?.serviceId ?? "Cognito Identity Provider",
        urlParser: config?.urlParser ?? url_parser_1.parseUrl,
        utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
    });
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 82201:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveRuntimeExtensions = void 0;
const smithy_client_1 = __webpack_require__(18851);
const asPartial = (t)=>t;
const resolveRuntimeExtensions = (runtimeConfig, extensions)=>{
    const extensionConfiguration = {
        ...asPartial((0, smithy_client_1.getDefaultExtensionConfiguration)(runtimeConfig))
    };
    extensions.forEach((extension)=>extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...(0, smithy_client_1.resolveDefaultRuntimeConfig)(extensionConfiguration)
    };
};
exports.resolveRuntimeExtensions = resolveRuntimeExtensions;


/***/ }),

/***/ 7330:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SSO = void 0;
const smithy_client_1 = __webpack_require__(18851);
const GetRoleCredentialsCommand_1 = __webpack_require__(20010);
const ListAccountRolesCommand_1 = __webpack_require__(94054);
const ListAccountsCommand_1 = __webpack_require__(17163);
const LogoutCommand_1 = __webpack_require__(46881);
const SSOClient_1 = __webpack_require__(41125);
const commands = {
    GetRoleCredentialsCommand: GetRoleCredentialsCommand_1.GetRoleCredentialsCommand,
    ListAccountRolesCommand: ListAccountRolesCommand_1.ListAccountRolesCommand,
    ListAccountsCommand: ListAccountsCommand_1.ListAccountsCommand,
    LogoutCommand: LogoutCommand_1.LogoutCommand
};
class SSO extends SSOClient_1.SSOClient {
}
exports.SSO = SSO;
(0, smithy_client_1.createAggregatedClient)(commands, SSO);


/***/ }),

/***/ 41125:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SSOClient = exports.__Client = void 0;
const middleware_host_header_1 = __webpack_require__(23496);
const middleware_logger_1 = __webpack_require__(25791);
const middleware_recursion_detection_1 = __webpack_require__(86548);
const middleware_user_agent_1 = __webpack_require__(71886);
const config_resolver_1 = __webpack_require__(25708);
const middleware_content_length_1 = __webpack_require__(32636);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_retry_1 = __webpack_require__(75567);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "__Client", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Client;
    }
}));
const EndpointParameters_1 = __webpack_require__(60506);
const runtimeConfig_1 = __webpack_require__(40595);
const runtimeExtensions_1 = __webpack_require__(52131);
class SSOClient extends smithy_client_1.Client {
    constructor(...[configuration]){
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration || {});
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_5);
        const _config_7 = (0, runtimeExtensions_1.resolveRuntimeExtensions)(_config_6, configuration?.extensions || []);
        super(_config_7);
        this.config = _config_7;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.SSOClient = SSOClient;


/***/ }),

/***/ 20010:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GetRoleCredentialsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(96608);
const Aws_restJson1_1 = __webpack_require__(56620);
class GetRoleCredentialsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetRoleCredentialsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOClient";
        const commandName = "GetRoleCredentialsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.GetRoleCredentialsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.GetRoleCredentialsResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_GetRoleCredentialsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_GetRoleCredentialsCommand)(output, context);
    }
}
exports.GetRoleCredentialsCommand = GetRoleCredentialsCommand;


/***/ }),

/***/ 94054:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ListAccountRolesCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(96608);
const Aws_restJson1_1 = __webpack_require__(56620);
class ListAccountRolesCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListAccountRolesCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOClient";
        const commandName = "ListAccountRolesCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListAccountRolesRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_ListAccountRolesCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_ListAccountRolesCommand)(output, context);
    }
}
exports.ListAccountRolesCommand = ListAccountRolesCommand;


/***/ }),

/***/ 17163:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ListAccountsCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(96608);
const Aws_restJson1_1 = __webpack_require__(56620);
class ListAccountsCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, ListAccountsCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOClient";
        const commandName = "ListAccountsCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.ListAccountsRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_ListAccountsCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_ListAccountsCommand)(output, context);
    }
}
exports.ListAccountsCommand = ListAccountsCommand;


/***/ }),

/***/ 46881:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.LogoutCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(96608);
const Aws_restJson1_1 = __webpack_require__(56620);
class LogoutCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, LogoutCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOClient";
        const commandName = "LogoutCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.LogoutRequestFilterSensitiveLog,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_restJson1_1.se_LogoutCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_restJson1_1.de_LogoutCommand)(output, context);
    }
}
exports.LogoutCommand = LogoutCommand;


/***/ }),

/***/ 18086:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(20010), exports);
tslib_1.__exportStar(__webpack_require__(94054), exports);
tslib_1.__exportStar(__webpack_require__(17163), exports);
tslib_1.__exportStar(__webpack_require__(46881), exports);


/***/ }),

/***/ 60506:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options)=>{
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        defaultSigningName: "awsssoportal"
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;


/***/ }),

/***/ 38897:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __webpack_require__(8059);
const ruleset_1 = __webpack_require__(59623);
const defaultEndpointResolver = (endpointParams, context = {})=>{
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 59623:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ruleSet = void 0;
const p = "required", q = "fn", r = "argv", s = "ref";
const a = "PartitionResult", b = "tree", c = "error", d = "endpoint", e = {
    [p]: false,
    "type": "String"
}, f = {
    [p]: true,
    "default": false,
    "type": "Boolean"
}, g = {
    [s]: "Endpoint"
}, h = {
    [q]: "booleanEquals",
    [r]: [
        {
            [s]: "UseFIPS"
        },
        true
    ]
}, i = {
    [q]: "booleanEquals",
    [r]: [
        {
            [s]: "UseDualStack"
        },
        true
    ]
}, j = {}, k = {
    [q]: "booleanEquals",
    [r]: [
        true,
        {
            [q]: "getAttr",
            [r]: [
                {
                    [s]: a
                },
                "supportsFIPS"
            ]
        }
    ]
}, l = {
    [q]: "booleanEquals",
    [r]: [
        true,
        {
            [q]: "getAttr",
            [r]: [
                {
                    [s]: a
                },
                "supportsDualStack"
            ]
        }
    ]
}, m = [
    g
], n = [
    h
], o = [
    i
];
const _data = {
    version: "1.0",
    parameters: {
        Region: e,
        UseDualStack: f,
        UseFIPS: f,
        Endpoint: e
    },
    rules: [
        {
            conditions: [
                {
                    [q]: "aws.partition",
                    [r]: [
                        {
                            [s]: "Region"
                        }
                    ],
                    assign: a
                }
            ],
            type: b,
            rules: [
                {
                    conditions: [
                        {
                            [q]: "isSet",
                            [r]: m
                        },
                        {
                            [q]: "parseURL",
                            [r]: m,
                            assign: "url"
                        }
                    ],
                    type: b,
                    rules: [
                        {
                            conditions: n,
                            error: "Invalid Configuration: FIPS and custom endpoint are not supported",
                            type: c
                        },
                        {
                            type: b,
                            rules: [
                                {
                                    conditions: o,
                                    error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
                                    type: c
                                },
                                {
                                    endpoint: {
                                        url: g,
                                        properties: j,
                                        headers: j
                                    },
                                    type: d
                                }
                            ]
                        }
                    ]
                },
                {
                    conditions: [
                        h,
                        i
                    ],
                    type: b,
                    rules: [
                        {
                            conditions: [
                                k,
                                l
                            ],
                            type: b,
                            rules: [
                                {
                                    endpoint: {
                                        url: "https://portal.sso-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                                        properties: j,
                                        headers: j
                                    },
                                    type: d
                                }
                            ]
                        },
                        {
                            error: "FIPS and DualStack are enabled, but this partition does not support one or both",
                            type: c
                        }
                    ]
                },
                {
                    conditions: n,
                    type: b,
                    rules: [
                        {
                            conditions: [
                                k
                            ],
                            type: b,
                            rules: [
                                {
                                    type: b,
                                    rules: [
                                        {
                                            endpoint: {
                                                url: "https://portal.sso-fips.{Region}.{PartitionResult#dnsSuffix}",
                                                properties: j,
                                                headers: j
                                            },
                                            type: d
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            error: "FIPS is enabled but this partition does not support FIPS",
                            type: c
                        }
                    ]
                },
                {
                    conditions: o,
                    type: b,
                    rules: [
                        {
                            conditions: [
                                l
                            ],
                            type: b,
                            rules: [
                                {
                                    endpoint: {
                                        url: "https://portal.sso.{Region}.{PartitionResult#dualStackDnsSuffix}",
                                        properties: j,
                                        headers: j
                                    },
                                    type: d
                                }
                            ]
                        },
                        {
                            error: "DualStack is enabled but this partition does not support DualStack",
                            type: c
                        }
                    ]
                },
                {
                    endpoint: {
                        url: "https://portal.sso.{Region}.{PartitionResult#dnsSuffix}",
                        properties: j,
                        headers: j
                    },
                    type: d
                }
            ]
        }
    ]
};
exports.ruleSet = _data;


/***/ }),

/***/ 66510:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SSOServiceException = void 0;
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(41125), exports);
tslib_1.__exportStar(__webpack_require__(7330), exports);
tslib_1.__exportStar(__webpack_require__(18086), exports);
tslib_1.__exportStar(__webpack_require__(10745), exports);
tslib_1.__exportStar(__webpack_require__(14355), exports);
var SSOServiceException_1 = __webpack_require__(6389);
Object.defineProperty(exports, "SSOServiceException", ({
    enumerable: true,
    get: function() {
        return SSOServiceException_1.SSOServiceException;
    }
}));


/***/ }),

/***/ 6389:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SSOServiceException = exports.__ServiceException = void 0;
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "__ServiceException", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.ServiceException;
    }
}));
class SSOServiceException extends smithy_client_1.ServiceException {
    constructor(options){
        super(options);
        Object.setPrototypeOf(this, SSOServiceException.prototype);
    }
}
exports.SSOServiceException = SSOServiceException;


/***/ }),

/***/ 14355:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(96608), exports);


/***/ }),

/***/ 96608:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.LogoutRequestFilterSensitiveLog = exports.ListAccountsRequestFilterSensitiveLog = exports.ListAccountRolesRequestFilterSensitiveLog = exports.GetRoleCredentialsResponseFilterSensitiveLog = exports.RoleCredentialsFilterSensitiveLog = exports.GetRoleCredentialsRequestFilterSensitiveLog = exports.UnauthorizedException = exports.TooManyRequestsException = exports.ResourceNotFoundException = exports.InvalidRequestException = void 0;
const smithy_client_1 = __webpack_require__(18851);
const SSOServiceException_1 = __webpack_require__(6389);
class InvalidRequestException extends SSOServiceException_1.SSOServiceException {
    constructor(opts){
        super({
            name: "InvalidRequestException",
            $fault: "client",
            ...opts
        });
        this.name = "InvalidRequestException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidRequestException.prototype);
    }
}
exports.InvalidRequestException = InvalidRequestException;
class ResourceNotFoundException extends SSOServiceException_1.SSOServiceException {
    constructor(opts){
        super({
            name: "ResourceNotFoundException",
            $fault: "client",
            ...opts
        });
        this.name = "ResourceNotFoundException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ResourceNotFoundException.prototype);
    }
}
exports.ResourceNotFoundException = ResourceNotFoundException;
class TooManyRequestsException extends SSOServiceException_1.SSOServiceException {
    constructor(opts){
        super({
            name: "TooManyRequestsException",
            $fault: "client",
            ...opts
        });
        this.name = "TooManyRequestsException";
        this.$fault = "client";
        Object.setPrototypeOf(this, TooManyRequestsException.prototype);
    }
}
exports.TooManyRequestsException = TooManyRequestsException;
class UnauthorizedException extends SSOServiceException_1.SSOServiceException {
    constructor(opts){
        super({
            name: "UnauthorizedException",
            $fault: "client",
            ...opts
        });
        this.name = "UnauthorizedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, UnauthorizedException.prototype);
    }
}
exports.UnauthorizedException = UnauthorizedException;
const GetRoleCredentialsRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.accessToken && {
            accessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.GetRoleCredentialsRequestFilterSensitiveLog = GetRoleCredentialsRequestFilterSensitiveLog;
const RoleCredentialsFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.secretAccessKey && {
            secretAccessKey: smithy_client_1.SENSITIVE_STRING
        },
        ...obj.sessionToken && {
            sessionToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.RoleCredentialsFilterSensitiveLog = RoleCredentialsFilterSensitiveLog;
const GetRoleCredentialsResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.roleCredentials && {
            roleCredentials: (0, exports.RoleCredentialsFilterSensitiveLog)(obj.roleCredentials)
        }
    });
exports.GetRoleCredentialsResponseFilterSensitiveLog = GetRoleCredentialsResponseFilterSensitiveLog;
const ListAccountRolesRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.accessToken && {
            accessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.ListAccountRolesRequestFilterSensitiveLog = ListAccountRolesRequestFilterSensitiveLog;
const ListAccountsRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.accessToken && {
            accessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.ListAccountsRequestFilterSensitiveLog = ListAccountsRequestFilterSensitiveLog;
const LogoutRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.accessToken && {
            accessToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.LogoutRequestFilterSensitiveLog = LogoutRequestFilterSensitiveLog;


/***/ }),

/***/ 33099:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 10059:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.paginateListAccountRoles = void 0;
const ListAccountRolesCommand_1 = __webpack_require__(94054);
const SSOClient_1 = __webpack_require__(41125);
const makePagedClientRequest = async (client, input, ...args)=>{
    return await client.send(new ListAccountRolesCommand_1.ListAccountRolesCommand(input), ...args);
};
async function* paginateListAccountRoles(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while(hasNext){
        input.nextToken = token;
        input["maxResults"] = config.pageSize;
        if (config.client instanceof SSOClient_1.SSOClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        } else {
            throw new Error("Invalid client, expected SSO | SSOClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListAccountRoles = paginateListAccountRoles;


/***/ }),

/***/ 13724:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.paginateListAccounts = void 0;
const ListAccountsCommand_1 = __webpack_require__(17163);
const SSOClient_1 = __webpack_require__(41125);
const makePagedClientRequest = async (client, input, ...args)=>{
    return await client.send(new ListAccountsCommand_1.ListAccountsCommand(input), ...args);
};
async function* paginateListAccounts(config, input, ...additionalArguments) {
    let token = config.startingToken || undefined;
    let hasNext = true;
    let page;
    while(hasNext){
        input.nextToken = token;
        input["maxResults"] = config.pageSize;
        if (config.client instanceof SSOClient_1.SSOClient) {
            page = await makePagedClientRequest(config.client, input, ...additionalArguments);
        } else {
            throw new Error("Invalid client, expected SSO | SSOClient");
        }
        yield page;
        const prevToken = token;
        token = page.nextToken;
        hasNext = !!(token && (!config.stopOnSameToken || token !== prevToken));
    }
    return undefined;
}
exports.paginateListAccounts = paginateListAccounts;


/***/ }),

/***/ 10745:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(33099), exports);
tslib_1.__exportStar(__webpack_require__(10059), exports);
tslib_1.__exportStar(__webpack_require__(13724), exports);


/***/ }),

/***/ 56620:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.de_LogoutCommand = exports.de_ListAccountsCommand = exports.de_ListAccountRolesCommand = exports.de_GetRoleCredentialsCommand = exports.se_LogoutCommand = exports.se_ListAccountsCommand = exports.se_ListAccountRolesCommand = exports.se_GetRoleCredentialsCommand = void 0;
const protocol_http_1 = __webpack_require__(64082);
const smithy_client_1 = __webpack_require__(18851);
const models_0_1 = __webpack_require__(96608);
const SSOServiceException_1 = __webpack_require__(6389);
const se_GetRoleCredentialsCommand = async (input, context)=>{
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amz-sso_bearer_token": input.accessToken
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/federation/credentials";
    const query = (0, smithy_client_1.map)({
        role_name: [
            ,
            (0, smithy_client_1.expectNonNull)(input.roleName, `roleName`)
        ],
        account_id: [
            ,
            (0, smithy_client_1.expectNonNull)(input.accountId, `accountId`)
        ]
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body
    });
};
exports.se_GetRoleCredentialsCommand = se_GetRoleCredentialsCommand;
const se_ListAccountRolesCommand = async (input, context)=>{
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amz-sso_bearer_token": input.accessToken
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/assignment/roles";
    const query = (0, smithy_client_1.map)({
        next_token: [
            ,
            input.nextToken
        ],
        max_result: [
            ()=>input.maxResults !== void 0,
            ()=>input.maxResults.toString()
        ],
        account_id: [
            ,
            (0, smithy_client_1.expectNonNull)(input.accountId, `accountId`)
        ]
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body
    });
};
exports.se_ListAccountRolesCommand = se_ListAccountRolesCommand;
const se_ListAccountsCommand = async (input, context)=>{
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amz-sso_bearer_token": input.accessToken
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/assignment/accounts";
    const query = (0, smithy_client_1.map)({
        next_token: [
            ,
            input.nextToken
        ],
        max_result: [
            ()=>input.maxResults !== void 0,
            ()=>input.maxResults.toString()
        ]
    });
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "GET",
        headers,
        path: resolvedPath,
        query,
        body
    });
};
exports.se_ListAccountsCommand = se_ListAccountsCommand;
const se_LogoutCommand = async (input, context)=>{
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = (0, smithy_client_1.map)({}, isSerializableHeaderValue, {
        "x-amz-sso_bearer_token": input.accessToken
    });
    const resolvedPath = `${basePath?.endsWith("/") ? basePath.slice(0, -1) : basePath || ""}` + "/logout";
    let body;
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body
    });
};
exports.se_LogoutCommand = se_LogoutCommand;
const de_GetRoleCredentialsCommand = async (output, context)=>{
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_GetRoleCredentialsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        roleCredentials: smithy_client_1._json
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_GetRoleCredentialsCommand = de_GetRoleCredentialsCommand;
const de_GetRoleCredentialsCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ListAccountRolesCommand = async (output, context)=>{
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAccountRolesCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        nextToken: smithy_client_1.expectString,
        roleList: smithy_client_1._json
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListAccountRolesCommand = de_ListAccountRolesCommand;
const de_ListAccountRolesCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_ListAccountsCommand = async (output, context)=>{
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_ListAccountsCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_1.take)(data, {
        accountList: smithy_client_1._json,
        nextToken: smithy_client_1.expectString
    });
    Object.assign(contents, doc);
    return contents;
};
exports.de_ListAccountsCommand = de_ListAccountsCommand;
const de_ListAccountsCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "ResourceNotFoundException":
        case "com.amazonaws.sso#ResourceNotFoundException":
            throw await de_ResourceNotFoundExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const de_LogoutCommand = async (output, context)=>{
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_LogoutCommandError(output, context);
    }
    const contents = (0, smithy_client_1.map)({
        $metadata: deserializeMetadata(output)
    });
    await (0, smithy_client_1.collectBody)(output.body, context);
    return contents;
};
exports.de_LogoutCommand = de_LogoutCommand;
const de_LogoutCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InvalidRequestException":
        case "com.amazonaws.sso#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "TooManyRequestsException":
        case "com.amazonaws.sso#TooManyRequestsException":
            throw await de_TooManyRequestsExceptionRes(parsedOutput, context);
        case "UnauthorizedException":
        case "com.amazonaws.sso#UnauthorizedException":
            throw await de_UnauthorizedExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
const throwDefaultError = (0, smithy_client_1.withBaseException)(SSOServiceException_1.SSOServiceException);
const de_InvalidRequestExceptionRes = async (parsedOutput, context)=>{
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_ResourceNotFoundExceptionRes = async (parsedOutput, context)=>{
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.ResourceNotFoundException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_TooManyRequestsExceptionRes = async (parsedOutput, context)=>{
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.TooManyRequestsException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const de_UnauthorizedExceptionRes = async (parsedOutput, context)=>{
    const contents = (0, smithy_client_1.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_1.take)(data, {
        message: smithy_client_1.expectString
    });
    Object.assign(contents, doc);
    const exception = new models_0_1.UnauthorizedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
    });
    return (0, smithy_client_1.decorateServiceException)(exception, parsedOutput.body);
};
const deserializeMetadata = (output)=>({
        httpStatusCode: output.statusCode,
        requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"]
    });
const collectBodyString = (streamBody, context)=>(0, smithy_client_1.collectBody)(streamBody, context).then((body)=>context.utf8Encoder(body));
const isSerializableHeaderValue = (value)=>value !== undefined && value !== null && value !== "" && (!Object.getOwnPropertyNames(value).includes("length") || value.length != 0) && (!Object.getOwnPropertyNames(value).includes("size") || value.size != 0);
const parseBody = (streamBody, context)=>collectBodyString(streamBody, context).then((encoded)=>{
        if (encoded.length) {
            return JSON.parse(encoded);
        }
        return {};
    });
const parseErrorBody = async (errorBody, context)=>{
    const value = await parseBody(errorBody, context);
    value.message = value.message ?? value.Message;
    return value;
};
const loadRestJsonErrorCode = (output, data)=>{
    const findKey = (object, key)=>Object.keys(object).find((k)=>k.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue)=>{
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== undefined) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== undefined) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== undefined) {
        return sanitizeErrorCode(data["__type"]);
    }
};


/***/ }),

/***/ 40595:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getRuntimeConfig = void 0;
const tslib_1 = __webpack_require__(35092);
const package_json_1 = tslib_1.__importDefault(__webpack_require__(21972));
const util_user_agent_node_1 = __webpack_require__(62850);
const config_resolver_1 = __webpack_require__(25708);
const hash_node_1 = __webpack_require__(44341);
const middleware_retry_1 = __webpack_require__(75567);
const node_config_provider_1 = __webpack_require__(15829);
const node_http_handler_1 = __webpack_require__(44025);
const util_body_length_node_1 = __webpack_require__(2414);
const util_retry_1 = __webpack_require__(7885);
const runtimeConfig_shared_1 = __webpack_require__(4612);
const smithy_client_1 = __webpack_require__(18851);
const util_defaults_mode_node_1 = __webpack_require__(87393);
const smithy_client_2 = __webpack_require__(18851);
const getRuntimeConfig = (config)=>{
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = ()=>defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.defaultUserAgent)({
            serviceId: clientSharedValues.serviceId,
            clientVersion: package_json_1.default.version
        }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
            ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
            default: async ()=>(await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
        }),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 4612:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getRuntimeConfig = void 0;
const smithy_client_1 = __webpack_require__(18851);
const url_parser_1 = __webpack_require__(45110);
const util_base64_1 = __webpack_require__(53013);
const util_utf8_1 = __webpack_require__(66120);
const endpointResolver_1 = __webpack_require__(38897);
const getRuntimeConfig = (config)=>({
        apiVersion: "2019-06-10",
        base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
        base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
        serviceId: config?.serviceId ?? "SSO",
        urlParser: config?.urlParser ?? url_parser_1.parseUrl,
        utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
    });
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 52131:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveRuntimeExtensions = void 0;
const smithy_client_1 = __webpack_require__(18851);
const asPartial = (t)=>t;
const resolveRuntimeExtensions = (runtimeConfig, extensions)=>{
    const extensionConfiguration = {
        ...asPartial((0, smithy_client_1.getDefaultExtensionConfiguration)(runtimeConfig))
    };
    extensions.forEach((extension)=>extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...(0, smithy_client_1.resolveDefaultRuntimeConfig)(extensionConfiguration)
    };
};
exports.resolveRuntimeExtensions = resolveRuntimeExtensions;


/***/ }),

/***/ 84166:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.STS = void 0;
const smithy_client_1 = __webpack_require__(18851);
const AssumeRoleCommand_1 = __webpack_require__(30279);
const AssumeRoleWithSAMLCommand_1 = __webpack_require__(26458);
const AssumeRoleWithWebIdentityCommand_1 = __webpack_require__(41486);
const DecodeAuthorizationMessageCommand_1 = __webpack_require__(49773);
const GetAccessKeyInfoCommand_1 = __webpack_require__(90779);
const GetCallerIdentityCommand_1 = __webpack_require__(8515);
const GetFederationTokenCommand_1 = __webpack_require__(54901);
const GetSessionTokenCommand_1 = __webpack_require__(24238);
const STSClient_1 = __webpack_require__(952);
const commands = {
    AssumeRoleCommand: AssumeRoleCommand_1.AssumeRoleCommand,
    AssumeRoleWithSAMLCommand: AssumeRoleWithSAMLCommand_1.AssumeRoleWithSAMLCommand,
    AssumeRoleWithWebIdentityCommand: AssumeRoleWithWebIdentityCommand_1.AssumeRoleWithWebIdentityCommand,
    DecodeAuthorizationMessageCommand: DecodeAuthorizationMessageCommand_1.DecodeAuthorizationMessageCommand,
    GetAccessKeyInfoCommand: GetAccessKeyInfoCommand_1.GetAccessKeyInfoCommand,
    GetCallerIdentityCommand: GetCallerIdentityCommand_1.GetCallerIdentityCommand,
    GetFederationTokenCommand: GetFederationTokenCommand_1.GetFederationTokenCommand,
    GetSessionTokenCommand: GetSessionTokenCommand_1.GetSessionTokenCommand
};
class STS extends STSClient_1.STSClient {
}
exports.STS = STS;
(0, smithy_client_1.createAggregatedClient)(commands, STS);


/***/ }),

/***/ 952:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.STSClient = exports.__Client = void 0;
const middleware_host_header_1 = __webpack_require__(23496);
const middleware_logger_1 = __webpack_require__(25791);
const middleware_recursion_detection_1 = __webpack_require__(86548);
const middleware_sdk_sts_1 = __webpack_require__(19639);
const middleware_user_agent_1 = __webpack_require__(71886);
const config_resolver_1 = __webpack_require__(25708);
const middleware_content_length_1 = __webpack_require__(32636);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_retry_1 = __webpack_require__(75567);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "__Client", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Client;
    }
}));
const EndpointParameters_1 = __webpack_require__(9976);
const runtimeConfig_1 = __webpack_require__(75496);
const runtimeExtensions_1 = __webpack_require__(47371);
class STSClient extends smithy_client_1.Client {
    constructor(...[configuration]){
        const _config_0 = (0, runtimeConfig_1.getRuntimeConfig)(configuration || {});
        const _config_1 = (0, EndpointParameters_1.resolveClientEndpointParameters)(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_sdk_sts_1.resolveStsAuthConfig)(_config_5, {
            stsClientCtor: STSClient
        });
        const _config_7 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_6);
        const _config_8 = (0, runtimeExtensions_1.resolveRuntimeExtensions)(_config_7, configuration?.extensions || []);
        super(_config_8);
        this.config = _config_8;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
}
exports.STSClient = STSClient;


/***/ }),

/***/ 30279:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AssumeRoleCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(72159);
const Aws_query_1 = __webpack_require__(51641);
class AssumeRoleCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: {
                type: "builtInParams",
                name: "useGlobalEndpoint"
            },
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AssumeRoleCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "AssumeRoleCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: models_0_1.AssumeRoleResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_AssumeRoleCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_AssumeRoleCommand)(output, context);
    }
}
exports.AssumeRoleCommand = AssumeRoleCommand;


/***/ }),

/***/ 26458:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AssumeRoleWithSAMLCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(72159);
const Aws_query_1 = __webpack_require__(51641);
class AssumeRoleWithSAMLCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: {
                type: "builtInParams",
                name: "useGlobalEndpoint"
            },
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AssumeRoleWithSAMLCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "AssumeRoleWithSAMLCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AssumeRoleWithSAMLRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.AssumeRoleWithSAMLResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_AssumeRoleWithSAMLCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_AssumeRoleWithSAMLCommand)(output, context);
    }
}
exports.AssumeRoleWithSAMLCommand = AssumeRoleWithSAMLCommand;


/***/ }),

/***/ 41486:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AssumeRoleWithWebIdentityCommand = exports.$Command = void 0;
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(72159);
const Aws_query_1 = __webpack_require__(51641);
class AssumeRoleWithWebIdentityCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: {
                type: "builtInParams",
                name: "useGlobalEndpoint"
            },
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, AssumeRoleWithWebIdentityCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "AssumeRoleWithWebIdentityCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: models_0_1.AssumeRoleWithWebIdentityRequestFilterSensitiveLog,
            outputFilterSensitiveLog: models_0_1.AssumeRoleWithWebIdentityResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_AssumeRoleWithWebIdentityCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_AssumeRoleWithWebIdentityCommand)(output, context);
    }
}
exports.AssumeRoleWithWebIdentityCommand = AssumeRoleWithWebIdentityCommand;


/***/ }),

/***/ 49773:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DecodeAuthorizationMessageCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_query_1 = __webpack_require__(51641);
class DecodeAuthorizationMessageCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: {
                type: "builtInParams",
                name: "useGlobalEndpoint"
            },
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, DecodeAuthorizationMessageCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "DecodeAuthorizationMessageCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_DecodeAuthorizationMessageCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_DecodeAuthorizationMessageCommand)(output, context);
    }
}
exports.DecodeAuthorizationMessageCommand = DecodeAuthorizationMessageCommand;


/***/ }),

/***/ 90779:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GetAccessKeyInfoCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_query_1 = __webpack_require__(51641);
class GetAccessKeyInfoCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: {
                type: "builtInParams",
                name: "useGlobalEndpoint"
            },
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetAccessKeyInfoCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "GetAccessKeyInfoCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetAccessKeyInfoCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetAccessKeyInfoCommand)(output, context);
    }
}
exports.GetAccessKeyInfoCommand = GetAccessKeyInfoCommand;


/***/ }),

/***/ 8515:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GetCallerIdentityCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const Aws_query_1 = __webpack_require__(51641);
class GetCallerIdentityCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: {
                type: "builtInParams",
                name: "useGlobalEndpoint"
            },
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetCallerIdentityCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "GetCallerIdentityCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetCallerIdentityCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetCallerIdentityCommand)(output, context);
    }
}
exports.GetCallerIdentityCommand = GetCallerIdentityCommand;


/***/ }),

/***/ 54901:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GetFederationTokenCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(72159);
const Aws_query_1 = __webpack_require__(51641);
class GetFederationTokenCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: {
                type: "builtInParams",
                name: "useGlobalEndpoint"
            },
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetFederationTokenCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "GetFederationTokenCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: models_0_1.GetFederationTokenResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetFederationTokenCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetFederationTokenCommand)(output, context);
    }
}
exports.GetFederationTokenCommand = GetFederationTokenCommand;


/***/ }),

/***/ 24238:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GetSessionTokenCommand = exports.$Command = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "$Command", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.Command;
    }
}));
const models_0_1 = __webpack_require__(72159);
const Aws_query_1 = __webpack_require__(51641);
class GetSessionTokenCommand extends smithy_client_1.Command {
    static getEndpointParameterInstructions() {
        return {
            UseGlobalEndpoint: {
                type: "builtInParams",
                name: "useGlobalEndpoint"
            },
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    constructor(input){
        super();
        this.input = input;
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_1.getEndpointPlugin)(configuration, GetSessionTokenCommand.getEndpointParameterInstructions()));
        this.middlewareStack.use((0, middleware_signing_1.getAwsAuthPlugin)(configuration));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "STSClient";
        const commandName = "GetSessionTokenCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: models_0_1.GetSessionTokenResponseFilterSensitiveLog
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return (0, Aws_query_1.se_GetSessionTokenCommand)(input, context);
    }
    deserialize(output, context) {
        return (0, Aws_query_1.de_GetSessionTokenCommand)(output, context);
    }
}
exports.GetSessionTokenCommand = GetSessionTokenCommand;


/***/ }),

/***/ 96842:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(30279), exports);
tslib_1.__exportStar(__webpack_require__(26458), exports);
tslib_1.__exportStar(__webpack_require__(41486), exports);
tslib_1.__exportStar(__webpack_require__(49773), exports);
tslib_1.__exportStar(__webpack_require__(90779), exports);
tslib_1.__exportStar(__webpack_require__(8515), exports);
tslib_1.__exportStar(__webpack_require__(54901), exports);
tslib_1.__exportStar(__webpack_require__(24238), exports);


/***/ }),

/***/ 47910:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.decorateDefaultCredentialProvider = exports.getDefaultRoleAssumerWithWebIdentity = exports.getDefaultRoleAssumer = void 0;
const defaultStsRoleAssumers_1 = __webpack_require__(62688);
const STSClient_1 = __webpack_require__(952);
const getCustomizableStsClientCtor = (baseCtor, customizations)=>{
    if (!customizations) return baseCtor;
    else return class CustomizableSTSClient extends baseCtor {
        constructor(config){
            super(config);
            for (const customization of customizations){
                this.middlewareStack.use(customization);
            }
        }
    };
};
const getDefaultRoleAssumer = (stsOptions = {}, stsPlugins)=>(0, defaultStsRoleAssumers_1.getDefaultRoleAssumer)(stsOptions, getCustomizableStsClientCtor(STSClient_1.STSClient, stsPlugins));
exports.getDefaultRoleAssumer = getDefaultRoleAssumer;
const getDefaultRoleAssumerWithWebIdentity = (stsOptions = {}, stsPlugins)=>(0, defaultStsRoleAssumers_1.getDefaultRoleAssumerWithWebIdentity)(stsOptions, getCustomizableStsClientCtor(STSClient_1.STSClient, stsPlugins));
exports.getDefaultRoleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity;
const decorateDefaultCredentialProvider = (provider)=>(input)=>provider({
            roleAssumer: (0, exports.getDefaultRoleAssumer)(input),
            roleAssumerWithWebIdentity: (0, exports.getDefaultRoleAssumerWithWebIdentity)(input),
            ...input
        });
exports.decorateDefaultCredentialProvider = decorateDefaultCredentialProvider;


/***/ }),

/***/ 62688:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.decorateDefaultCredentialProvider = exports.getDefaultRoleAssumerWithWebIdentity = exports.getDefaultRoleAssumer = void 0;
const AssumeRoleCommand_1 = __webpack_require__(30279);
const AssumeRoleWithWebIdentityCommand_1 = __webpack_require__(41486);
const ASSUME_ROLE_DEFAULT_REGION = "us-east-1";
const decorateDefaultRegion = (region)=>{
    if (typeof region !== "function") {
        return region === undefined ? ASSUME_ROLE_DEFAULT_REGION : region;
    }
    return async ()=>{
        try {
            return await region();
        } catch (e) {
            return ASSUME_ROLE_DEFAULT_REGION;
        }
    };
};
const getDefaultRoleAssumer = (stsOptions, stsClientCtor)=>{
    let stsClient;
    let closureSourceCreds;
    return async (sourceCreds, params)=>{
        closureSourceCreds = sourceCreds;
        if (!stsClient) {
            const { logger, region, requestHandler } = stsOptions;
            stsClient = new stsClientCtor({
                logger,
                credentialDefaultProvider: ()=>async ()=>closureSourceCreds,
                region: decorateDefaultRegion(region || stsOptions.region),
                ...requestHandler ? {
                    requestHandler
                } : {}
            });
        }
        const { Credentials } = await stsClient.send(new AssumeRoleCommand_1.AssumeRoleCommand(params));
        if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
            throw new Error(`Invalid response from STS.assumeRole call with role ${params.RoleArn}`);
        }
        return {
            accessKeyId: Credentials.AccessKeyId,
            secretAccessKey: Credentials.SecretAccessKey,
            sessionToken: Credentials.SessionToken,
            expiration: Credentials.Expiration
        };
    };
};
exports.getDefaultRoleAssumer = getDefaultRoleAssumer;
const getDefaultRoleAssumerWithWebIdentity = (stsOptions, stsClientCtor)=>{
    let stsClient;
    return async (params)=>{
        if (!stsClient) {
            const { logger, region, requestHandler } = stsOptions;
            stsClient = new stsClientCtor({
                logger,
                region: decorateDefaultRegion(region || stsOptions.region),
                ...requestHandler ? {
                    requestHandler
                } : {}
            });
        }
        const { Credentials } = await stsClient.send(new AssumeRoleWithWebIdentityCommand_1.AssumeRoleWithWebIdentityCommand(params));
        if (!Credentials || !Credentials.AccessKeyId || !Credentials.SecretAccessKey) {
            throw new Error(`Invalid response from STS.assumeRoleWithWebIdentity call with role ${params.RoleArn}`);
        }
        return {
            accessKeyId: Credentials.AccessKeyId,
            secretAccessKey: Credentials.SecretAccessKey,
            sessionToken: Credentials.SessionToken,
            expiration: Credentials.Expiration
        };
    };
};
exports.getDefaultRoleAssumerWithWebIdentity = getDefaultRoleAssumerWithWebIdentity;
const decorateDefaultCredentialProvider = (provider)=>(input)=>provider({
            roleAssumer: (0, exports.getDefaultRoleAssumer)(input, input.stsClientCtor),
            roleAssumerWithWebIdentity: (0, exports.getDefaultRoleAssumerWithWebIdentity)(input, input.stsClientCtor),
            ...input
        });
exports.decorateDefaultCredentialProvider = decorateDefaultCredentialProvider;


/***/ }),

/***/ 9976:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveClientEndpointParameters = void 0;
const resolveClientEndpointParameters = (options)=>{
    return {
        ...options,
        useDualstackEndpoint: options.useDualstackEndpoint ?? false,
        useFipsEndpoint: options.useFipsEndpoint ?? false,
        useGlobalEndpoint: options.useGlobalEndpoint ?? false,
        defaultSigningName: "sts"
    };
};
exports.resolveClientEndpointParameters = resolveClientEndpointParameters;


/***/ }),

/***/ 87214:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.defaultEndpointResolver = void 0;
const util_endpoints_1 = __webpack_require__(8059);
const ruleset_1 = __webpack_require__(5690);
const defaultEndpointResolver = (endpointParams, context = {})=>{
    return (0, util_endpoints_1.resolveEndpoint)(ruleset_1.ruleSet, {
        endpointParams: endpointParams,
        logger: context.logger
    });
};
exports.defaultEndpointResolver = defaultEndpointResolver;


/***/ }),

/***/ 5690:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ruleSet = void 0;
const F = "required", G = "type", H = "fn", I = "argv", J = "ref";
const a = false, b = true, c = "booleanEquals", d = "tree", e = "stringEquals", f = "sigv4", g = "sts", h = "us-east-1", i = "endpoint", j = "https://sts.{Region}.{PartitionResult#dnsSuffix}", k = "error", l = "getAttr", m = {
    [F]: false,
    [G]: "String"
}, n = {
    [F]: true,
    "default": false,
    [G]: "Boolean"
}, o = {
    [J]: "Endpoint"
}, p = {
    [H]: "isSet",
    [I]: [
        {
            [J]: "Region"
        }
    ]
}, q = {
    [J]: "Region"
}, r = {
    [H]: "aws.partition",
    [I]: [
        q
    ],
    "assign": "PartitionResult"
}, s = {
    [J]: "UseFIPS"
}, t = {
    [J]: "UseDualStack"
}, u = {
    "url": "https://sts.amazonaws.com",
    "properties": {
        "authSchemes": [
            {
                "name": f,
                "signingName": g,
                "signingRegion": h
            }
        ]
    },
    "headers": {}
}, v = {}, w = {
    "conditions": [
        {
            [H]: e,
            [I]: [
                q,
                "aws-global"
            ]
        }
    ],
    [i]: u,
    [G]: i
}, x = {
    [H]: c,
    [I]: [
        s,
        true
    ]
}, y = {
    [H]: c,
    [I]: [
        t,
        true
    ]
}, z = {
    [H]: c,
    [I]: [
        true,
        {
            [H]: l,
            [I]: [
                {
                    [J]: "PartitionResult"
                },
                "supportsFIPS"
            ]
        }
    ]
}, A = {
    [J]: "PartitionResult"
}, B = {
    [H]: c,
    [I]: [
        true,
        {
            [H]: l,
            [I]: [
                A,
                "supportsDualStack"
            ]
        }
    ]
}, C = [
    {
        [H]: "isSet",
        [I]: [
            o
        ]
    }
], D = [
    x
], E = [
    y
];
const _data = {
    version: "1.0",
    parameters: {
        Region: m,
        UseDualStack: n,
        UseFIPS: n,
        Endpoint: m,
        UseGlobalEndpoint: n
    },
    rules: [
        {
            conditions: [
                {
                    [H]: c,
                    [I]: [
                        {
                            [J]: "UseGlobalEndpoint"
                        },
                        b
                    ]
                },
                {
                    [H]: "not",
                    [I]: C
                },
                p,
                r,
                {
                    [H]: c,
                    [I]: [
                        s,
                        a
                    ]
                },
                {
                    [H]: c,
                    [I]: [
                        t,
                        a
                    ]
                }
            ],
            [G]: d,
            rules: [
                {
                    conditions: [
                        {
                            [H]: e,
                            [I]: [
                                q,
                                "ap-northeast-1"
                            ]
                        }
                    ],
                    endpoint: u,
                    [G]: i
                },
                {
                    conditions: [
                        {
                            [H]: e,
                            [I]: [
                                q,
                                "ap-south-1"
                            ]
                        }
                    ],
                    endpoint: u,
                    [G]: i
                },
                {
                    conditions: [
                        {
                            [H]: e,
                            [I]: [
                                q,
                                "ap-southeast-1"
                            ]
                        }
                    ],
                    endpoint: u,
                    [G]: i
                },
                {
                    conditions: [
                        {
                            [H]: e,
                            [I]: [
                                q,
                                "ap-southeast-2"
                            ]
                        }
                    ],
                    endpoint: u,
                    [G]: i
                },
                w,
                {
                    conditions: [
                        {
                            [H]: e,
                            [I]: [
                                q,
                                "ca-central-1"
                            ]
                        }
                    ],
                    endpoint: u,
                    [G]: i
                },
                {
                    conditions: [
                        {
                            [H]: e,
                            [I]: [
                                q,
                                "eu-central-1"
                            ]
                        }
                    ],
                    endpoint: u,
                    [G]: i
                },
                {
                    conditions: [
                        {
                            [H]: e,
                            [I]: [
                                q,
                                "eu-north-1"
                            ]
                        }
                    ],
                    endpoint: u,
                    [G]: i
                },
                {
                    conditions: [
                        {
                            [H]: e,
                            [I]: [
                                q,
                                "eu-west-1"
                            ]
                        }
                    ],
                    endpoint: u,
                    [G]: i
                },
                {
                    conditions: [
                        {
                            [H]: e,
                            [I]: [
                                q,
                                "eu-west-2"
                            ]
                        }
                    ],
                    endpoint: u,
                    [G]: i
                },
                {
                    conditions: [
                        {
                            [H]: e,
                            [I]: [
                                q,
                                "eu-west-3"
                            ]
                        }
                    ],
                    endpoint: u,
                    [G]: i
                },
                {
                    conditions: [
                        {
                            [H]: e,
                            [I]: [
                                q,
                                "sa-east-1"
                            ]
                        }
                    ],
                    endpoint: u,
                    [G]: i
                },
                {
                    conditions: [
                        {
                            [H]: e,
                            [I]: [
                                q,
                                h
                            ]
                        }
                    ],
                    endpoint: u,
                    [G]: i
                },
                {
                    conditions: [
                        {
                            [H]: e,
                            [I]: [
                                q,
                                "us-east-2"
                            ]
                        }
                    ],
                    endpoint: u,
                    [G]: i
                },
                {
                    conditions: [
                        {
                            [H]: e,
                            [I]: [
                                q,
                                "us-west-1"
                            ]
                        }
                    ],
                    endpoint: u,
                    [G]: i
                },
                {
                    conditions: [
                        {
                            [H]: e,
                            [I]: [
                                q,
                                "us-west-2"
                            ]
                        }
                    ],
                    endpoint: u,
                    [G]: i
                },
                {
                    endpoint: {
                        url: j,
                        properties: {
                            authSchemes: [
                                {
                                    name: f,
                                    signingName: g,
                                    signingRegion: "{Region}"
                                }
                            ]
                        },
                        headers: v
                    },
                    [G]: i
                }
            ]
        },
        {
            conditions: C,
            [G]: d,
            rules: [
                {
                    conditions: D,
                    error: "Invalid Configuration: FIPS and custom endpoint are not supported",
                    [G]: k
                },
                {
                    [G]: d,
                    rules: [
                        {
                            conditions: E,
                            error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
                            [G]: k
                        },
                        {
                            endpoint: {
                                url: o,
                                properties: v,
                                headers: v
                            },
                            [G]: i
                        }
                    ]
                }
            ]
        },
        {
            [G]: d,
            rules: [
                {
                    conditions: [
                        p
                    ],
                    [G]: d,
                    rules: [
                        {
                            conditions: [
                                r
                            ],
                            [G]: d,
                            rules: [
                                {
                                    conditions: [
                                        x,
                                        y
                                    ],
                                    [G]: d,
                                    rules: [
                                        {
                                            conditions: [
                                                z,
                                                B
                                            ],
                                            [G]: d,
                                            rules: [
                                                {
                                                    [G]: d,
                                                    rules: [
                                                        {
                                                            endpoint: {
                                                                url: "https://sts-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                                                                properties: v,
                                                                headers: v
                                                            },
                                                            [G]: i
                                                        }
                                                    ]
                                                }
                                            ]
                                        },
                                        {
                                            error: "FIPS and DualStack are enabled, but this partition does not support one or both",
                                            [G]: k
                                        }
                                    ]
                                },
                                {
                                    conditions: D,
                                    [G]: d,
                                    rules: [
                                        {
                                            conditions: [
                                                z
                                            ],
                                            [G]: d,
                                            rules: [
                                                {
                                                    [G]: d,
                                                    rules: [
                                                        {
                                                            conditions: [
                                                                {
                                                                    [H]: e,
                                                                    [I]: [
                                                                        "aws-us-gov",
                                                                        {
                                                                            [H]: l,
                                                                            [I]: [
                                                                                A,
                                                                                "name"
                                                                            ]
                                                                        }
                                                                    ]
                                                                }
                                                            ],
                                                            endpoint: {
                                                                url: "https://sts.{Region}.amazonaws.com",
                                                                properties: v,
                                                                headers: v
                                                            },
                                                            [G]: i
                                                        },
                                                        {
                                                            endpoint: {
                                                                url: "https://sts-fips.{Region}.{PartitionResult#dnsSuffix}",
                                                                properties: v,
                                                                headers: v
                                                            },
                                                            [G]: i
                                                        }
                                                    ]
                                                }
                                            ]
                                        },
                                        {
                                            error: "FIPS is enabled but this partition does not support FIPS",
                                            [G]: k
                                        }
                                    ]
                                },
                                {
                                    conditions: E,
                                    [G]: d,
                                    rules: [
                                        {
                                            conditions: [
                                                B
                                            ],
                                            [G]: d,
                                            rules: [
                                                {
                                                    [G]: d,
                                                    rules: [
                                                        {
                                                            endpoint: {
                                                                url: "https://sts.{Region}.{PartitionResult#dualStackDnsSuffix}",
                                                                properties: v,
                                                                headers: v
                                                            },
                                                            [G]: i
                                                        }
                                                    ]
                                                }
                                            ]
                                        },
                                        {
                                            error: "DualStack is enabled but this partition does not support DualStack",
                                            [G]: k
                                        }
                                    ]
                                },
                                {
                                    [G]: d,
                                    rules: [
                                        w,
                                        {
                                            endpoint: {
                                                url: j,
                                                properties: v,
                                                headers: v
                                            },
                                            [G]: i
                                        }
                                    ]
                                }
                            ]
                        }
                    ]
                },
                {
                    error: "Invalid Configuration: Missing Region",
                    [G]: k
                }
            ]
        }
    ]
};
exports.ruleSet = _data;


/***/ }),

/***/ 15590:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.STSServiceException = void 0;
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(952), exports);
tslib_1.__exportStar(__webpack_require__(84166), exports);
tslib_1.__exportStar(__webpack_require__(96842), exports);
tslib_1.__exportStar(__webpack_require__(35245), exports);
tslib_1.__exportStar(__webpack_require__(47910), exports);
var STSServiceException_1 = __webpack_require__(69923);
Object.defineProperty(exports, "STSServiceException", ({
    enumerable: true,
    get: function() {
        return STSServiceException_1.STSServiceException;
    }
}));


/***/ }),

/***/ 69923:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.STSServiceException = exports.__ServiceException = void 0;
const smithy_client_1 = __webpack_require__(18851);
Object.defineProperty(exports, "__ServiceException", ({
    enumerable: true,
    get: function() {
        return smithy_client_1.ServiceException;
    }
}));
class STSServiceException extends smithy_client_1.ServiceException {
    constructor(options){
        super(options);
        Object.setPrototypeOf(this, STSServiceException.prototype);
    }
}
exports.STSServiceException = STSServiceException;


/***/ }),

/***/ 35245:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(72159), exports);


/***/ }),

/***/ 72159:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.GetSessionTokenResponseFilterSensitiveLog = exports.GetFederationTokenResponseFilterSensitiveLog = exports.AssumeRoleWithWebIdentityResponseFilterSensitiveLog = exports.AssumeRoleWithWebIdentityRequestFilterSensitiveLog = exports.AssumeRoleWithSAMLResponseFilterSensitiveLog = exports.AssumeRoleWithSAMLRequestFilterSensitiveLog = exports.AssumeRoleResponseFilterSensitiveLog = exports.CredentialsFilterSensitiveLog = exports.InvalidAuthorizationMessageException = exports.IDPCommunicationErrorException = exports.InvalidIdentityTokenException = exports.IDPRejectedClaimException = exports.RegionDisabledException = exports.PackedPolicyTooLargeException = exports.MalformedPolicyDocumentException = exports.ExpiredTokenException = void 0;
const smithy_client_1 = __webpack_require__(18851);
const STSServiceException_1 = __webpack_require__(69923);
class ExpiredTokenException extends STSServiceException_1.STSServiceException {
    constructor(opts){
        super({
            name: "ExpiredTokenException",
            $fault: "client",
            ...opts
        });
        this.name = "ExpiredTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, ExpiredTokenException.prototype);
    }
}
exports.ExpiredTokenException = ExpiredTokenException;
class MalformedPolicyDocumentException extends STSServiceException_1.STSServiceException {
    constructor(opts){
        super({
            name: "MalformedPolicyDocumentException",
            $fault: "client",
            ...opts
        });
        this.name = "MalformedPolicyDocumentException";
        this.$fault = "client";
        Object.setPrototypeOf(this, MalformedPolicyDocumentException.prototype);
    }
}
exports.MalformedPolicyDocumentException = MalformedPolicyDocumentException;
class PackedPolicyTooLargeException extends STSServiceException_1.STSServiceException {
    constructor(opts){
        super({
            name: "PackedPolicyTooLargeException",
            $fault: "client",
            ...opts
        });
        this.name = "PackedPolicyTooLargeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, PackedPolicyTooLargeException.prototype);
    }
}
exports.PackedPolicyTooLargeException = PackedPolicyTooLargeException;
class RegionDisabledException extends STSServiceException_1.STSServiceException {
    constructor(opts){
        super({
            name: "RegionDisabledException",
            $fault: "client",
            ...opts
        });
        this.name = "RegionDisabledException";
        this.$fault = "client";
        Object.setPrototypeOf(this, RegionDisabledException.prototype);
    }
}
exports.RegionDisabledException = RegionDisabledException;
class IDPRejectedClaimException extends STSServiceException_1.STSServiceException {
    constructor(opts){
        super({
            name: "IDPRejectedClaimException",
            $fault: "client",
            ...opts
        });
        this.name = "IDPRejectedClaimException";
        this.$fault = "client";
        Object.setPrototypeOf(this, IDPRejectedClaimException.prototype);
    }
}
exports.IDPRejectedClaimException = IDPRejectedClaimException;
class InvalidIdentityTokenException extends STSServiceException_1.STSServiceException {
    constructor(opts){
        super({
            name: "InvalidIdentityTokenException",
            $fault: "client",
            ...opts
        });
        this.name = "InvalidIdentityTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidIdentityTokenException.prototype);
    }
}
exports.InvalidIdentityTokenException = InvalidIdentityTokenException;
class IDPCommunicationErrorException extends STSServiceException_1.STSServiceException {
    constructor(opts){
        super({
            name: "IDPCommunicationErrorException",
            $fault: "client",
            ...opts
        });
        this.name = "IDPCommunicationErrorException";
        this.$fault = "client";
        Object.setPrototypeOf(this, IDPCommunicationErrorException.prototype);
    }
}
exports.IDPCommunicationErrorException = IDPCommunicationErrorException;
class InvalidAuthorizationMessageException extends STSServiceException_1.STSServiceException {
    constructor(opts){
        super({
            name: "InvalidAuthorizationMessageException",
            $fault: "client",
            ...opts
        });
        this.name = "InvalidAuthorizationMessageException";
        this.$fault = "client";
        Object.setPrototypeOf(this, InvalidAuthorizationMessageException.prototype);
    }
}
exports.InvalidAuthorizationMessageException = InvalidAuthorizationMessageException;
const CredentialsFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.SecretAccessKey && {
            SecretAccessKey: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.CredentialsFilterSensitiveLog = CredentialsFilterSensitiveLog;
const AssumeRoleResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Credentials && {
            Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials)
        }
    });
exports.AssumeRoleResponseFilterSensitiveLog = AssumeRoleResponseFilterSensitiveLog;
const AssumeRoleWithSAMLRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.SAMLAssertion && {
            SAMLAssertion: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AssumeRoleWithSAMLRequestFilterSensitiveLog = AssumeRoleWithSAMLRequestFilterSensitiveLog;
const AssumeRoleWithSAMLResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Credentials && {
            Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials)
        }
    });
exports.AssumeRoleWithSAMLResponseFilterSensitiveLog = AssumeRoleWithSAMLResponseFilterSensitiveLog;
const AssumeRoleWithWebIdentityRequestFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.WebIdentityToken && {
            WebIdentityToken: smithy_client_1.SENSITIVE_STRING
        }
    });
exports.AssumeRoleWithWebIdentityRequestFilterSensitiveLog = AssumeRoleWithWebIdentityRequestFilterSensitiveLog;
const AssumeRoleWithWebIdentityResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Credentials && {
            Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials)
        }
    });
exports.AssumeRoleWithWebIdentityResponseFilterSensitiveLog = AssumeRoleWithWebIdentityResponseFilterSensitiveLog;
const GetFederationTokenResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Credentials && {
            Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials)
        }
    });
exports.GetFederationTokenResponseFilterSensitiveLog = GetFederationTokenResponseFilterSensitiveLog;
const GetSessionTokenResponseFilterSensitiveLog = (obj)=>({
        ...obj,
        ...obj.Credentials && {
            Credentials: (0, exports.CredentialsFilterSensitiveLog)(obj.Credentials)
        }
    });
exports.GetSessionTokenResponseFilterSensitiveLog = GetSessionTokenResponseFilterSensitiveLog;


/***/ }),

/***/ 51641:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.de_GetSessionTokenCommand = exports.de_GetFederationTokenCommand = exports.de_GetCallerIdentityCommand = exports.de_GetAccessKeyInfoCommand = exports.de_DecodeAuthorizationMessageCommand = exports.de_AssumeRoleWithWebIdentityCommand = exports.de_AssumeRoleWithSAMLCommand = exports.de_AssumeRoleCommand = exports.se_GetSessionTokenCommand = exports.se_GetFederationTokenCommand = exports.se_GetCallerIdentityCommand = exports.se_GetAccessKeyInfoCommand = exports.se_DecodeAuthorizationMessageCommand = exports.se_AssumeRoleWithWebIdentityCommand = exports.se_AssumeRoleWithSAMLCommand = exports.se_AssumeRoleCommand = void 0;
const protocol_http_1 = __webpack_require__(64082);
const smithy_client_1 = __webpack_require__(18851);
const fast_xml_parser_1 = __webpack_require__(41246);
const models_0_1 = __webpack_require__(72159);
const STSServiceException_1 = __webpack_require__(69923);
const se_AssumeRoleCommand = async (input, context)=>{
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssumeRoleRequest(input, context),
        Action: "AssumeRole",
        Version: "2011-06-15"
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AssumeRoleCommand = se_AssumeRoleCommand;
const se_AssumeRoleWithSAMLCommand = async (input, context)=>{
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssumeRoleWithSAMLRequest(input, context),
        Action: "AssumeRoleWithSAML",
        Version: "2011-06-15"
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AssumeRoleWithSAMLCommand = se_AssumeRoleWithSAMLCommand;
const se_AssumeRoleWithWebIdentityCommand = async (input, context)=>{
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_AssumeRoleWithWebIdentityRequest(input, context),
        Action: "AssumeRoleWithWebIdentity",
        Version: "2011-06-15"
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_AssumeRoleWithWebIdentityCommand = se_AssumeRoleWithWebIdentityCommand;
const se_DecodeAuthorizationMessageCommand = async (input, context)=>{
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_DecodeAuthorizationMessageRequest(input, context),
        Action: "DecodeAuthorizationMessage",
        Version: "2011-06-15"
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_DecodeAuthorizationMessageCommand = se_DecodeAuthorizationMessageCommand;
const se_GetAccessKeyInfoCommand = async (input, context)=>{
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetAccessKeyInfoRequest(input, context),
        Action: "GetAccessKeyInfo",
        Version: "2011-06-15"
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetAccessKeyInfoCommand = se_GetAccessKeyInfoCommand;
const se_GetCallerIdentityCommand = async (input, context)=>{
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetCallerIdentityRequest(input, context),
        Action: "GetCallerIdentity",
        Version: "2011-06-15"
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetCallerIdentityCommand = se_GetCallerIdentityCommand;
const se_GetFederationTokenCommand = async (input, context)=>{
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetFederationTokenRequest(input, context),
        Action: "GetFederationToken",
        Version: "2011-06-15"
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetFederationTokenCommand = se_GetFederationTokenCommand;
const se_GetSessionTokenCommand = async (input, context)=>{
    const headers = SHARED_HEADERS;
    let body;
    body = buildFormUrlencodedString({
        ...se_GetSessionTokenRequest(input, context),
        Action: "GetSessionToken",
        Version: "2011-06-15"
    });
    return buildHttpRpcRequest(context, headers, "/", undefined, body);
};
exports.se_GetSessionTokenCommand = se_GetSessionTokenCommand;
const de_AssumeRoleCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AssumeRoleCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssumeRoleResponse(data.AssumeRoleResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AssumeRoleCommand = de_AssumeRoleCommand;
const de_AssumeRoleCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
            throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await de_RegionDisabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode
            });
    }
};
const de_AssumeRoleWithSAMLCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AssumeRoleWithSAMLCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssumeRoleWithSAMLResponse(data.AssumeRoleWithSAMLResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AssumeRoleWithSAMLCommand = de_AssumeRoleWithSAMLCommand;
const de_AssumeRoleWithSAMLCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
            throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
            throw await de_IDPRejectedClaimExceptionRes(parsedOutput, context);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
            throw await de_InvalidIdentityTokenExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await de_RegionDisabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode
            });
    }
};
const de_AssumeRoleWithWebIdentityCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_AssumeRoleWithWebIdentityCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_AssumeRoleWithWebIdentityResponse(data.AssumeRoleWithWebIdentityResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_AssumeRoleWithWebIdentityCommand = de_AssumeRoleWithWebIdentityCommand;
const de_AssumeRoleWithWebIdentityCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "ExpiredTokenException":
        case "com.amazonaws.sts#ExpiredTokenException":
            throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
        case "IDPCommunicationError":
        case "com.amazonaws.sts#IDPCommunicationErrorException":
            throw await de_IDPCommunicationErrorExceptionRes(parsedOutput, context);
        case "IDPRejectedClaim":
        case "com.amazonaws.sts#IDPRejectedClaimException":
            throw await de_IDPRejectedClaimExceptionRes(parsedOutput, context);
        case "InvalidIdentityToken":
        case "com.amazonaws.sts#InvalidIdentityTokenException":
            throw await de_InvalidIdentityTokenExceptionRes(parsedOutput, context);
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await de_RegionDisabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode
            });
    }
};
const de_DecodeAuthorizationMessageCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_DecodeAuthorizationMessageCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_DecodeAuthorizationMessageResponse(data.DecodeAuthorizationMessageResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_DecodeAuthorizationMessageCommand = de_DecodeAuthorizationMessageCommand;
const de_DecodeAuthorizationMessageCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InvalidAuthorizationMessageException":
        case "com.amazonaws.sts#InvalidAuthorizationMessageException":
            throw await de_InvalidAuthorizationMessageExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode
            });
    }
};
const de_GetAccessKeyInfoCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_GetAccessKeyInfoCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetAccessKeyInfoResponse(data.GetAccessKeyInfoResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_GetAccessKeyInfoCommand = de_GetAccessKeyInfoCommand;
const de_GetAccessKeyInfoCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode
    });
};
const de_GetCallerIdentityCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_GetCallerIdentityCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetCallerIdentityResponse(data.GetCallerIdentityResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_GetCallerIdentityCommand = de_GetCallerIdentityCommand;
const de_GetCallerIdentityCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    const parsedBody = parsedOutput.body;
    return throwDefaultError({
        output,
        parsedBody: parsedBody.Error,
        errorCode
    });
};
const de_GetFederationTokenCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_GetFederationTokenCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetFederationTokenResponse(data.GetFederationTokenResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_GetFederationTokenCommand = de_GetFederationTokenCommand;
const de_GetFederationTokenCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "MalformedPolicyDocument":
        case "com.amazonaws.sts#MalformedPolicyDocumentException":
            throw await de_MalformedPolicyDocumentExceptionRes(parsedOutput, context);
        case "PackedPolicyTooLarge":
        case "com.amazonaws.sts#PackedPolicyTooLargeException":
            throw await de_PackedPolicyTooLargeExceptionRes(parsedOutput, context);
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await de_RegionDisabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode
            });
    }
};
const de_GetSessionTokenCommand = async (output, context)=>{
    if (output.statusCode >= 300) {
        return de_GetSessionTokenCommandError(output, context);
    }
    const data = await parseBody(output.body, context);
    let contents = {};
    contents = de_GetSessionTokenResponse(data.GetSessionTokenResult, context);
    const response = {
        $metadata: deserializeMetadata(output),
        ...contents
    };
    return response;
};
exports.de_GetSessionTokenCommand = de_GetSessionTokenCommand;
const de_GetSessionTokenCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadQueryErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "RegionDisabledException":
        case "com.amazonaws.sts#RegionDisabledException":
            throw await de_RegionDisabledExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody: parsedBody.Error,
                errorCode
            });
    }
};
const de_ExpiredTokenExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = de_ExpiredTokenException(body.Error, context);
    const exception = new models_0_1.ExpiredTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IDPCommunicationErrorExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = de_IDPCommunicationErrorException(body.Error, context);
    const exception = new models_0_1.IDPCommunicationErrorException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_IDPRejectedClaimExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = de_IDPRejectedClaimException(body.Error, context);
    const exception = new models_0_1.IDPRejectedClaimException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidAuthorizationMessageExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = de_InvalidAuthorizationMessageException(body.Error, context);
    const exception = new models_0_1.InvalidAuthorizationMessageException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_InvalidIdentityTokenExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = de_InvalidIdentityTokenException(body.Error, context);
    const exception = new models_0_1.InvalidIdentityTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_MalformedPolicyDocumentExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = de_MalformedPolicyDocumentException(body.Error, context);
    const exception = new models_0_1.MalformedPolicyDocumentException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_PackedPolicyTooLargeExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = de_PackedPolicyTooLargeException(body.Error, context);
    const exception = new models_0_1.PackedPolicyTooLargeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const de_RegionDisabledExceptionRes = async (parsedOutput, context)=>{
    const body = parsedOutput.body;
    const deserialized = de_RegionDisabledException(body.Error, context);
    const exception = new models_0_1.RegionDisabledException({
        $metadata: deserializeMetadata(parsedOutput),
        ...deserialized
    });
    return (0, smithy_client_1.decorateServiceException)(exception, body);
};
const se_AssumeRoleRequest = (input, context)=>{
    const entries = {};
    if (input.RoleArn != null) {
        entries["RoleArn"] = input.RoleArn;
    }
    if (input.RoleSessionName != null) {
        entries["RoleSessionName"] = input.RoleSessionName;
    }
    if (input.PolicyArns != null) {
        const memberEntries = se_policyDescriptorListType(input.PolicyArns, context);
        if (input.PolicyArns?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value])=>{
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Policy != null) {
        entries["Policy"] = input.Policy;
    }
    if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value])=>{
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    if (input.TransitiveTagKeys != null) {
        const memberEntries = se_tagKeyListType(input.TransitiveTagKeys, context);
        if (input.TransitiveTagKeys?.length === 0) {
            entries.TransitiveTagKeys = [];
        }
        Object.entries(memberEntries).forEach(([key, value])=>{
            const loc = `TransitiveTagKeys.${key}`;
            entries[loc] = value;
        });
    }
    if (input.ExternalId != null) {
        entries["ExternalId"] = input.ExternalId;
    }
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.TokenCode != null) {
        entries["TokenCode"] = input.TokenCode;
    }
    if (input.SourceIdentity != null) {
        entries["SourceIdentity"] = input.SourceIdentity;
    }
    if (input.ProvidedContexts != null) {
        const memberEntries = se_ProvidedContextsListType(input.ProvidedContexts, context);
        if (input.ProvidedContexts?.length === 0) {
            entries.ProvidedContexts = [];
        }
        Object.entries(memberEntries).forEach(([key, value])=>{
            const loc = `ProvidedContexts.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_AssumeRoleWithSAMLRequest = (input, context)=>{
    const entries = {};
    if (input.RoleArn != null) {
        entries["RoleArn"] = input.RoleArn;
    }
    if (input.PrincipalArn != null) {
        entries["PrincipalArn"] = input.PrincipalArn;
    }
    if (input.SAMLAssertion != null) {
        entries["SAMLAssertion"] = input.SAMLAssertion;
    }
    if (input.PolicyArns != null) {
        const memberEntries = se_policyDescriptorListType(input.PolicyArns, context);
        if (input.PolicyArns?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value])=>{
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Policy != null) {
        entries["Policy"] = input.Policy;
    }
    if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
    }
    return entries;
};
const se_AssumeRoleWithWebIdentityRequest = (input, context)=>{
    const entries = {};
    if (input.RoleArn != null) {
        entries["RoleArn"] = input.RoleArn;
    }
    if (input.RoleSessionName != null) {
        entries["RoleSessionName"] = input.RoleSessionName;
    }
    if (input.WebIdentityToken != null) {
        entries["WebIdentityToken"] = input.WebIdentityToken;
    }
    if (input.ProviderId != null) {
        entries["ProviderId"] = input.ProviderId;
    }
    if (input.PolicyArns != null) {
        const memberEntries = se_policyDescriptorListType(input.PolicyArns, context);
        if (input.PolicyArns?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value])=>{
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.Policy != null) {
        entries["Policy"] = input.Policy;
    }
    if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
    }
    return entries;
};
const se_DecodeAuthorizationMessageRequest = (input, context)=>{
    const entries = {};
    if (input.EncodedMessage != null) {
        entries["EncodedMessage"] = input.EncodedMessage;
    }
    return entries;
};
const se_GetAccessKeyInfoRequest = (input, context)=>{
    const entries = {};
    if (input.AccessKeyId != null) {
        entries["AccessKeyId"] = input.AccessKeyId;
    }
    return entries;
};
const se_GetCallerIdentityRequest = (input, context)=>{
    const entries = {};
    return entries;
};
const se_GetFederationTokenRequest = (input, context)=>{
    const entries = {};
    if (input.Name != null) {
        entries["Name"] = input.Name;
    }
    if (input.Policy != null) {
        entries["Policy"] = input.Policy;
    }
    if (input.PolicyArns != null) {
        const memberEntries = se_policyDescriptorListType(input.PolicyArns, context);
        if (input.PolicyArns?.length === 0) {
            entries.PolicyArns = [];
        }
        Object.entries(memberEntries).forEach(([key, value])=>{
            const loc = `PolicyArns.${key}`;
            entries[loc] = value;
        });
    }
    if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
    }
    if (input.Tags != null) {
        const memberEntries = se_tagListType(input.Tags, context);
        if (input.Tags?.length === 0) {
            entries.Tags = [];
        }
        Object.entries(memberEntries).forEach(([key, value])=>{
            const loc = `Tags.${key}`;
            entries[loc] = value;
        });
    }
    return entries;
};
const se_GetSessionTokenRequest = (input, context)=>{
    const entries = {};
    if (input.DurationSeconds != null) {
        entries["DurationSeconds"] = input.DurationSeconds;
    }
    if (input.SerialNumber != null) {
        entries["SerialNumber"] = input.SerialNumber;
    }
    if (input.TokenCode != null) {
        entries["TokenCode"] = input.TokenCode;
    }
    return entries;
};
const se_policyDescriptorListType = (input, context)=>{
    const entries = {};
    let counter = 1;
    for (const entry of input){
        if (entry === null) {
            continue;
        }
        const memberEntries = se_PolicyDescriptorType(entry, context);
        Object.entries(memberEntries).forEach(([key, value])=>{
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_PolicyDescriptorType = (input, context)=>{
    const entries = {};
    if (input.arn != null) {
        entries["arn"] = input.arn;
    }
    return entries;
};
const se_ProvidedContext = (input, context)=>{
    const entries = {};
    if (input.ProviderArn != null) {
        entries["ProviderArn"] = input.ProviderArn;
    }
    if (input.ContextAssertion != null) {
        entries["ContextAssertion"] = input.ContextAssertion;
    }
    return entries;
};
const se_ProvidedContextsListType = (input, context)=>{
    const entries = {};
    let counter = 1;
    for (const entry of input){
        if (entry === null) {
            continue;
        }
        const memberEntries = se_ProvidedContext(entry, context);
        Object.entries(memberEntries).forEach(([key, value])=>{
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const se_Tag = (input, context)=>{
    const entries = {};
    if (input.Key != null) {
        entries["Key"] = input.Key;
    }
    if (input.Value != null) {
        entries["Value"] = input.Value;
    }
    return entries;
};
const se_tagKeyListType = (input, context)=>{
    const entries = {};
    let counter = 1;
    for (const entry of input){
        if (entry === null) {
            continue;
        }
        entries[`member.${counter}`] = entry;
        counter++;
    }
    return entries;
};
const se_tagListType = (input, context)=>{
    const entries = {};
    let counter = 1;
    for (const entry of input){
        if (entry === null) {
            continue;
        }
        const memberEntries = se_Tag(entry, context);
        Object.entries(memberEntries).forEach(([key, value])=>{
            entries[`member.${counter}.${key}`] = value;
        });
        counter++;
    }
    return entries;
};
const de_AssumedRoleUser = (output, context)=>{
    const contents = {};
    if (output["AssumedRoleId"] !== undefined) {
        contents.AssumedRoleId = (0, smithy_client_1.expectString)(output["AssumedRoleId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    return contents;
};
const de_AssumeRoleResponse = (output, context)=>{
    const contents = {};
    if (output["Credentials"] !== undefined) {
        contents.Credentials = de_Credentials(output["Credentials"], context);
    }
    if (output["AssumedRoleUser"] !== undefined) {
        contents.AssumedRoleUser = de_AssumedRoleUser(output["AssumedRoleUser"], context);
    }
    if (output["PackedPolicySize"] !== undefined) {
        contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
    }
    if (output["SourceIdentity"] !== undefined) {
        contents.SourceIdentity = (0, smithy_client_1.expectString)(output["SourceIdentity"]);
    }
    return contents;
};
const de_AssumeRoleWithSAMLResponse = (output, context)=>{
    const contents = {};
    if (output["Credentials"] !== undefined) {
        contents.Credentials = de_Credentials(output["Credentials"], context);
    }
    if (output["AssumedRoleUser"] !== undefined) {
        contents.AssumedRoleUser = de_AssumedRoleUser(output["AssumedRoleUser"], context);
    }
    if (output["PackedPolicySize"] !== undefined) {
        contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
    }
    if (output["Subject"] !== undefined) {
        contents.Subject = (0, smithy_client_1.expectString)(output["Subject"]);
    }
    if (output["SubjectType"] !== undefined) {
        contents.SubjectType = (0, smithy_client_1.expectString)(output["SubjectType"]);
    }
    if (output["Issuer"] !== undefined) {
        contents.Issuer = (0, smithy_client_1.expectString)(output["Issuer"]);
    }
    if (output["Audience"] !== undefined) {
        contents.Audience = (0, smithy_client_1.expectString)(output["Audience"]);
    }
    if (output["NameQualifier"] !== undefined) {
        contents.NameQualifier = (0, smithy_client_1.expectString)(output["NameQualifier"]);
    }
    if (output["SourceIdentity"] !== undefined) {
        contents.SourceIdentity = (0, smithy_client_1.expectString)(output["SourceIdentity"]);
    }
    return contents;
};
const de_AssumeRoleWithWebIdentityResponse = (output, context)=>{
    const contents = {};
    if (output["Credentials"] !== undefined) {
        contents.Credentials = de_Credentials(output["Credentials"], context);
    }
    if (output["SubjectFromWebIdentityToken"] !== undefined) {
        contents.SubjectFromWebIdentityToken = (0, smithy_client_1.expectString)(output["SubjectFromWebIdentityToken"]);
    }
    if (output["AssumedRoleUser"] !== undefined) {
        contents.AssumedRoleUser = de_AssumedRoleUser(output["AssumedRoleUser"], context);
    }
    if (output["PackedPolicySize"] !== undefined) {
        contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
    }
    if (output["Provider"] !== undefined) {
        contents.Provider = (0, smithy_client_1.expectString)(output["Provider"]);
    }
    if (output["Audience"] !== undefined) {
        contents.Audience = (0, smithy_client_1.expectString)(output["Audience"]);
    }
    if (output["SourceIdentity"] !== undefined) {
        contents.SourceIdentity = (0, smithy_client_1.expectString)(output["SourceIdentity"]);
    }
    return contents;
};
const de_Credentials = (output, context)=>{
    const contents = {};
    if (output["AccessKeyId"] !== undefined) {
        contents.AccessKeyId = (0, smithy_client_1.expectString)(output["AccessKeyId"]);
    }
    if (output["SecretAccessKey"] !== undefined) {
        contents.SecretAccessKey = (0, smithy_client_1.expectString)(output["SecretAccessKey"]);
    }
    if (output["SessionToken"] !== undefined) {
        contents.SessionToken = (0, smithy_client_1.expectString)(output["SessionToken"]);
    }
    if (output["Expiration"] !== undefined) {
        contents.Expiration = (0, smithy_client_1.expectNonNull)((0, smithy_client_1.parseRfc3339DateTimeWithOffset)(output["Expiration"]));
    }
    return contents;
};
const de_DecodeAuthorizationMessageResponse = (output, context)=>{
    const contents = {};
    if (output["DecodedMessage"] !== undefined) {
        contents.DecodedMessage = (0, smithy_client_1.expectString)(output["DecodedMessage"]);
    }
    return contents;
};
const de_ExpiredTokenException = (output, context)=>{
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_FederatedUser = (output, context)=>{
    const contents = {};
    if (output["FederatedUserId"] !== undefined) {
        contents.FederatedUserId = (0, smithy_client_1.expectString)(output["FederatedUserId"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    return contents;
};
const de_GetAccessKeyInfoResponse = (output, context)=>{
    const contents = {};
    if (output["Account"] !== undefined) {
        contents.Account = (0, smithy_client_1.expectString)(output["Account"]);
    }
    return contents;
};
const de_GetCallerIdentityResponse = (output, context)=>{
    const contents = {};
    if (output["UserId"] !== undefined) {
        contents.UserId = (0, smithy_client_1.expectString)(output["UserId"]);
    }
    if (output["Account"] !== undefined) {
        contents.Account = (0, smithy_client_1.expectString)(output["Account"]);
    }
    if (output["Arn"] !== undefined) {
        contents.Arn = (0, smithy_client_1.expectString)(output["Arn"]);
    }
    return contents;
};
const de_GetFederationTokenResponse = (output, context)=>{
    const contents = {};
    if (output["Credentials"] !== undefined) {
        contents.Credentials = de_Credentials(output["Credentials"], context);
    }
    if (output["FederatedUser"] !== undefined) {
        contents.FederatedUser = de_FederatedUser(output["FederatedUser"], context);
    }
    if (output["PackedPolicySize"] !== undefined) {
        contents.PackedPolicySize = (0, smithy_client_1.strictParseInt32)(output["PackedPolicySize"]);
    }
    return contents;
};
const de_GetSessionTokenResponse = (output, context)=>{
    const contents = {};
    if (output["Credentials"] !== undefined) {
        contents.Credentials = de_Credentials(output["Credentials"], context);
    }
    return contents;
};
const de_IDPCommunicationErrorException = (output, context)=>{
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_IDPRejectedClaimException = (output, context)=>{
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_InvalidAuthorizationMessageException = (output, context)=>{
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_InvalidIdentityTokenException = (output, context)=>{
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_MalformedPolicyDocumentException = (output, context)=>{
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_PackedPolicyTooLargeException = (output, context)=>{
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const de_RegionDisabledException = (output, context)=>{
    const contents = {};
    if (output["message"] !== undefined) {
        contents.message = (0, smithy_client_1.expectString)(output["message"]);
    }
    return contents;
};
const deserializeMetadata = (output)=>({
        httpStatusCode: output.statusCode,
        requestId: output.headers["x-amzn-requestid"] ?? output.headers["x-amzn-request-id"] ?? output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"]
    });
const collectBodyString = (streamBody, context)=>(0, smithy_client_1.collectBody)(streamBody, context).then((body)=>context.utf8Encoder(body));
const throwDefaultError = (0, smithy_client_1.withBaseException)(STSServiceException_1.STSServiceException);
const buildHttpRpcRequest = async (context, headers, path, resolvedHostname, body)=>{
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const contents = {
        protocol,
        hostname,
        port,
        method: "POST",
        path: basePath.endsWith("/") ? basePath.slice(0, -1) + path : basePath + path,
        headers
    };
    if (resolvedHostname !== undefined) {
        contents.hostname = resolvedHostname;
    }
    if (body !== undefined) {
        contents.body = body;
    }
    return new protocol_http_1.HttpRequest(contents);
};
const SHARED_HEADERS = {
    "content-type": "application/x-www-form-urlencoded"
};
const parseBody = (streamBody, context)=>collectBodyString(streamBody, context).then((encoded)=>{
        if (encoded.length) {
            const parser = new fast_xml_parser_1.XMLParser({
                attributeNamePrefix: "",
                htmlEntities: true,
                ignoreAttributes: false,
                ignoreDeclaration: true,
                parseTagValue: false,
                trimValues: false,
                tagValueProcessor: (_, val)=>val.trim() === "" && val.includes("\n") ? "" : undefined
            });
            parser.addEntity("#xD", "\r");
            parser.addEntity("#10", "\n");
            const parsedObj = parser.parse(encoded);
            const textNodeName = "#text";
            const key = Object.keys(parsedObj)[0];
            const parsedObjToReturn = parsedObj[key];
            if (parsedObjToReturn[textNodeName]) {
                parsedObjToReturn[key] = parsedObjToReturn[textNodeName];
                delete parsedObjToReturn[textNodeName];
            }
            return (0, smithy_client_1.getValueFromTextNode)(parsedObjToReturn);
        }
        return {};
    });
const parseErrorBody = async (errorBody, context)=>{
    const value = await parseBody(errorBody, context);
    if (value.Error) {
        value.Error.message = value.Error.message ?? value.Error.Message;
    }
    return value;
};
const buildFormUrlencodedString = (formEntries)=>Object.entries(formEntries).map(([key, value])=>(0, smithy_client_1.extendedEncodeURIComponent)(key) + "=" + (0, smithy_client_1.extendedEncodeURIComponent)(value)).join("&");
const loadQueryErrorCode = (output, data)=>{
    if (data.Error?.Code !== undefined) {
        return data.Error.Code;
    }
    if (output.statusCode == 404) {
        return "NotFound";
    }
};


/***/ }),

/***/ 75496:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getRuntimeConfig = void 0;
const tslib_1 = __webpack_require__(35092);
const package_json_1 = tslib_1.__importDefault(__webpack_require__(41657));
const defaultStsRoleAssumers_1 = __webpack_require__(62688);
const credential_provider_node_1 = __webpack_require__(55116);
const util_user_agent_node_1 = __webpack_require__(62850);
const config_resolver_1 = __webpack_require__(25708);
const hash_node_1 = __webpack_require__(44341);
const middleware_retry_1 = __webpack_require__(75567);
const node_config_provider_1 = __webpack_require__(15829);
const node_http_handler_1 = __webpack_require__(44025);
const util_body_length_node_1 = __webpack_require__(2414);
const util_retry_1 = __webpack_require__(7885);
const runtimeConfig_shared_1 = __webpack_require__(30921);
const smithy_client_1 = __webpack_require__(18851);
const util_defaults_mode_node_1 = __webpack_require__(87393);
const smithy_client_2 = __webpack_require__(18851);
const getRuntimeConfig = (config)=>{
    (0, smithy_client_2.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = ()=>defaultsMode().then(smithy_client_1.loadConfigsForDefaultMode);
    const clientSharedValues = (0, runtimeConfig_shared_1.getRuntimeConfig)(config);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: config?.bodyLengthChecker ?? util_body_length_node_1.calculateBodyLength,
        credentialDefaultProvider: config?.credentialDefaultProvider ?? (0, defaultStsRoleAssumers_1.decorateDefaultCredentialProvider)(credential_provider_node_1.defaultProvider),
        defaultUserAgentProvider: config?.defaultUserAgentProvider ?? (0, util_user_agent_node_1.defaultUserAgent)({
            serviceId: clientSharedValues.serviceId,
            clientVersion: package_json_1.default.version
        }),
        maxAttempts: config?.maxAttempts ?? (0, node_config_provider_1.loadConfig)(middleware_retry_1.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: config?.region ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS, config_resolver_1.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: config?.requestHandler ?? new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: config?.retryMode ?? (0, node_config_provider_1.loadConfig)({
            ...middleware_retry_1.NODE_RETRY_MODE_CONFIG_OPTIONS,
            default: async ()=>(await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
        }),
        sha256: config?.sha256 ?? hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: config?.streamCollector ?? node_http_handler_1.streamCollector,
        useDualstackEndpoint: config?.useDualstackEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: config?.useFipsEndpoint ?? (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
    };
};
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 30921:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getRuntimeConfig = void 0;
const smithy_client_1 = __webpack_require__(18851);
const url_parser_1 = __webpack_require__(45110);
const util_base64_1 = __webpack_require__(53013);
const util_utf8_1 = __webpack_require__(66120);
const endpointResolver_1 = __webpack_require__(87214);
const getRuntimeConfig = (config)=>({
        apiVersion: "2011-06-15",
        base64Decoder: config?.base64Decoder ?? util_base64_1.fromBase64,
        base64Encoder: config?.base64Encoder ?? util_base64_1.toBase64,
        disableHostPrefix: config?.disableHostPrefix ?? false,
        endpointProvider: config?.endpointProvider ?? endpointResolver_1.defaultEndpointResolver,
        extensions: config?.extensions ?? [],
        logger: config?.logger ?? new smithy_client_1.NoOpLogger(),
        serviceId: config?.serviceId ?? "STS",
        urlParser: config?.urlParser ?? url_parser_1.parseUrl,
        utf8Decoder: config?.utf8Decoder ?? util_utf8_1.fromUtf8,
        utf8Encoder: config?.utf8Encoder ?? util_utf8_1.toUtf8
    });
exports.getRuntimeConfig = getRuntimeConfig;


/***/ }),

/***/ 47371:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveRuntimeExtensions = void 0;
const smithy_client_1 = __webpack_require__(18851);
const asPartial = (t)=>t;
const resolveRuntimeExtensions = (runtimeConfig, extensions)=>{
    const extensionConfiguration = {
        ...asPartial((0, smithy_client_1.getDefaultExtensionConfiguration)(runtimeConfig))
    };
    extensions.forEach((extension)=>extension.configure(extensionConfiguration));
    return {
        ...runtimeConfig,
        ...(0, smithy_client_1.resolveDefaultRuntimeConfig)(extensionConfiguration)
    };
};
exports.resolveRuntimeExtensions = resolveRuntimeExtensions;


/***/ }),

/***/ 43270:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromEnv = exports.ENV_EXPIRATION = exports.ENV_SESSION = exports.ENV_SECRET = exports.ENV_KEY = void 0;
const property_provider_1 = __webpack_require__(29852);
exports.ENV_KEY = "AWS_ACCESS_KEY_ID";
exports.ENV_SECRET = "AWS_SECRET_ACCESS_KEY";
exports.ENV_SESSION = "AWS_SESSION_TOKEN";
exports.ENV_EXPIRATION = "AWS_CREDENTIAL_EXPIRATION";
const fromEnv = ()=>async ()=>{
        const accessKeyId = process.env[exports.ENV_KEY];
        const secretAccessKey = process.env[exports.ENV_SECRET];
        const sessionToken = process.env[exports.ENV_SESSION];
        const expiry = process.env[exports.ENV_EXPIRATION];
        if (accessKeyId && secretAccessKey) {
            return {
                accessKeyId,
                secretAccessKey,
                ...sessionToken && {
                    sessionToken
                },
                ...expiry && {
                    expiration: new Date(expiry)
                }
            };
        }
        throw new property_provider_1.CredentialsProviderError("Unable to find environment variable credentials.");
    };
exports.fromEnv = fromEnv;


/***/ }),

/***/ 72712:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(43270), exports);


/***/ }),

/***/ 18027:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromIni = void 0;
const shared_ini_file_loader_1 = __webpack_require__(3666);
const resolveProfileData_1 = __webpack_require__(67286);
const fromIni = (init = {})=>async ()=>{
        const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
        return (0, resolveProfileData_1.resolveProfileData)((0, shared_ini_file_loader_1.getProfileName)(init), profiles, init);
    };
exports.fromIni = fromIni;


/***/ }),

/***/ 33060:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(18027), exports);


/***/ }),

/***/ 62789:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveAssumeRoleCredentials = exports.isAssumeRoleProfile = void 0;
const property_provider_1 = __webpack_require__(29852);
const shared_ini_file_loader_1 = __webpack_require__(3666);
const resolveCredentialSource_1 = __webpack_require__(90333);
const resolveProfileData_1 = __webpack_require__(67286);
const isAssumeRoleProfile = (arg)=>Boolean(arg) && typeof arg === "object" && typeof arg.role_arn === "string" && [
        "undefined",
        "string"
    ].indexOf(typeof arg.role_session_name) > -1 && [
        "undefined",
        "string"
    ].indexOf(typeof arg.external_id) > -1 && [
        "undefined",
        "string"
    ].indexOf(typeof arg.mfa_serial) > -1 && (isAssumeRoleWithSourceProfile(arg) || isAssumeRoleWithProviderProfile(arg));
exports.isAssumeRoleProfile = isAssumeRoleProfile;
const isAssumeRoleWithSourceProfile = (arg)=>typeof arg.source_profile === "string" && typeof arg.credential_source === "undefined";
const isAssumeRoleWithProviderProfile = (arg)=>typeof arg.credential_source === "string" && typeof arg.source_profile === "undefined";
const resolveAssumeRoleCredentials = async (profileName, profiles, options, visitedProfiles = {})=>{
    const data = profiles[profileName];
    if (!options.roleAssumer) {
        throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} requires a role to be assumed, but no role assumption callback was provided.`, false);
    }
    const { source_profile } = data;
    if (source_profile && source_profile in visitedProfiles) {
        throw new property_provider_1.CredentialsProviderError(`Detected a cycle attempting to resolve credentials for profile` + ` ${(0, shared_ini_file_loader_1.getProfileName)(options)}. Profiles visited: ` + Object.keys(visitedProfiles).join(", "), false);
    }
    const sourceCredsProvider = source_profile ? (0, resolveProfileData_1.resolveProfileData)(source_profile, profiles, options, {
        ...visitedProfiles,
        [source_profile]: true
    }) : (0, resolveCredentialSource_1.resolveCredentialSource)(data.credential_source, profileName)();
    const params = {
        RoleArn: data.role_arn,
        RoleSessionName: data.role_session_name || `aws-sdk-js-${Date.now()}`,
        ExternalId: data.external_id
    };
    const { mfa_serial } = data;
    if (mfa_serial) {
        if (!options.mfaCodeProvider) {
            throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} requires multi-factor authentication, but no MFA code callback was provided.`, false);
        }
        params.SerialNumber = mfa_serial;
        params.TokenCode = await options.mfaCodeProvider(mfa_serial);
    }
    const sourceCreds = await sourceCredsProvider;
    return options.roleAssumer(sourceCreds, params);
};
exports.resolveAssumeRoleCredentials = resolveAssumeRoleCredentials;


/***/ }),

/***/ 90333:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveCredentialSource = void 0;
const credential_provider_env_1 = __webpack_require__(72712);
const credential_provider_imds_1 = __webpack_require__(72214);
const property_provider_1 = __webpack_require__(29852);
const resolveCredentialSource = (credentialSource, profileName)=>{
    const sourceProvidersMap = {
        EcsContainer: credential_provider_imds_1.fromContainerMetadata,
        Ec2InstanceMetadata: credential_provider_imds_1.fromInstanceMetadata,
        Environment: credential_provider_env_1.fromEnv
    };
    if (credentialSource in sourceProvidersMap) {
        return sourceProvidersMap[credentialSource]();
    } else {
        throw new property_provider_1.CredentialsProviderError(`Unsupported credential source in profile ${profileName}. Got ${credentialSource}, ` + `expected EcsContainer or Ec2InstanceMetadata or Environment.`);
    }
};
exports.resolveCredentialSource = resolveCredentialSource;


/***/ }),

/***/ 73889:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveProcessCredentials = exports.isProcessProfile = void 0;
const credential_provider_process_1 = __webpack_require__(91640);
const isProcessProfile = (arg)=>Boolean(arg) && typeof arg === "object" && typeof arg.credential_process === "string";
exports.isProcessProfile = isProcessProfile;
const resolveProcessCredentials = async (options, profile)=>(0, credential_provider_process_1.fromProcess)({
        ...options,
        profile
    })();
exports.resolveProcessCredentials = resolveProcessCredentials;


/***/ }),

/***/ 67286:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveProfileData = void 0;
const property_provider_1 = __webpack_require__(29852);
const resolveAssumeRoleCredentials_1 = __webpack_require__(62789);
const resolveProcessCredentials_1 = __webpack_require__(73889);
const resolveSsoCredentials_1 = __webpack_require__(26090);
const resolveStaticCredentials_1 = __webpack_require__(38780);
const resolveWebIdentityCredentials_1 = __webpack_require__(4495);
const resolveProfileData = async (profileName, profiles, options, visitedProfiles = {})=>{
    const data = profiles[profileName];
    if (Object.keys(visitedProfiles).length > 0 && (0, resolveStaticCredentials_1.isStaticCredsProfile)(data)) {
        return (0, resolveStaticCredentials_1.resolveStaticCredentials)(data);
    }
    if ((0, resolveAssumeRoleCredentials_1.isAssumeRoleProfile)(data)) {
        return (0, resolveAssumeRoleCredentials_1.resolveAssumeRoleCredentials)(profileName, profiles, options, visitedProfiles);
    }
    if ((0, resolveStaticCredentials_1.isStaticCredsProfile)(data)) {
        return (0, resolveStaticCredentials_1.resolveStaticCredentials)(data);
    }
    if ((0, resolveWebIdentityCredentials_1.isWebIdentityProfile)(data)) {
        return (0, resolveWebIdentityCredentials_1.resolveWebIdentityCredentials)(data, options);
    }
    if ((0, resolveProcessCredentials_1.isProcessProfile)(data)) {
        return (0, resolveProcessCredentials_1.resolveProcessCredentials)(options, profileName);
    }
    if ((0, resolveSsoCredentials_1.isSsoProfile)(data)) {
        return (0, resolveSsoCredentials_1.resolveSsoCredentials)(data);
    }
    throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} could not be found or parsed in shared credentials file.`);
};
exports.resolveProfileData = resolveProfileData;


/***/ }),

/***/ 26090:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveSsoCredentials = exports.isSsoProfile = void 0;
const credential_provider_sso_1 = __webpack_require__(68312);
var credential_provider_sso_2 = __webpack_require__(68312);
Object.defineProperty(exports, "isSsoProfile", ({
    enumerable: true,
    get: function() {
        return credential_provider_sso_2.isSsoProfile;
    }
}));
const resolveSsoCredentials = (data)=>{
    const { sso_start_url, sso_account_id, sso_session, sso_region, sso_role_name } = (0, credential_provider_sso_1.validateSsoProfile)(data);
    return (0, credential_provider_sso_1.fromSSO)({
        ssoStartUrl: sso_start_url,
        ssoAccountId: sso_account_id,
        ssoSession: sso_session,
        ssoRegion: sso_region,
        ssoRoleName: sso_role_name
    })();
};
exports.resolveSsoCredentials = resolveSsoCredentials;


/***/ }),

/***/ 38780:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveStaticCredentials = exports.isStaticCredsProfile = void 0;
const isStaticCredsProfile = (arg)=>Boolean(arg) && typeof arg === "object" && typeof arg.aws_access_key_id === "string" && typeof arg.aws_secret_access_key === "string" && [
        "undefined",
        "string"
    ].indexOf(typeof arg.aws_session_token) > -1;
exports.isStaticCredsProfile = isStaticCredsProfile;
const resolveStaticCredentials = (profile)=>Promise.resolve({
        accessKeyId: profile.aws_access_key_id,
        secretAccessKey: profile.aws_secret_access_key,
        sessionToken: profile.aws_session_token
    });
exports.resolveStaticCredentials = resolveStaticCredentials;


/***/ }),

/***/ 4495:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveWebIdentityCredentials = exports.isWebIdentityProfile = void 0;
const credential_provider_web_identity_1 = __webpack_require__(55835);
const isWebIdentityProfile = (arg)=>Boolean(arg) && typeof arg === "object" && typeof arg.web_identity_token_file === "string" && typeof arg.role_arn === "string" && [
        "undefined",
        "string"
    ].indexOf(typeof arg.role_session_name) > -1;
exports.isWebIdentityProfile = isWebIdentityProfile;
const resolveWebIdentityCredentials = async (profile, options)=>(0, credential_provider_web_identity_1.fromTokenFile)({
        webIdentityTokenFile: profile.web_identity_token_file,
        roleArn: profile.role_arn,
        roleSessionName: profile.role_session_name,
        roleAssumerWithWebIdentity: options.roleAssumerWithWebIdentity
    })();
exports.resolveWebIdentityCredentials = resolveWebIdentityCredentials;


/***/ }),

/***/ 1678:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.defaultProvider = void 0;
const credential_provider_env_1 = __webpack_require__(72712);
const credential_provider_ini_1 = __webpack_require__(33060);
const credential_provider_process_1 = __webpack_require__(91640);
const credential_provider_sso_1 = __webpack_require__(68312);
const credential_provider_web_identity_1 = __webpack_require__(55835);
const property_provider_1 = __webpack_require__(29852);
const shared_ini_file_loader_1 = __webpack_require__(3666);
const remoteProvider_1 = __webpack_require__(40114);
const defaultProvider = (init = {})=>(0, property_provider_1.memoize)((0, property_provider_1.chain)(...init.profile || process.env[shared_ini_file_loader_1.ENV_PROFILE] ? [] : [
        (0, credential_provider_env_1.fromEnv)()
    ], (0, credential_provider_sso_1.fromSSO)(init), (0, credential_provider_ini_1.fromIni)(init), (0, credential_provider_process_1.fromProcess)(init), (0, credential_provider_web_identity_1.fromTokenFile)(init), (0, remoteProvider_1.remoteProvider)(init), async ()=>{
        throw new property_provider_1.CredentialsProviderError("Could not load credentials from any providers", false);
    }), (credentials)=>credentials.expiration !== undefined && credentials.expiration.getTime() - Date.now() < 300000, (credentials)=>credentials.expiration !== undefined);
exports.defaultProvider = defaultProvider;


/***/ }),

/***/ 55116:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(1678), exports);


/***/ }),

/***/ 40114:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.remoteProvider = exports.ENV_IMDS_DISABLED = void 0;
const credential_provider_imds_1 = __webpack_require__(72214);
const property_provider_1 = __webpack_require__(29852);
exports.ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
const remoteProvider = (init)=>{
    if (process.env[credential_provider_imds_1.ENV_CMDS_RELATIVE_URI] || process.env[credential_provider_imds_1.ENV_CMDS_FULL_URI]) {
        return (0, credential_provider_imds_1.fromContainerMetadata)(init);
    }
    if (process.env[exports.ENV_IMDS_DISABLED]) {
        return async ()=>{
            throw new property_provider_1.CredentialsProviderError("EC2 Instance Metadata Service access disabled");
        };
    }
    return (0, credential_provider_imds_1.fromInstanceMetadata)(init);
};
exports.remoteProvider = remoteProvider;


/***/ }),

/***/ 76026:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromProcess = void 0;
const shared_ini_file_loader_1 = __webpack_require__(3666);
const resolveProcessCredentials_1 = __webpack_require__(87890);
const fromProcess = (init = {})=>async ()=>{
        const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
        return (0, resolveProcessCredentials_1.resolveProcessCredentials)((0, shared_ini_file_loader_1.getProfileName)(init), profiles);
    };
exports.fromProcess = fromProcess;


/***/ }),

/***/ 14931:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getValidatedProcessCredentials = void 0;
const getValidatedProcessCredentials = (profileName, data)=>{
    if (data.Version !== 1) {
        throw Error(`Profile ${profileName} credential_process did not return Version 1.`);
    }
    if (data.AccessKeyId === undefined || data.SecretAccessKey === undefined) {
        throw Error(`Profile ${profileName} credential_process returned invalid credentials.`);
    }
    if (data.Expiration) {
        const currentTime = new Date();
        const expireTime = new Date(data.Expiration);
        if (expireTime < currentTime) {
            throw Error(`Profile ${profileName} credential_process returned expired credentials.`);
        }
    }
    return {
        accessKeyId: data.AccessKeyId,
        secretAccessKey: data.SecretAccessKey,
        ...data.SessionToken && {
            sessionToken: data.SessionToken
        },
        ...data.Expiration && {
            expiration: new Date(data.Expiration)
        }
    };
};
exports.getValidatedProcessCredentials = getValidatedProcessCredentials;


/***/ }),

/***/ 91640:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(76026), exports);


/***/ }),

/***/ 87890:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveProcessCredentials = void 0;
const property_provider_1 = __webpack_require__(29852);
const child_process_1 = __webpack_require__(32081);
const util_1 = __webpack_require__(73837);
const getValidatedProcessCredentials_1 = __webpack_require__(14931);
const resolveProcessCredentials = async (profileName, profiles)=>{
    const profile = profiles[profileName];
    if (profiles[profileName]) {
        const credentialProcess = profile["credential_process"];
        if (credentialProcess !== undefined) {
            const execPromise = (0, util_1.promisify)(child_process_1.exec);
            try {
                const { stdout } = await execPromise(credentialProcess);
                let data;
                try {
                    data = JSON.parse(stdout.trim());
                } catch (_a) {
                    throw Error(`Profile ${profileName} credential_process returned invalid JSON.`);
                }
                return (0, getValidatedProcessCredentials_1.getValidatedProcessCredentials)(profileName, data);
            } catch (error) {
                throw new property_provider_1.CredentialsProviderError(error.message);
            }
        } else {
            throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} did not contain credential_process.`);
        }
    } else {
        throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} could not be found in shared credentials file.`);
    }
};
exports.resolveProcessCredentials = resolveProcessCredentials;


/***/ }),

/***/ 66422:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromSSO = void 0;
const property_provider_1 = __webpack_require__(29852);
const shared_ini_file_loader_1 = __webpack_require__(3666);
const isSsoProfile_1 = __webpack_require__(73187);
const resolveSSOCredentials_1 = __webpack_require__(78418);
const validateSsoProfile_1 = __webpack_require__(38990);
const fromSSO = (init = {})=>async ()=>{
        const { ssoStartUrl, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, ssoSession } = init;
        const profileName = (0, shared_ini_file_loader_1.getProfileName)(init);
        if (!ssoStartUrl && !ssoAccountId && !ssoRegion && !ssoRoleName && !ssoSession) {
            const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
            const profile = profiles[profileName];
            if (!profile) {
                throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} was not found.`);
            }
            if (!(0, isSsoProfile_1.isSsoProfile)(profile)) {
                throw new property_provider_1.CredentialsProviderError(`Profile ${profileName} is not configured with SSO credentials.`);
            }
            if (profile === null || profile === void 0 ? void 0 : profile.sso_session) {
                const ssoSessions = await (0, shared_ini_file_loader_1.loadSsoSessionData)(init);
                const session = ssoSessions[profile.sso_session];
                const conflictMsg = ` configurations in profile ${profileName} and sso-session ${profile.sso_session}`;
                if (ssoRegion && ssoRegion !== session.sso_region) {
                    throw new property_provider_1.CredentialsProviderError(`Conflicting SSO region` + conflictMsg, false);
                }
                if (ssoStartUrl && ssoStartUrl !== session.sso_start_url) {
                    throw new property_provider_1.CredentialsProviderError(`Conflicting SSO start_url` + conflictMsg, false);
                }
                profile.sso_region = session.sso_region;
                profile.sso_start_url = session.sso_start_url;
            }
            const { sso_start_url, sso_account_id, sso_region, sso_role_name, sso_session } = (0, validateSsoProfile_1.validateSsoProfile)(profile);
            return (0, resolveSSOCredentials_1.resolveSSOCredentials)({
                ssoStartUrl: sso_start_url,
                ssoSession: sso_session,
                ssoAccountId: sso_account_id,
                ssoRegion: sso_region,
                ssoRoleName: sso_role_name,
                ssoClient: ssoClient,
                profile: profileName
            });
        } else if (!ssoStartUrl || !ssoAccountId || !ssoRegion || !ssoRoleName) {
            throw new property_provider_1.CredentialsProviderError("Incomplete configuration. The fromSSO() argument hash must include " + '"ssoStartUrl", "ssoAccountId", "ssoRegion", "ssoRoleName"');
        } else {
            return (0, resolveSSOCredentials_1.resolveSSOCredentials)({
                ssoStartUrl,
                ssoSession,
                ssoAccountId,
                ssoRegion,
                ssoRoleName,
                ssoClient,
                profile: profileName
            });
        }
    };
exports.fromSSO = fromSSO;


/***/ }),

/***/ 68312:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(66422), exports);
tslib_1.__exportStar(__webpack_require__(73187), exports);
tslib_1.__exportStar(__webpack_require__(41100), exports);
tslib_1.__exportStar(__webpack_require__(38990), exports);


/***/ }),

/***/ 73187:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isSsoProfile = void 0;
const isSsoProfile = (arg)=>arg && (typeof arg.sso_start_url === "string" || typeof arg.sso_account_id === "string" || typeof arg.sso_session === "string" || typeof arg.sso_region === "string" || typeof arg.sso_role_name === "string");
exports.isSsoProfile = isSsoProfile;


/***/ }),

/***/ 78418:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveSSOCredentials = void 0;
const client_sso_1 = __webpack_require__(66510);
const token_providers_1 = __webpack_require__(47388);
const property_provider_1 = __webpack_require__(29852);
const shared_ini_file_loader_1 = __webpack_require__(3666);
const SHOULD_FAIL_CREDENTIAL_CHAIN = false;
const resolveSSOCredentials = async ({ ssoStartUrl, ssoSession, ssoAccountId, ssoRegion, ssoRoleName, ssoClient, profile })=>{
    let token;
    const refreshMessage = `To refresh this SSO session run aws sso login with the corresponding profile.`;
    if (ssoSession) {
        try {
            const _token = await (0, token_providers_1.fromSso)({
                profile
            })();
            token = {
                accessToken: _token.token,
                expiresAt: new Date(_token.expiration).toISOString()
            };
        } catch (e) {
            throw new property_provider_1.CredentialsProviderError(e.message, SHOULD_FAIL_CREDENTIAL_CHAIN);
        }
    } else {
        try {
            token = await (0, shared_ini_file_loader_1.getSSOTokenFromFile)(ssoStartUrl);
        } catch (e) {
            throw new property_provider_1.CredentialsProviderError(`The SSO session associated with this profile is invalid. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
        }
    }
    if (new Date(token.expiresAt).getTime() - Date.now() <= 0) {
        throw new property_provider_1.CredentialsProviderError(`The SSO session associated with this profile has expired. ${refreshMessage}`, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    const { accessToken } = token;
    const sso = ssoClient || new client_sso_1.SSOClient({
        region: ssoRegion
    });
    let ssoResp;
    try {
        ssoResp = await sso.send(new client_sso_1.GetRoleCredentialsCommand({
            accountId: ssoAccountId,
            roleName: ssoRoleName,
            accessToken
        }));
    } catch (e) {
        throw property_provider_1.CredentialsProviderError.from(e, SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    const { roleCredentials: { accessKeyId, secretAccessKey, sessionToken, expiration } = {} } = ssoResp;
    if (!accessKeyId || !secretAccessKey || !sessionToken || !expiration) {
        throw new property_provider_1.CredentialsProviderError("SSO returns an invalid temporary credential.", SHOULD_FAIL_CREDENTIAL_CHAIN);
    }
    return {
        accessKeyId,
        secretAccessKey,
        sessionToken,
        expiration: new Date(expiration)
    };
};
exports.resolveSSOCredentials = resolveSSOCredentials;


/***/ }),

/***/ 41100:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 38990:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.validateSsoProfile = void 0;
const property_provider_1 = __webpack_require__(29852);
const validateSsoProfile = (profile)=>{
    const { sso_start_url, sso_account_id, sso_region, sso_role_name } = profile;
    if (!sso_start_url || !sso_account_id || !sso_region || !sso_role_name) {
        throw new property_provider_1.CredentialsProviderError(`Profile is configured with invalid SSO credentials. Required parameters "sso_account_id", ` + `"sso_region", "sso_role_name", "sso_start_url". Got ${Object.keys(profile).join(", ")}\nReference: https://docs.aws.amazon.com/cli/latest/userguide/cli-configure-sso.html`, false);
    }
    return profile;
};
exports.validateSsoProfile = validateSsoProfile;


/***/ }),

/***/ 55200:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromTokenFile = void 0;
const property_provider_1 = __webpack_require__(29852);
const fs_1 = __webpack_require__(57147);
const fromWebToken_1 = __webpack_require__(59519);
const ENV_TOKEN_FILE = "AWS_WEB_IDENTITY_TOKEN_FILE";
const ENV_ROLE_ARN = "AWS_ROLE_ARN";
const ENV_ROLE_SESSION_NAME = "AWS_ROLE_SESSION_NAME";
const fromTokenFile = (init = {})=>async ()=>{
        var _a, _b, _c;
        const webIdentityTokenFile = (_a = init === null || init === void 0 ? void 0 : init.webIdentityTokenFile) !== null && _a !== void 0 ? _a : process.env[ENV_TOKEN_FILE];
        const roleArn = (_b = init === null || init === void 0 ? void 0 : init.roleArn) !== null && _b !== void 0 ? _b : process.env[ENV_ROLE_ARN];
        const roleSessionName = (_c = init === null || init === void 0 ? void 0 : init.roleSessionName) !== null && _c !== void 0 ? _c : process.env[ENV_ROLE_SESSION_NAME];
        if (!webIdentityTokenFile || !roleArn) {
            throw new property_provider_1.CredentialsProviderError("Web identity configuration not specified");
        }
        return (0, fromWebToken_1.fromWebToken)({
            ...init,
            webIdentityToken: (0, fs_1.readFileSync)(webIdentityTokenFile, {
                encoding: "ascii"
            }),
            roleArn,
            roleSessionName
        })();
    };
exports.fromTokenFile = fromTokenFile;


/***/ }),

/***/ 59519:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromWebToken = void 0;
const property_provider_1 = __webpack_require__(29852);
const fromWebToken = (init)=>()=>{
        const { roleArn, roleSessionName, webIdentityToken, providerId, policyArns, policy, durationSeconds, roleAssumerWithWebIdentity } = init;
        if (!roleAssumerWithWebIdentity) {
            throw new property_provider_1.CredentialsProviderError(`Role Arn '${roleArn}' needs to be assumed with web identity,` + ` but no role assumption callback was provided.`, false);
        }
        return roleAssumerWithWebIdentity({
            RoleArn: roleArn,
            RoleSessionName: roleSessionName !== null && roleSessionName !== void 0 ? roleSessionName : `aws-sdk-js-session-${Date.now()}`,
            WebIdentityToken: webIdentityToken,
            ProviderId: providerId,
            PolicyArns: policyArns,
            Policy: policy,
            DurationSeconds: durationSeconds
        });
    };
exports.fromWebToken = fromWebToken;


/***/ }),

/***/ 55835:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(55200), exports);
tslib_1.__exportStar(__webpack_require__(59519), exports);


/***/ }),

/***/ 23496:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getHostHeaderPlugin = exports.hostHeaderMiddlewareOptions = exports.hostHeaderMiddleware = exports.resolveHostHeaderConfig = void 0;
const protocol_http_1 = __webpack_require__(64082);
function resolveHostHeaderConfig(input) {
    return input;
}
exports.resolveHostHeaderConfig = resolveHostHeaderConfig;
const hostHeaderMiddleware = (options)=>(next)=>async (args)=>{
            if (!protocol_http_1.HttpRequest.isInstance(args.request)) return next(args);
            const { request } = args;
            const { handlerProtocol = "" } = options.requestHandler.metadata || {};
            if (handlerProtocol.indexOf("h2") >= 0 && !request.headers[":authority"]) {
                delete request.headers["host"];
                request.headers[":authority"] = "";
            } else if (!request.headers["host"]) {
                let host = request.hostname;
                if (request.port != null) host += `:${request.port}`;
                request.headers["host"] = host;
            }
            return next(args);
        };
exports.hostHeaderMiddleware = hostHeaderMiddleware;
exports.hostHeaderMiddlewareOptions = {
    name: "hostHeaderMiddleware",
    step: "build",
    priority: "low",
    tags: [
        "HOST"
    ],
    override: true
};
const getHostHeaderPlugin = (options)=>({
        applyToStack: (clientStack)=>{
            clientStack.add((0, exports.hostHeaderMiddleware)(options), exports.hostHeaderMiddlewareOptions);
        }
    });
exports.getHostHeaderPlugin = getHostHeaderPlugin;


/***/ }),

/***/ 25791:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(87293), exports);


/***/ }),

/***/ 87293:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getLoggerPlugin = exports.loggerMiddlewareOptions = exports.loggerMiddleware = void 0;
const loggerMiddleware = ()=>(next, context)=>async (args)=>{
            var _a, _b;
            try {
                const response = await next(args);
                const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
                const { overrideInputFilterSensitiveLog, overrideOutputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
                const inputFilterSensitiveLog = overrideInputFilterSensitiveLog !== null && overrideInputFilterSensitiveLog !== void 0 ? overrideInputFilterSensitiveLog : context.inputFilterSensitiveLog;
                const outputFilterSensitiveLog = overrideOutputFilterSensitiveLog !== null && overrideOutputFilterSensitiveLog !== void 0 ? overrideOutputFilterSensitiveLog : context.outputFilterSensitiveLog;
                const { $metadata, ...outputWithoutMetadata } = response.output;
                (_a = logger === null || logger === void 0 ? void 0 : logger.info) === null || _a === void 0 ? void 0 : _a.call(logger, {
                    clientName,
                    commandName,
                    input: inputFilterSensitiveLog(args.input),
                    output: outputFilterSensitiveLog(outputWithoutMetadata),
                    metadata: $metadata
                });
                return response;
            } catch (error) {
                const { clientName, commandName, logger, dynamoDbDocumentClientOptions = {} } = context;
                const { overrideInputFilterSensitiveLog } = dynamoDbDocumentClientOptions;
                const inputFilterSensitiveLog = overrideInputFilterSensitiveLog !== null && overrideInputFilterSensitiveLog !== void 0 ? overrideInputFilterSensitiveLog : context.inputFilterSensitiveLog;
                (_b = logger === null || logger === void 0 ? void 0 : logger.error) === null || _b === void 0 ? void 0 : _b.call(logger, {
                    clientName,
                    commandName,
                    input: inputFilterSensitiveLog(args.input),
                    error,
                    metadata: error.$metadata
                });
                throw error;
            }
        };
exports.loggerMiddleware = loggerMiddleware;
exports.loggerMiddlewareOptions = {
    name: "loggerMiddleware",
    tags: [
        "LOGGER"
    ],
    step: "initialize",
    override: true
};
const getLoggerPlugin = (options)=>({
        applyToStack: (clientStack)=>{
            clientStack.add((0, exports.loggerMiddleware)(), exports.loggerMiddlewareOptions);
        }
    });
exports.getLoggerPlugin = getLoggerPlugin;


/***/ }),

/***/ 86548:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getRecursionDetectionPlugin = exports.addRecursionDetectionMiddlewareOptions = exports.recursionDetectionMiddleware = void 0;
const protocol_http_1 = __webpack_require__(64082);
const TRACE_ID_HEADER_NAME = "X-Amzn-Trace-Id";
const ENV_LAMBDA_FUNCTION_NAME = "AWS_LAMBDA_FUNCTION_NAME";
const ENV_TRACE_ID = "_X_AMZN_TRACE_ID";
const recursionDetectionMiddleware = (options)=>(next)=>async (args)=>{
            const { request } = args;
            if (!protocol_http_1.HttpRequest.isInstance(request) || options.runtime !== "node" || request.headers.hasOwnProperty(TRACE_ID_HEADER_NAME)) {
                return next(args);
            }
            const functionName = process.env[ENV_LAMBDA_FUNCTION_NAME];
            const traceId = process.env[ENV_TRACE_ID];
            const nonEmptyString = (str)=>typeof str === "string" && str.length > 0;
            if (nonEmptyString(functionName) && nonEmptyString(traceId)) {
                request.headers[TRACE_ID_HEADER_NAME] = traceId;
            }
            return next({
                ...args,
                request
            });
        };
exports.recursionDetectionMiddleware = recursionDetectionMiddleware;
exports.addRecursionDetectionMiddlewareOptions = {
    step: "build",
    tags: [
        "RECURSION_DETECTION"
    ],
    name: "recursionDetectionMiddleware",
    override: true,
    priority: "low"
};
const getRecursionDetectionPlugin = (options)=>({
        applyToStack: (clientStack)=>{
            clientStack.add((0, exports.recursionDetectionMiddleware)(options), exports.addRecursionDetectionMiddlewareOptions);
        }
    });
exports.getRecursionDetectionPlugin = getRecursionDetectionPlugin;


/***/ }),

/***/ 19639:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveStsAuthConfig = void 0;
const middleware_signing_1 = __webpack_require__(73129);
const resolveStsAuthConfig = (input, { stsClientCtor })=>(0, middleware_signing_1.resolveAwsAuthConfig)({
        ...input,
        stsClientCtor
    });
exports.resolveStsAuthConfig = resolveStsAuthConfig;


/***/ }),

/***/ 27104:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveSigV4AuthConfig = exports.resolveAwsAuthConfig = void 0;
const property_provider_1 = __webpack_require__(29852);
const signature_v4_1 = __webpack_require__(19671);
const util_middleware_1 = __webpack_require__(5837);
const CREDENTIAL_EXPIRE_WINDOW = 300000;
const resolveAwsAuthConfig = (input)=>{
    const normalizedCreds = input.credentials ? normalizeCredentialProvider(input.credentials) : input.credentialDefaultProvider(input);
    const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
    let signer;
    if (input.signer) {
        signer = (0, util_middleware_1.normalizeProvider)(input.signer);
    } else if (input.regionInfoProvider) {
        signer = ()=>(0, util_middleware_1.normalizeProvider)(input.region)().then(async (region)=>[
                    await input.regionInfoProvider(region, {
                        useFipsEndpoint: await input.useFipsEndpoint(),
                        useDualstackEndpoint: await input.useDualstackEndpoint()
                    }) || {},
                    region
                ]).then(([regionInfo, region])=>{
                const { signingRegion, signingService } = regionInfo;
                input.signingRegion = input.signingRegion || signingRegion || region;
                input.signingName = input.signingName || signingService || input.serviceId;
                const params = {
                    ...input,
                    credentials: normalizedCreds,
                    region: input.signingRegion,
                    service: input.signingName,
                    sha256,
                    uriEscapePath: signingEscapePath
                };
                const SignerCtor = input.signerConstructor || signature_v4_1.SignatureV4;
                return new SignerCtor(params);
            });
    } else {
        signer = async (authScheme)=>{
            authScheme = Object.assign({}, {
                name: "sigv4",
                signingName: input.signingName || input.defaultSigningName,
                signingRegion: await (0, util_middleware_1.normalizeProvider)(input.region)(),
                properties: {}
            }, authScheme);
            const signingRegion = authScheme.signingRegion;
            const signingService = authScheme.signingName;
            input.signingRegion = input.signingRegion || signingRegion;
            input.signingName = input.signingName || signingService || input.serviceId;
            const params = {
                ...input,
                credentials: normalizedCreds,
                region: input.signingRegion,
                service: input.signingName,
                sha256,
                uriEscapePath: signingEscapePath
            };
            const SignerCtor = input.signerConstructor || signature_v4_1.SignatureV4;
            return new SignerCtor(params);
        };
    }
    return {
        ...input,
        systemClockOffset,
        signingEscapePath,
        credentials: normalizedCreds,
        signer
    };
};
exports.resolveAwsAuthConfig = resolveAwsAuthConfig;
const resolveSigV4AuthConfig = (input)=>{
    const normalizedCreds = input.credentials ? normalizeCredentialProvider(input.credentials) : input.credentialDefaultProvider(input);
    const { signingEscapePath = true, systemClockOffset = input.systemClockOffset || 0, sha256 } = input;
    let signer;
    if (input.signer) {
        signer = (0, util_middleware_1.normalizeProvider)(input.signer);
    } else {
        signer = (0, util_middleware_1.normalizeProvider)(new signature_v4_1.SignatureV4({
            credentials: normalizedCreds,
            region: input.region,
            service: input.signingName,
            sha256,
            uriEscapePath: signingEscapePath
        }));
    }
    return {
        ...input,
        systemClockOffset,
        signingEscapePath,
        credentials: normalizedCreds,
        signer
    };
};
exports.resolveSigV4AuthConfig = resolveSigV4AuthConfig;
const normalizeCredentialProvider = (credentials)=>{
    if (typeof credentials === "function") {
        return (0, property_provider_1.memoize)(credentials, (credentials)=>credentials.expiration !== undefined && credentials.expiration.getTime() - Date.now() < CREDENTIAL_EXPIRE_WINDOW, (credentials)=>credentials.expiration !== undefined);
    }
    return (0, util_middleware_1.normalizeProvider)(credentials);
};


/***/ }),

/***/ 99446:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getSigV4AuthPlugin = exports.getAwsAuthPlugin = exports.awsAuthMiddlewareOptions = exports.awsAuthMiddleware = void 0;
const protocol_http_1 = __webpack_require__(64082);
const getSkewCorrectedDate_1 = __webpack_require__(50387);
const getUpdatedSystemClockOffset_1 = __webpack_require__(26261);
const awsAuthMiddleware = (options)=>(next, context)=>async function(args) {
            var _a, _b, _c, _d;
            if (!protocol_http_1.HttpRequest.isInstance(args.request)) return next(args);
            const authScheme = (_c = (_b = (_a = context.endpointV2) === null || _a === void 0 ? void 0 : _a.properties) === null || _b === void 0 ? void 0 : _b.authSchemes) === null || _c === void 0 ? void 0 : _c[0];
            const multiRegionOverride = (authScheme === null || authScheme === void 0 ? void 0 : authScheme.name) === "sigv4a" ? (_d = authScheme === null || authScheme === void 0 ? void 0 : authScheme.signingRegionSet) === null || _d === void 0 ? void 0 : _d.join(",") : undefined;
            const signer = await options.signer(authScheme);
            const output = await next({
                ...args,
                request: await signer.sign(args.request, {
                    signingDate: (0, getSkewCorrectedDate_1.getSkewCorrectedDate)(options.systemClockOffset),
                    signingRegion: multiRegionOverride || context["signing_region"],
                    signingService: context["signing_service"]
                })
            }).catch((error)=>{
                var _a;
                const serverTime = (_a = error.ServerTime) !== null && _a !== void 0 ? _a : getDateHeader(error.$response);
                if (serverTime) {
                    options.systemClockOffset = (0, getUpdatedSystemClockOffset_1.getUpdatedSystemClockOffset)(serverTime, options.systemClockOffset);
                }
                throw error;
            });
            const dateHeader = getDateHeader(output.response);
            if (dateHeader) {
                options.systemClockOffset = (0, getUpdatedSystemClockOffset_1.getUpdatedSystemClockOffset)(dateHeader, options.systemClockOffset);
            }
            return output;
        };
exports.awsAuthMiddleware = awsAuthMiddleware;
const getDateHeader = (response)=>{
    var _a, _b, _c;
    return protocol_http_1.HttpResponse.isInstance(response) ? (_b = (_a = response.headers) === null || _a === void 0 ? void 0 : _a.date) !== null && _b !== void 0 ? _b : (_c = response.headers) === null || _c === void 0 ? void 0 : _c.Date : undefined;
};
exports.awsAuthMiddlewareOptions = {
    name: "awsAuthMiddleware",
    tags: [
        "SIGNATURE",
        "AWSAUTH"
    ],
    relation: "after",
    toMiddleware: "retryMiddleware",
    override: true
};
const getAwsAuthPlugin = (options)=>({
        applyToStack: (clientStack)=>{
            clientStack.addRelativeTo((0, exports.awsAuthMiddleware)(options), exports.awsAuthMiddlewareOptions);
        }
    });
exports.getAwsAuthPlugin = getAwsAuthPlugin;
exports.getSigV4AuthPlugin = exports.getAwsAuthPlugin;


/***/ }),

/***/ 73129:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(27104), exports);
tslib_1.__exportStar(__webpack_require__(99446), exports);


/***/ }),

/***/ 50387:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getSkewCorrectedDate = void 0;
const getSkewCorrectedDate = (systemClockOffset)=>new Date(Date.now() + systemClockOffset);
exports.getSkewCorrectedDate = getSkewCorrectedDate;


/***/ }),

/***/ 26261:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getUpdatedSystemClockOffset = void 0;
const isClockSkewed_1 = __webpack_require__(71352);
const getUpdatedSystemClockOffset = (clockTime, currentSystemClockOffset)=>{
    const clockTimeInMs = Date.parse(clockTime);
    if ((0, isClockSkewed_1.isClockSkewed)(clockTimeInMs, currentSystemClockOffset)) {
        return clockTimeInMs - Date.now();
    }
    return currentSystemClockOffset;
};
exports.getUpdatedSystemClockOffset = getUpdatedSystemClockOffset;


/***/ }),

/***/ 71352:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isClockSkewed = void 0;
const getSkewCorrectedDate_1 = __webpack_require__(50387);
const isClockSkewed = (clockTime, systemClockOffset)=>Math.abs((0, getSkewCorrectedDate_1.getSkewCorrectedDate)(systemClockOffset).getTime() - clockTime) >= 300000;
exports.isClockSkewed = isClockSkewed;


/***/ }),

/***/ 31176:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveUserAgentConfig = void 0;
function resolveUserAgentConfig(input) {
    return {
        ...input,
        customUserAgent: typeof input.customUserAgent === "string" ? [
            [
                input.customUserAgent
            ]
        ] : input.customUserAgent
    };
}
exports.resolveUserAgentConfig = resolveUserAgentConfig;


/***/ }),

/***/ 37839:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UA_ESCAPE_CHAR = exports.UA_VALUE_ESCAPE_REGEX = exports.UA_NAME_ESCAPE_REGEX = exports.UA_NAME_SEPARATOR = exports.SPACE = exports.X_AMZ_USER_AGENT = exports.USER_AGENT = void 0;
exports.USER_AGENT = "user-agent";
exports.X_AMZ_USER_AGENT = "x-amz-user-agent";
exports.SPACE = " ";
exports.UA_NAME_SEPARATOR = "/";
exports.UA_NAME_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w]/g;
exports.UA_VALUE_ESCAPE_REGEX = /[^\!\$\%\&\'\*\+\-\.\^\_\`\|\~\d\w\#]/g;
exports.UA_ESCAPE_CHAR = "-";


/***/ }),

/***/ 71886:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(31176), exports);
tslib_1.__exportStar(__webpack_require__(45788), exports);


/***/ }),

/***/ 45788:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getUserAgentPlugin = exports.getUserAgentMiddlewareOptions = exports.userAgentMiddleware = void 0;
const util_endpoints_1 = __webpack_require__(8059);
const protocol_http_1 = __webpack_require__(64082);
const constants_1 = __webpack_require__(37839);
const userAgentMiddleware = (options)=>(next, context)=>async (args)=>{
            var _a, _b;
            const { request } = args;
            if (!protocol_http_1.HttpRequest.isInstance(request)) return next(args);
            const { headers } = request;
            const userAgent = ((_a = context === null || context === void 0 ? void 0 : context.userAgent) === null || _a === void 0 ? void 0 : _a.map(escapeUserAgent)) || [];
            const defaultUserAgent = (await options.defaultUserAgentProvider()).map(escapeUserAgent);
            const customUserAgent = ((_b = options === null || options === void 0 ? void 0 : options.customUserAgent) === null || _b === void 0 ? void 0 : _b.map(escapeUserAgent)) || [];
            const prefix = (0, util_endpoints_1.getUserAgentPrefix)();
            const sdkUserAgentValue = (prefix ? [
                prefix
            ] : []).concat([
                ...defaultUserAgent,
                ...userAgent,
                ...customUserAgent
            ]).join(constants_1.SPACE);
            const normalUAValue = [
                ...defaultUserAgent.filter((section)=>section.startsWith("aws-sdk-")),
                ...customUserAgent
            ].join(constants_1.SPACE);
            if (options.runtime !== "browser") {
                if (normalUAValue) {
                    headers[constants_1.X_AMZ_USER_AGENT] = headers[constants_1.X_AMZ_USER_AGENT] ? `${headers[constants_1.USER_AGENT]} ${normalUAValue}` : normalUAValue;
                }
                headers[constants_1.USER_AGENT] = sdkUserAgentValue;
            } else {
                headers[constants_1.X_AMZ_USER_AGENT] = sdkUserAgentValue;
            }
            return next({
                ...args,
                request
            });
        };
exports.userAgentMiddleware = userAgentMiddleware;
const escapeUserAgent = (userAgentPair)=>{
    var _a;
    const name = userAgentPair[0].split(constants_1.UA_NAME_SEPARATOR).map((part)=>part.replace(constants_1.UA_NAME_ESCAPE_REGEX, constants_1.UA_ESCAPE_CHAR)).join(constants_1.UA_NAME_SEPARATOR);
    const version = (_a = userAgentPair[1]) === null || _a === void 0 ? void 0 : _a.replace(constants_1.UA_VALUE_ESCAPE_REGEX, constants_1.UA_ESCAPE_CHAR);
    const prefixSeparatorIndex = name.indexOf(constants_1.UA_NAME_SEPARATOR);
    const prefix = name.substring(0, prefixSeparatorIndex);
    let uaName = name.substring(prefixSeparatorIndex + 1);
    if (prefix === "api") {
        uaName = uaName.toLowerCase();
    }
    return [
        prefix,
        uaName,
        version
    ].filter((item)=>item && item.length > 0).reduce((acc, item, index)=>{
        switch(index){
            case 0:
                return item;
            case 1:
                return `${acc}/${item}`;
            default:
                return `${acc}#${item}`;
        }
    }, "");
};
exports.getUserAgentMiddlewareOptions = {
    name: "getUserAgentMiddleware",
    step: "build",
    priority: "low",
    tags: [
        "SET_USER_AGENT",
        "USER_AGENT"
    ],
    override: true
};
const getUserAgentPlugin = (config)=>({
        applyToStack: (clientStack)=>{
            clientStack.add((0, exports.userAgentMiddleware)(config), exports.getUserAgentMiddlewareOptions);
        }
    });
exports.getUserAgentPlugin = getUserAgentPlugin;


/***/ }),

/***/ 53597:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UnsupportedGrantTypeException = exports.UnauthorizedClientException = exports.SlowDownException = exports.SSOOIDCClient = exports.InvalidScopeException = exports.InvalidRequestException = exports.InvalidClientException = exports.InternalServerException = exports.ExpiredTokenException = exports.CreateTokenCommand = exports.AuthorizationPendingException = exports.AccessDeniedException = void 0;
const middleware_host_header_1 = __webpack_require__(23496);
const middleware_logger_1 = __webpack_require__(25791);
const middleware_recursion_detection_1 = __webpack_require__(86548);
const middleware_user_agent_1 = __webpack_require__(71886);
const config_resolver_1 = __webpack_require__(25708);
const middleware_content_length_1 = __webpack_require__(32636);
const middleware_endpoint_1 = __webpack_require__(33692);
const middleware_retry_1 = __webpack_require__(75567);
const smithy_client_1 = __webpack_require__(18851);
var resolveClientEndpointParameters = (options)=>{
    var _a, _b;
    return {
        ...options,
        useDualstackEndpoint: (_a = options.useDualstackEndpoint) !== null && _a !== void 0 ? _a : false,
        useFipsEndpoint: (_b = options.useFipsEndpoint) !== null && _b !== void 0 ? _b : false,
        defaultSigningName: "awsssooidc"
    };
};
var package_default = {
    version: "3.387.0"
};
const util_user_agent_node_1 = __webpack_require__(62850);
const config_resolver_2 = __webpack_require__(25708);
const hash_node_1 = __webpack_require__(44341);
const middleware_retry_2 = __webpack_require__(75567);
const node_config_provider_1 = __webpack_require__(15829);
const node_http_handler_1 = __webpack_require__(44025);
const util_body_length_node_1 = __webpack_require__(2414);
const util_retry_1 = __webpack_require__(7885);
const smithy_client_2 = __webpack_require__(18851);
const url_parser_1 = __webpack_require__(45110);
const util_base64_1 = __webpack_require__(53013);
const util_utf8_1 = __webpack_require__(66120);
const util_endpoints_1 = __webpack_require__(8059);
var p = "required";
var q = "fn";
var r = "argv";
var s = "ref";
var a = "PartitionResult";
var b = "tree";
var c = "error";
var d = "endpoint";
var e = {
    [p]: false,
    "type": "String"
};
var f = {
    [p]: true,
    "default": false,
    "type": "Boolean"
};
var g = {
    [s]: "Endpoint"
};
var h = {
    [q]: "booleanEquals",
    [r]: [
        {
            [s]: "UseFIPS"
        },
        true
    ]
};
var i = {
    [q]: "booleanEquals",
    [r]: [
        {
            [s]: "UseDualStack"
        },
        true
    ]
};
var j = {};
var k = {
    [q]: "booleanEquals",
    [r]: [
        true,
        {
            [q]: "getAttr",
            [r]: [
                {
                    [s]: a
                },
                "supportsFIPS"
            ]
        }
    ]
};
var l = {
    [q]: "booleanEquals",
    [r]: [
        true,
        {
            [q]: "getAttr",
            [r]: [
                {
                    [s]: a
                },
                "supportsDualStack"
            ]
        }
    ]
};
var m = [
    g
];
var n = [
    h
];
var o = [
    i
];
var _data = {
    version: "1.0",
    parameters: {
        Region: e,
        UseDualStack: f,
        UseFIPS: f,
        Endpoint: e
    },
    rules: [
        {
            conditions: [
                {
                    [q]: "aws.partition",
                    [r]: [
                        {
                            [s]: "Region"
                        }
                    ],
                    assign: a
                }
            ],
            type: b,
            rules: [
                {
                    conditions: [
                        {
                            [q]: "isSet",
                            [r]: m
                        },
                        {
                            [q]: "parseURL",
                            [r]: m,
                            assign: "url"
                        }
                    ],
                    type: b,
                    rules: [
                        {
                            conditions: n,
                            error: "Invalid Configuration: FIPS and custom endpoint are not supported",
                            type: c
                        },
                        {
                            type: b,
                            rules: [
                                {
                                    conditions: o,
                                    error: "Invalid Configuration: Dualstack and custom endpoint are not supported",
                                    type: c
                                },
                                {
                                    endpoint: {
                                        url: g,
                                        properties: j,
                                        headers: j
                                    },
                                    type: d
                                }
                            ]
                        }
                    ]
                },
                {
                    conditions: [
                        h,
                        i
                    ],
                    type: b,
                    rules: [
                        {
                            conditions: [
                                k,
                                l
                            ],
                            type: b,
                            rules: [
                                {
                                    endpoint: {
                                        url: "https://oidc-fips.{Region}.{PartitionResult#dualStackDnsSuffix}",
                                        properties: j,
                                        headers: j
                                    },
                                    type: d
                                }
                            ]
                        },
                        {
                            error: "FIPS and DualStack are enabled, but this partition does not support one or both",
                            type: c
                        }
                    ]
                },
                {
                    conditions: n,
                    type: b,
                    rules: [
                        {
                            conditions: [
                                k
                            ],
                            type: b,
                            rules: [
                                {
                                    type: b,
                                    rules: [
                                        {
                                            endpoint: {
                                                url: "https://oidc-fips.{Region}.{PartitionResult#dnsSuffix}",
                                                properties: j,
                                                headers: j
                                            },
                                            type: d
                                        }
                                    ]
                                }
                            ]
                        },
                        {
                            error: "FIPS is enabled but this partition does not support FIPS",
                            type: c
                        }
                    ]
                },
                {
                    conditions: o,
                    type: b,
                    rules: [
                        {
                            conditions: [
                                l
                            ],
                            type: b,
                            rules: [
                                {
                                    endpoint: {
                                        url: "https://oidc.{Region}.{PartitionResult#dualStackDnsSuffix}",
                                        properties: j,
                                        headers: j
                                    },
                                    type: d
                                }
                            ]
                        },
                        {
                            error: "DualStack is enabled but this partition does not support DualStack",
                            type: c
                        }
                    ]
                },
                {
                    endpoint: {
                        url: "https://oidc.{Region}.{PartitionResult#dnsSuffix}",
                        properties: j,
                        headers: j
                    },
                    type: d
                }
            ]
        }
    ]
};
var ruleSet = _data;
var defaultEndpointResolver = (endpointParams, context = {})=>{
    return (0, util_endpoints_1.resolveEndpoint)(ruleSet, {
        endpointParams,
        logger: context.logger
    });
};
var getRuntimeConfig = (config)=>{
    var _a, _b, _c, _d, _e, _f, _g, _h, _j;
    return {
        apiVersion: "2019-06-10",
        base64Decoder: (_a = config === null || config === void 0 ? void 0 : config.base64Decoder) !== null && _a !== void 0 ? _a : util_base64_1.fromBase64,
        base64Encoder: (_b = config === null || config === void 0 ? void 0 : config.base64Encoder) !== null && _b !== void 0 ? _b : util_base64_1.toBase64,
        disableHostPrefix: (_c = config === null || config === void 0 ? void 0 : config.disableHostPrefix) !== null && _c !== void 0 ? _c : false,
        endpointProvider: (_d = config === null || config === void 0 ? void 0 : config.endpointProvider) !== null && _d !== void 0 ? _d : defaultEndpointResolver,
        logger: (_e = config === null || config === void 0 ? void 0 : config.logger) !== null && _e !== void 0 ? _e : new smithy_client_2.NoOpLogger(),
        serviceId: (_f = config === null || config === void 0 ? void 0 : config.serviceId) !== null && _f !== void 0 ? _f : "SSO OIDC",
        urlParser: (_g = config === null || config === void 0 ? void 0 : config.urlParser) !== null && _g !== void 0 ? _g : url_parser_1.parseUrl,
        utf8Decoder: (_h = config === null || config === void 0 ? void 0 : config.utf8Decoder) !== null && _h !== void 0 ? _h : util_utf8_1.fromUtf8,
        utf8Encoder: (_j = config === null || config === void 0 ? void 0 : config.utf8Encoder) !== null && _j !== void 0 ? _j : util_utf8_1.toUtf8
    };
};
const smithy_client_3 = __webpack_require__(18851);
const util_defaults_mode_node_1 = __webpack_require__(87393);
const smithy_client_4 = __webpack_require__(18851);
var getRuntimeConfig2 = (config)=>{
    var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k;
    (0, smithy_client_4.emitWarningIfUnsupportedVersion)(process.version);
    const defaultsMode = (0, util_defaults_mode_node_1.resolveDefaultsModeConfig)(config);
    const defaultConfigProvider = ()=>defaultsMode().then(smithy_client_3.loadConfigsForDefaultMode);
    const clientSharedValues = getRuntimeConfig(config);
    return {
        ...clientSharedValues,
        ...config,
        runtime: "node",
        defaultsMode,
        bodyLengthChecker: (_a = config === null || config === void 0 ? void 0 : config.bodyLengthChecker) !== null && _a !== void 0 ? _a : util_body_length_node_1.calculateBodyLength,
        defaultUserAgentProvider: (_b = config === null || config === void 0 ? void 0 : config.defaultUserAgentProvider) !== null && _b !== void 0 ? _b : (0, util_user_agent_node_1.defaultUserAgent)({
            serviceId: clientSharedValues.serviceId,
            clientVersion: package_default.version
        }),
        maxAttempts: (_c = config === null || config === void 0 ? void 0 : config.maxAttempts) !== null && _c !== void 0 ? _c : (0, node_config_provider_1.loadConfig)(middleware_retry_2.NODE_MAX_ATTEMPT_CONFIG_OPTIONS),
        region: (_d = config === null || config === void 0 ? void 0 : config.region) !== null && _d !== void 0 ? _d : (0, node_config_provider_1.loadConfig)(config_resolver_2.NODE_REGION_CONFIG_OPTIONS, config_resolver_2.NODE_REGION_CONFIG_FILE_OPTIONS),
        requestHandler: (_e = config === null || config === void 0 ? void 0 : config.requestHandler) !== null && _e !== void 0 ? _e : new node_http_handler_1.NodeHttpHandler(defaultConfigProvider),
        retryMode: (_f = config === null || config === void 0 ? void 0 : config.retryMode) !== null && _f !== void 0 ? _f : (0, node_config_provider_1.loadConfig)({
            ...middleware_retry_2.NODE_RETRY_MODE_CONFIG_OPTIONS,
            default: async ()=>(await defaultConfigProvider()).retryMode || util_retry_1.DEFAULT_RETRY_MODE
        }),
        sha256: (_g = config === null || config === void 0 ? void 0 : config.sha256) !== null && _g !== void 0 ? _g : hash_node_1.Hash.bind(null, "sha256"),
        streamCollector: (_h = config === null || config === void 0 ? void 0 : config.streamCollector) !== null && _h !== void 0 ? _h : node_http_handler_1.streamCollector,
        useDualstackEndpoint: (_j = config === null || config === void 0 ? void 0 : config.useDualstackEndpoint) !== null && _j !== void 0 ? _j : (0, node_config_provider_1.loadConfig)(config_resolver_2.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS),
        useFipsEndpoint: (_k = config === null || config === void 0 ? void 0 : config.useFipsEndpoint) !== null && _k !== void 0 ? _k : (0, node_config_provider_1.loadConfig)(config_resolver_2.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS)
    };
};
var SSOOIDCClient = class extends smithy_client_1.Client {
    constructor(...[configuration]){
        const _config_0 = getRuntimeConfig2(configuration || {});
        const _config_1 = resolveClientEndpointParameters(_config_0);
        const _config_2 = (0, config_resolver_1.resolveRegionConfig)(_config_1);
        const _config_3 = (0, middleware_endpoint_1.resolveEndpointConfig)(_config_2);
        const _config_4 = (0, middleware_retry_1.resolveRetryConfig)(_config_3);
        const _config_5 = (0, middleware_host_header_1.resolveHostHeaderConfig)(_config_4);
        const _config_6 = (0, middleware_user_agent_1.resolveUserAgentConfig)(_config_5);
        super(_config_6);
        this.config = _config_6;
        this.middlewareStack.use((0, middleware_retry_1.getRetryPlugin)(this.config));
        this.middlewareStack.use((0, middleware_content_length_1.getContentLengthPlugin)(this.config));
        this.middlewareStack.use((0, middleware_host_header_1.getHostHeaderPlugin)(this.config));
        this.middlewareStack.use((0, middleware_logger_1.getLoggerPlugin)(this.config));
        this.middlewareStack.use((0, middleware_recursion_detection_1.getRecursionDetectionPlugin)(this.config));
        this.middlewareStack.use((0, middleware_user_agent_1.getUserAgentPlugin)(this.config));
    }
    destroy() {
        super.destroy();
    }
};
exports.SSOOIDCClient = SSOOIDCClient;
const smithy_client_5 = __webpack_require__(18851);
const middleware_endpoint_2 = __webpack_require__(33692);
const middleware_serde_1 = __webpack_require__(22406);
const smithy_client_6 = __webpack_require__(18851);
const protocol_http_1 = __webpack_require__(64082);
const smithy_client_7 = __webpack_require__(18851);
const smithy_client_8 = __webpack_require__(18851);
var SSOOIDCServiceException = class _SSOOIDCServiceException extends smithy_client_8.ServiceException {
    constructor(options){
        super(options);
        Object.setPrototypeOf(this, _SSOOIDCServiceException.prototype);
    }
};
var AccessDeniedException = class _AccessDeniedException extends SSOOIDCServiceException {
    constructor(opts){
        super({
            name: "AccessDeniedException",
            $fault: "client",
            ...opts
        });
        this.name = "AccessDeniedException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _AccessDeniedException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.AccessDeniedException = AccessDeniedException;
var AuthorizationPendingException = class _AuthorizationPendingException extends SSOOIDCServiceException {
    constructor(opts){
        super({
            name: "AuthorizationPendingException",
            $fault: "client",
            ...opts
        });
        this.name = "AuthorizationPendingException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _AuthorizationPendingException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.AuthorizationPendingException = AuthorizationPendingException;
var ExpiredTokenException = class _ExpiredTokenException extends SSOOIDCServiceException {
    constructor(opts){
        super({
            name: "ExpiredTokenException",
            $fault: "client",
            ...opts
        });
        this.name = "ExpiredTokenException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _ExpiredTokenException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.ExpiredTokenException = ExpiredTokenException;
var InternalServerException = class _InternalServerException extends SSOOIDCServiceException {
    constructor(opts){
        super({
            name: "InternalServerException",
            $fault: "server",
            ...opts
        });
        this.name = "InternalServerException";
        this.$fault = "server";
        Object.setPrototypeOf(this, _InternalServerException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.InternalServerException = InternalServerException;
var InvalidClientException = class _InvalidClientException extends SSOOIDCServiceException {
    constructor(opts){
        super({
            name: "InvalidClientException",
            $fault: "client",
            ...opts
        });
        this.name = "InvalidClientException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidClientException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.InvalidClientException = InvalidClientException;
var InvalidGrantException = class _InvalidGrantException extends SSOOIDCServiceException {
    constructor(opts){
        super({
            name: "InvalidGrantException",
            $fault: "client",
            ...opts
        });
        this.name = "InvalidGrantException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidGrantException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
var InvalidRequestException = class _InvalidRequestException extends SSOOIDCServiceException {
    constructor(opts){
        super({
            name: "InvalidRequestException",
            $fault: "client",
            ...opts
        });
        this.name = "InvalidRequestException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidRequestException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.InvalidRequestException = InvalidRequestException;
var InvalidScopeException = class _InvalidScopeException extends SSOOIDCServiceException {
    constructor(opts){
        super({
            name: "InvalidScopeException",
            $fault: "client",
            ...opts
        });
        this.name = "InvalidScopeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidScopeException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.InvalidScopeException = InvalidScopeException;
var SlowDownException = class _SlowDownException extends SSOOIDCServiceException {
    constructor(opts){
        super({
            name: "SlowDownException",
            $fault: "client",
            ...opts
        });
        this.name = "SlowDownException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _SlowDownException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.SlowDownException = SlowDownException;
var UnauthorizedClientException = class _UnauthorizedClientException extends SSOOIDCServiceException {
    constructor(opts){
        super({
            name: "UnauthorizedClientException",
            $fault: "client",
            ...opts
        });
        this.name = "UnauthorizedClientException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _UnauthorizedClientException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.UnauthorizedClientException = UnauthorizedClientException;
var UnsupportedGrantTypeException = class _UnsupportedGrantTypeException extends SSOOIDCServiceException {
    constructor(opts){
        super({
            name: "UnsupportedGrantTypeException",
            $fault: "client",
            ...opts
        });
        this.name = "UnsupportedGrantTypeException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _UnsupportedGrantTypeException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
exports.UnsupportedGrantTypeException = UnsupportedGrantTypeException;
var InvalidClientMetadataException = class _InvalidClientMetadataException extends SSOOIDCServiceException {
    constructor(opts){
        super({
            name: "InvalidClientMetadataException",
            $fault: "client",
            ...opts
        });
        this.name = "InvalidClientMetadataException";
        this.$fault = "client";
        Object.setPrototypeOf(this, _InvalidClientMetadataException.prototype);
        this.error = opts.error;
        this.error_description = opts.error_description;
    }
};
var se_CreateTokenCommand = async (input, context)=>{
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json"
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}/token`;
    let body;
    body = JSON.stringify((0, smithy_client_7.take)(input, {
        clientId: [],
        clientSecret: [],
        code: [],
        deviceCode: [],
        grantType: [],
        redirectUri: [],
        refreshToken: [],
        scope: (_)=>(0, smithy_client_7._json)(_)
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body
    });
};
var se_RegisterClientCommand = async (input, context)=>{
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json"
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}/client/register`;
    let body;
    body = JSON.stringify((0, smithy_client_7.take)(input, {
        clientName: [],
        clientType: [],
        scopes: (_)=>(0, smithy_client_7._json)(_)
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body
    });
};
var se_StartDeviceAuthorizationCommand = async (input, context)=>{
    const { hostname, protocol = "https", port, path: basePath } = await context.endpoint();
    const headers = {
        "content-type": "application/json"
    };
    const resolvedPath = `${(basePath === null || basePath === void 0 ? void 0 : basePath.endsWith("/")) ? basePath.slice(0, -1) : basePath || ""}/device_authorization`;
    let body;
    body = JSON.stringify((0, smithy_client_7.take)(input, {
        clientId: [],
        clientSecret: [],
        startUrl: []
    }));
    return new protocol_http_1.HttpRequest({
        protocol,
        hostname,
        port,
        method: "POST",
        headers,
        path: resolvedPath,
        body
    });
};
var de_CreateTokenCommand = async (output, context)=>{
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_CreateTokenCommandError(output, context);
    }
    const contents = (0, smithy_client_7.map)({
        $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_7.expectNonNull)((0, smithy_client_7.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_7.take)(data, {
        accessToken: smithy_client_7.expectString,
        expiresIn: smithy_client_7.expectInt32,
        idToken: smithy_client_7.expectString,
        refreshToken: smithy_client_7.expectString,
        tokenType: smithy_client_7.expectString
    });
    Object.assign(contents, doc);
    return contents;
};
var de_CreateTokenCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "AccessDeniedException":
        case "com.amazonaws.ssooidc#AccessDeniedException":
            throw await de_AccessDeniedExceptionRes(parsedOutput, context);
        case "AuthorizationPendingException":
        case "com.amazonaws.ssooidc#AuthorizationPendingException":
            throw await de_AuthorizationPendingExceptionRes(parsedOutput, context);
        case "ExpiredTokenException":
        case "com.amazonaws.ssooidc#ExpiredTokenException":
            throw await de_ExpiredTokenExceptionRes(parsedOutput, context);
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "InvalidClientException":
        case "com.amazonaws.ssooidc#InvalidClientException":
            throw await de_InvalidClientExceptionRes(parsedOutput, context);
        case "InvalidGrantException":
        case "com.amazonaws.ssooidc#InvalidGrantException":
            throw await de_InvalidGrantExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "InvalidScopeException":
        case "com.amazonaws.ssooidc#InvalidScopeException":
            throw await de_InvalidScopeExceptionRes(parsedOutput, context);
        case "SlowDownException":
        case "com.amazonaws.ssooidc#SlowDownException":
            throw await de_SlowDownExceptionRes(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.ssooidc#UnauthorizedClientException":
            throw await de_UnauthorizedClientExceptionRes(parsedOutput, context);
        case "UnsupportedGrantTypeException":
        case "com.amazonaws.ssooidc#UnsupportedGrantTypeException":
            throw await de_UnsupportedGrantTypeExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
var de_RegisterClientCommand = async (output, context)=>{
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_RegisterClientCommandError(output, context);
    }
    const contents = (0, smithy_client_7.map)({
        $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_7.expectNonNull)((0, smithy_client_7.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_7.take)(data, {
        authorizationEndpoint: smithy_client_7.expectString,
        clientId: smithy_client_7.expectString,
        clientIdIssuedAt: smithy_client_7.expectLong,
        clientSecret: smithy_client_7.expectString,
        clientSecretExpiresAt: smithy_client_7.expectLong,
        tokenEndpoint: smithy_client_7.expectString
    });
    Object.assign(contents, doc);
    return contents;
};
var de_RegisterClientCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "InvalidClientMetadataException":
        case "com.amazonaws.ssooidc#InvalidClientMetadataException":
            throw await de_InvalidClientMetadataExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "InvalidScopeException":
        case "com.amazonaws.ssooidc#InvalidScopeException":
            throw await de_InvalidScopeExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
var de_StartDeviceAuthorizationCommand = async (output, context)=>{
    if (output.statusCode !== 200 && output.statusCode >= 300) {
        return de_StartDeviceAuthorizationCommandError(output, context);
    }
    const contents = (0, smithy_client_7.map)({
        $metadata: deserializeMetadata(output)
    });
    const data = (0, smithy_client_7.expectNonNull)((0, smithy_client_7.expectObject)(await parseBody(output.body, context)), "body");
    const doc = (0, smithy_client_7.take)(data, {
        deviceCode: smithy_client_7.expectString,
        expiresIn: smithy_client_7.expectInt32,
        interval: smithy_client_7.expectInt32,
        userCode: smithy_client_7.expectString,
        verificationUri: smithy_client_7.expectString,
        verificationUriComplete: smithy_client_7.expectString
    });
    Object.assign(contents, doc);
    return contents;
};
var de_StartDeviceAuthorizationCommandError = async (output, context)=>{
    const parsedOutput = {
        ...output,
        body: await parseErrorBody(output.body, context)
    };
    const errorCode = loadRestJsonErrorCode(output, parsedOutput.body);
    switch(errorCode){
        case "InternalServerException":
        case "com.amazonaws.ssooidc#InternalServerException":
            throw await de_InternalServerExceptionRes(parsedOutput, context);
        case "InvalidClientException":
        case "com.amazonaws.ssooidc#InvalidClientException":
            throw await de_InvalidClientExceptionRes(parsedOutput, context);
        case "InvalidRequestException":
        case "com.amazonaws.ssooidc#InvalidRequestException":
            throw await de_InvalidRequestExceptionRes(parsedOutput, context);
        case "SlowDownException":
        case "com.amazonaws.ssooidc#SlowDownException":
            throw await de_SlowDownExceptionRes(parsedOutput, context);
        case "UnauthorizedClientException":
        case "com.amazonaws.ssooidc#UnauthorizedClientException":
            throw await de_UnauthorizedClientExceptionRes(parsedOutput, context);
        default:
            const parsedBody = parsedOutput.body;
            return throwDefaultError({
                output,
                parsedBody,
                errorCode
            });
    }
};
var throwDefaultError = (0, smithy_client_7.withBaseException)(SSOOIDCServiceException);
var de_AccessDeniedExceptionRes = async (parsedOutput, context)=>{
    const contents = (0, smithy_client_7.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_7.take)(data, {
        error: smithy_client_7.expectString,
        error_description: smithy_client_7.expectString
    });
    Object.assign(contents, doc);
    const exception = new AccessDeniedException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
    });
    return (0, smithy_client_7.decorateServiceException)(exception, parsedOutput.body);
};
var de_AuthorizationPendingExceptionRes = async (parsedOutput, context)=>{
    const contents = (0, smithy_client_7.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_7.take)(data, {
        error: smithy_client_7.expectString,
        error_description: smithy_client_7.expectString
    });
    Object.assign(contents, doc);
    const exception = new AuthorizationPendingException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
    });
    return (0, smithy_client_7.decorateServiceException)(exception, parsedOutput.body);
};
var de_ExpiredTokenExceptionRes = async (parsedOutput, context)=>{
    const contents = (0, smithy_client_7.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_7.take)(data, {
        error: smithy_client_7.expectString,
        error_description: smithy_client_7.expectString
    });
    Object.assign(contents, doc);
    const exception = new ExpiredTokenException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
    });
    return (0, smithy_client_7.decorateServiceException)(exception, parsedOutput.body);
};
var de_InternalServerExceptionRes = async (parsedOutput, context)=>{
    const contents = (0, smithy_client_7.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_7.take)(data, {
        error: smithy_client_7.expectString,
        error_description: smithy_client_7.expectString
    });
    Object.assign(contents, doc);
    const exception = new InternalServerException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
    });
    return (0, smithy_client_7.decorateServiceException)(exception, parsedOutput.body);
};
var de_InvalidClientExceptionRes = async (parsedOutput, context)=>{
    const contents = (0, smithy_client_7.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_7.take)(data, {
        error: smithy_client_7.expectString,
        error_description: smithy_client_7.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidClientException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
    });
    return (0, smithy_client_7.decorateServiceException)(exception, parsedOutput.body);
};
var de_InvalidClientMetadataExceptionRes = async (parsedOutput, context)=>{
    const contents = (0, smithy_client_7.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_7.take)(data, {
        error: smithy_client_7.expectString,
        error_description: smithy_client_7.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidClientMetadataException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
    });
    return (0, smithy_client_7.decorateServiceException)(exception, parsedOutput.body);
};
var de_InvalidGrantExceptionRes = async (parsedOutput, context)=>{
    const contents = (0, smithy_client_7.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_7.take)(data, {
        error: smithy_client_7.expectString,
        error_description: smithy_client_7.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidGrantException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
    });
    return (0, smithy_client_7.decorateServiceException)(exception, parsedOutput.body);
};
var de_InvalidRequestExceptionRes = async (parsedOutput, context)=>{
    const contents = (0, smithy_client_7.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_7.take)(data, {
        error: smithy_client_7.expectString,
        error_description: smithy_client_7.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidRequestException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
    });
    return (0, smithy_client_7.decorateServiceException)(exception, parsedOutput.body);
};
var de_InvalidScopeExceptionRes = async (parsedOutput, context)=>{
    const contents = (0, smithy_client_7.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_7.take)(data, {
        error: smithy_client_7.expectString,
        error_description: smithy_client_7.expectString
    });
    Object.assign(contents, doc);
    const exception = new InvalidScopeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
    });
    return (0, smithy_client_7.decorateServiceException)(exception, parsedOutput.body);
};
var de_SlowDownExceptionRes = async (parsedOutput, context)=>{
    const contents = (0, smithy_client_7.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_7.take)(data, {
        error: smithy_client_7.expectString,
        error_description: smithy_client_7.expectString
    });
    Object.assign(contents, doc);
    const exception = new SlowDownException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
    });
    return (0, smithy_client_7.decorateServiceException)(exception, parsedOutput.body);
};
var de_UnauthorizedClientExceptionRes = async (parsedOutput, context)=>{
    const contents = (0, smithy_client_7.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_7.take)(data, {
        error: smithy_client_7.expectString,
        error_description: smithy_client_7.expectString
    });
    Object.assign(contents, doc);
    const exception = new UnauthorizedClientException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
    });
    return (0, smithy_client_7.decorateServiceException)(exception, parsedOutput.body);
};
var de_UnsupportedGrantTypeExceptionRes = async (parsedOutput, context)=>{
    const contents = (0, smithy_client_7.map)({});
    const data = parsedOutput.body;
    const doc = (0, smithy_client_7.take)(data, {
        error: smithy_client_7.expectString,
        error_description: smithy_client_7.expectString
    });
    Object.assign(contents, doc);
    const exception = new UnsupportedGrantTypeException({
        $metadata: deserializeMetadata(parsedOutput),
        ...contents
    });
    return (0, smithy_client_7.decorateServiceException)(exception, parsedOutput.body);
};
var deserializeMetadata = (output)=>{
    var _a, _b;
    return {
        httpStatusCode: output.statusCode,
        requestId: (_b = (_a = output.headers["x-amzn-requestid"]) !== null && _a !== void 0 ? _a : output.headers["x-amzn-request-id"]) !== null && _b !== void 0 ? _b : output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"]
    };
};
var collectBodyString = (streamBody, context)=>(0, smithy_client_7.collectBody)(streamBody, context).then((body)=>context.utf8Encoder(body));
var parseBody = (streamBody, context)=>collectBodyString(streamBody, context).then((encoded)=>{
        if (encoded.length) {
            return JSON.parse(encoded);
        }
        return {};
    });
var parseErrorBody = async (errorBody, context)=>{
    var _a;
    const value = await parseBody(errorBody, context);
    value.message = (_a = value.message) !== null && _a !== void 0 ? _a : value.Message;
    return value;
};
var loadRestJsonErrorCode = (output, data)=>{
    const findKey = (object, key)=>Object.keys(object).find((k2)=>k2.toLowerCase() === key.toLowerCase());
    const sanitizeErrorCode = (rawValue)=>{
        let cleanValue = rawValue;
        if (typeof cleanValue === "number") {
            cleanValue = cleanValue.toString();
        }
        if (cleanValue.indexOf(",") >= 0) {
            cleanValue = cleanValue.split(",")[0];
        }
        if (cleanValue.indexOf(":") >= 0) {
            cleanValue = cleanValue.split(":")[0];
        }
        if (cleanValue.indexOf("#") >= 0) {
            cleanValue = cleanValue.split("#")[1];
        }
        return cleanValue;
    };
    const headerKey = findKey(output.headers, "x-amzn-errortype");
    if (headerKey !== void 0) {
        return sanitizeErrorCode(output.headers[headerKey]);
    }
    if (data.code !== void 0) {
        return sanitizeErrorCode(data.code);
    }
    if (data["__type"] !== void 0) {
        return sanitizeErrorCode(data["__type"]);
    }
};
var CreateTokenCommand = class _CreateTokenCommand extends smithy_client_6.Command {
    constructor(input){
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_1.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_2.getEndpointPlugin)(configuration, _CreateTokenCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOOIDCClient";
        const commandName = "CreateTokenCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return se_CreateTokenCommand(input, context);
    }
    deserialize(output, context) {
        return de_CreateTokenCommand(output, context);
    }
};
exports.CreateTokenCommand = CreateTokenCommand;
const middleware_endpoint_3 = __webpack_require__(33692);
const middleware_serde_2 = __webpack_require__(22406);
const smithy_client_9 = __webpack_require__(18851);
var RegisterClientCommand = class _RegisterClientCommand extends smithy_client_9.Command {
    constructor(input){
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_2.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_3.getEndpointPlugin)(configuration, _RegisterClientCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOOIDCClient";
        const commandName = "RegisterClientCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return se_RegisterClientCommand(input, context);
    }
    deserialize(output, context) {
        return de_RegisterClientCommand(output, context);
    }
};
const middleware_endpoint_4 = __webpack_require__(33692);
const middleware_serde_3 = __webpack_require__(22406);
const smithy_client_10 = __webpack_require__(18851);
var StartDeviceAuthorizationCommand = class _StartDeviceAuthorizationCommand extends smithy_client_10.Command {
    constructor(input){
        super();
        this.input = input;
    }
    static getEndpointParameterInstructions() {
        return {
            UseFIPS: {
                type: "builtInParams",
                name: "useFipsEndpoint"
            },
            Endpoint: {
                type: "builtInParams",
                name: "endpoint"
            },
            Region: {
                type: "builtInParams",
                name: "region"
            },
            UseDualStack: {
                type: "builtInParams",
                name: "useDualstackEndpoint"
            }
        };
    }
    resolveMiddleware(clientStack, configuration, options) {
        this.middlewareStack.use((0, middleware_serde_3.getSerdePlugin)(configuration, this.serialize, this.deserialize));
        this.middlewareStack.use((0, middleware_endpoint_4.getEndpointPlugin)(configuration, _StartDeviceAuthorizationCommand.getEndpointParameterInstructions()));
        const stack = clientStack.concat(this.middlewareStack);
        const { logger } = configuration;
        const clientName = "SSOOIDCClient";
        const commandName = "StartDeviceAuthorizationCommand";
        const handlerExecutionContext = {
            logger,
            clientName,
            commandName,
            inputFilterSensitiveLog: (_)=>_,
            outputFilterSensitiveLog: (_)=>_
        };
        const { requestHandler } = configuration;
        return stack.resolve((request)=>requestHandler.handle(request.request, options || {}), handlerExecutionContext);
    }
    serialize(input, context) {
        return se_StartDeviceAuthorizationCommand(input, context);
    }
    deserialize(output, context) {
        return de_StartDeviceAuthorizationCommand(output, context);
    }
};
var commands = {
    CreateTokenCommand,
    RegisterClientCommand,
    StartDeviceAuthorizationCommand
};
var SSOOIDC = class extends SSOOIDCClient {
};
(0, smithy_client_5.createAggregatedClient)(commands, SSOOIDC);


/***/ }),

/***/ 99337:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.REFRESH_MESSAGE = exports.EXPIRE_WINDOW_MS = void 0;
exports.EXPIRE_WINDOW_MS = 5 * 60 * 1000;
exports.REFRESH_MESSAGE = `To refresh this SSO session run 'aws sso login' with the corresponding profile.`;


/***/ }),

/***/ 22283:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromSso = void 0;
const property_provider_1 = __webpack_require__(29852);
const shared_ini_file_loader_1 = __webpack_require__(3666);
const constants_1 = __webpack_require__(99337);
const getNewSsoOidcToken_1 = __webpack_require__(319);
const validateTokenExpiry_1 = __webpack_require__(75259);
const validateTokenKey_1 = __webpack_require__(63345);
const writeSSOTokenToFile_1 = __webpack_require__(49233);
const lastRefreshAttemptTime = new Date(0);
const fromSso = (init = {})=>async ()=>{
        const profiles = await (0, shared_ini_file_loader_1.parseKnownFiles)(init);
        const profileName = (0, shared_ini_file_loader_1.getProfileName)(init);
        const profile = profiles[profileName];
        if (!profile) {
            throw new property_provider_1.TokenProviderError(`Profile '${profileName}' could not be found in shared credentials file.`, false);
        } else if (!profile["sso_session"]) {
            throw new property_provider_1.TokenProviderError(`Profile '${profileName}' is missing required property 'sso_session'.`);
        }
        const ssoSessionName = profile["sso_session"];
        const ssoSessions = await (0, shared_ini_file_loader_1.loadSsoSessionData)(init);
        const ssoSession = ssoSessions[ssoSessionName];
        if (!ssoSession) {
            throw new property_provider_1.TokenProviderError(`Sso session '${ssoSessionName}' could not be found in shared credentials file.`, false);
        }
        for (const ssoSessionRequiredKey of [
            "sso_start_url",
            "sso_region"
        ]){
            if (!ssoSession[ssoSessionRequiredKey]) {
                throw new property_provider_1.TokenProviderError(`Sso session '${ssoSessionName}' is missing required property '${ssoSessionRequiredKey}'.`, false);
            }
        }
        const ssoStartUrl = ssoSession["sso_start_url"];
        const ssoRegion = ssoSession["sso_region"];
        let ssoToken;
        try {
            ssoToken = await (0, shared_ini_file_loader_1.getSSOTokenFromFile)(ssoSessionName);
        } catch (e) {
            throw new property_provider_1.TokenProviderError(`The SSO session token associated with profile=${profileName} was not found or is invalid. ${constants_1.REFRESH_MESSAGE}`, false);
        }
        (0, validateTokenKey_1.validateTokenKey)("accessToken", ssoToken.accessToken);
        (0, validateTokenKey_1.validateTokenKey)("expiresAt", ssoToken.expiresAt);
        const { accessToken, expiresAt } = ssoToken;
        const existingToken = {
            token: accessToken,
            expiration: new Date(expiresAt)
        };
        if (existingToken.expiration.getTime() - Date.now() > constants_1.EXPIRE_WINDOW_MS) {
            return existingToken;
        }
        if (Date.now() - lastRefreshAttemptTime.getTime() < 30 * 1000) {
            (0, validateTokenExpiry_1.validateTokenExpiry)(existingToken);
            return existingToken;
        }
        (0, validateTokenKey_1.validateTokenKey)("clientId", ssoToken.clientId, true);
        (0, validateTokenKey_1.validateTokenKey)("clientSecret", ssoToken.clientSecret, true);
        (0, validateTokenKey_1.validateTokenKey)("refreshToken", ssoToken.refreshToken, true);
        try {
            lastRefreshAttemptTime.setTime(Date.now());
            const newSsoOidcToken = await (0, getNewSsoOidcToken_1.getNewSsoOidcToken)(ssoToken, ssoRegion);
            (0, validateTokenKey_1.validateTokenKey)("accessToken", newSsoOidcToken.accessToken);
            (0, validateTokenKey_1.validateTokenKey)("expiresIn", newSsoOidcToken.expiresIn);
            const newTokenExpiration = new Date(Date.now() + newSsoOidcToken.expiresIn * 1000);
            try {
                await (0, writeSSOTokenToFile_1.writeSSOTokenToFile)(ssoSessionName, {
                    ...ssoToken,
                    accessToken: newSsoOidcToken.accessToken,
                    expiresAt: newTokenExpiration.toISOString(),
                    refreshToken: newSsoOidcToken.refreshToken
                });
            } catch (error) {}
            return {
                token: newSsoOidcToken.accessToken,
                expiration: newTokenExpiration
            };
        } catch (error) {
            (0, validateTokenExpiry_1.validateTokenExpiry)(existingToken);
            return existingToken;
        }
    };
exports.fromSso = fromSso;


/***/ }),

/***/ 31375:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromStatic = void 0;
const property_provider_1 = __webpack_require__(29852);
const fromStatic = ({ token })=>async ()=>{
        if (!token || !token.token) {
            throw new property_provider_1.TokenProviderError(`Please pass a valid token to fromStatic`, false);
        }
        return token;
    };
exports.fromStatic = fromStatic;


/***/ }),

/***/ 319:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getNewSsoOidcToken = void 0;
const client_sso_oidc_node_1 = __webpack_require__(53597);
const getSsoOidcClient_1 = __webpack_require__(76132);
const getNewSsoOidcToken = (ssoToken, ssoRegion)=>{
    const ssoOidcClient = (0, getSsoOidcClient_1.getSsoOidcClient)(ssoRegion);
    return ssoOidcClient.send(new client_sso_oidc_node_1.CreateTokenCommand({
        clientId: ssoToken.clientId,
        clientSecret: ssoToken.clientSecret,
        refreshToken: ssoToken.refreshToken,
        grantType: "refresh_token"
    }));
};
exports.getNewSsoOidcToken = getNewSsoOidcToken;


/***/ }),

/***/ 76132:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getSsoOidcClient = void 0;
const client_sso_oidc_node_1 = __webpack_require__(53597);
const ssoOidcClientsHash = {};
const getSsoOidcClient = (ssoRegion)=>{
    if (ssoOidcClientsHash[ssoRegion]) {
        return ssoOidcClientsHash[ssoRegion];
    }
    const ssoOidcClient = new client_sso_oidc_node_1.SSOOIDCClient({
        region: ssoRegion
    });
    ssoOidcClientsHash[ssoRegion] = ssoOidcClient;
    return ssoOidcClient;
};
exports.getSsoOidcClient = getSsoOidcClient;


/***/ }),

/***/ 47388:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(53597), exports);
tslib_1.__exportStar(__webpack_require__(22283), exports);
tslib_1.__exportStar(__webpack_require__(31375), exports);
tslib_1.__exportStar(__webpack_require__(88850), exports);


/***/ }),

/***/ 88850:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.nodeProvider = void 0;
const property_provider_1 = __webpack_require__(29852);
const fromSso_1 = __webpack_require__(22283);
const nodeProvider = (init = {})=>(0, property_provider_1.memoize)((0, property_provider_1.chain)((0, fromSso_1.fromSso)(init), async ()=>{
        throw new property_provider_1.TokenProviderError("Could not load token from any providers", false);
    }), (token)=>token.expiration !== undefined && token.expiration.getTime() - Date.now() < 300000, (token)=>token.expiration !== undefined);
exports.nodeProvider = nodeProvider;


/***/ }),

/***/ 75259:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.validateTokenExpiry = void 0;
const property_provider_1 = __webpack_require__(29852);
const constants_1 = __webpack_require__(99337);
const validateTokenExpiry = (token)=>{
    if (token.expiration && token.expiration.getTime() < Date.now()) {
        throw new property_provider_1.TokenProviderError(`Token is expired. ${constants_1.REFRESH_MESSAGE}`, false);
    }
};
exports.validateTokenExpiry = validateTokenExpiry;


/***/ }),

/***/ 63345:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.validateTokenKey = void 0;
const property_provider_1 = __webpack_require__(29852);
const constants_1 = __webpack_require__(99337);
const validateTokenKey = (key, value, forRefresh = false)=>{
    if (typeof value === "undefined") {
        throw new property_provider_1.TokenProviderError(`Value not present for '${key}' in SSO Token${forRefresh ? ". Cannot refresh" : ""}. ${constants_1.REFRESH_MESSAGE}`, false);
    }
};
exports.validateTokenKey = validateTokenKey;


/***/ }),

/***/ 49233:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.writeSSOTokenToFile = void 0;
const shared_ini_file_loader_1 = __webpack_require__(3666);
const fs_1 = __webpack_require__(57147);
const { writeFile } = fs_1.promises;
const writeSSOTokenToFile = (id, ssoToken)=>{
    const tokenFilepath = (0, shared_ini_file_loader_1.getSSOTokenFilepath)(id);
    const tokenString = JSON.stringify(ssoToken, null, 2);
    return writeFile(tokenFilepath, tokenString);
};
exports.writeSSOTokenToFile = writeSSOTokenToFile;


/***/ }),

/***/ 77733:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 98052:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.HttpAuthLocation = void 0;
var types_1 = __webpack_require__(46754);
Object.defineProperty(exports, "HttpAuthLocation", ({
    enumerable: true,
    get: function() {
        return types_1.HttpAuthLocation;
    }
}));


/***/ }),

/***/ 15289:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 99824:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 35710:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 24455:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 78462:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 35519:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 71887:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 85462:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.HostAddressType = void 0;
var HostAddressType;
(function(HostAddressType) {
    HostAddressType["AAAA"] = "AAAA";
    HostAddressType["A"] = "A";
})(HostAddressType = exports.HostAddressType || (exports.HostAddressType = {}));


/***/ }),

/***/ 64075:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 94406:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.EndpointURLScheme = void 0;
var types_1 = __webpack_require__(46754);
Object.defineProperty(exports, "EndpointURLScheme", ({
    enumerable: true,
    get: function() {
        return types_1.EndpointURLScheme;
    }
}));


/***/ }),

/***/ 16085:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 44663:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 82727:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 73944:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 8498:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 78776:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 70894:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 31548:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(82727), exports);
tslib_1.__exportStar(__webpack_require__(73944), exports);
tslib_1.__exportStar(__webpack_require__(8498), exports);
tslib_1.__exportStar(__webpack_require__(78776), exports);
tslib_1.__exportStar(__webpack_require__(70894), exports);


/***/ }),

/***/ 18414:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(77733), exports);
tslib_1.__exportStar(__webpack_require__(98052), exports);
tslib_1.__exportStar(__webpack_require__(15289), exports);
tslib_1.__exportStar(__webpack_require__(99824), exports);
tslib_1.__exportStar(__webpack_require__(35710), exports);
tslib_1.__exportStar(__webpack_require__(24455), exports);
tslib_1.__exportStar(__webpack_require__(78462), exports);
tslib_1.__exportStar(__webpack_require__(35519), exports);
tslib_1.__exportStar(__webpack_require__(71887), exports);
tslib_1.__exportStar(__webpack_require__(85462), exports);
tslib_1.__exportStar(__webpack_require__(64075), exports);
tslib_1.__exportStar(__webpack_require__(94406), exports);
tslib_1.__exportStar(__webpack_require__(16085), exports);
tslib_1.__exportStar(__webpack_require__(44663), exports);
tslib_1.__exportStar(__webpack_require__(31548), exports);
tslib_1.__exportStar(__webpack_require__(60424), exports);
tslib_1.__exportStar(__webpack_require__(55488), exports);
tslib_1.__exportStar(__webpack_require__(85619), exports);
tslib_1.__exportStar(__webpack_require__(32589), exports);
tslib_1.__exportStar(__webpack_require__(34007), exports);
tslib_1.__exportStar(__webpack_require__(58009), exports);
tslib_1.__exportStar(__webpack_require__(79233), exports);
tslib_1.__exportStar(__webpack_require__(15751), exports);
tslib_1.__exportStar(__webpack_require__(7020), exports);
tslib_1.__exportStar(__webpack_require__(27657), exports);
tslib_1.__exportStar(__webpack_require__(38242), exports);
tslib_1.__exportStar(__webpack_require__(770), exports);
tslib_1.__exportStar(__webpack_require__(67799), exports);
tslib_1.__exportStar(__webpack_require__(69399), exports);
tslib_1.__exportStar(__webpack_require__(21761), exports);
tslib_1.__exportStar(__webpack_require__(40257), exports);


/***/ }),

/***/ 60424:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 55488:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 85619:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 32589:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 34007:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 58009:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 79233:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 15751:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 7020:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 27657:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 38242:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 770:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 67799:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.RequestHandlerProtocol = void 0;
var types_1 = __webpack_require__(46754);
Object.defineProperty(exports, "RequestHandlerProtocol", ({
    enumerable: true,
    get: function() {
        return types_1.RequestHandlerProtocol;
    }
}));


/***/ }),

/***/ 69399:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 21761:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 40257:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 62457:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.debugId = void 0;
exports.debugId = "endpoints";


/***/ }),

/***/ 90857:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(62457), exports);
tslib_1.__exportStar(__webpack_require__(34004), exports);


/***/ }),

/***/ 34004:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.toDebugString = void 0;
function toDebugString(input) {
    if (typeof input !== "object" || input == null) {
        return input;
    }
    if ("ref" in input) {
        return `$${toDebugString(input.ref)}`;
    }
    if ("fn" in input) {
        return `${input.fn}(${(input.argv || []).map(toDebugString).join(", ")})`;
    }
    return JSON.stringify(input, null, 2);
}
exports.toDebugString = toDebugString;


/***/ }),

/***/ 8059:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(97021), exports);
tslib_1.__exportStar(__webpack_require__(23621), exports);
tslib_1.__exportStar(__webpack_require__(17447), exports);
tslib_1.__exportStar(__webpack_require__(32258), exports);


/***/ }),

/***/ 80672:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(25045), exports);
tslib_1.__exportStar(__webpack_require__(1863), exports);
tslib_1.__exportStar(__webpack_require__(97021), exports);


/***/ }),

/***/ 25045:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isVirtualHostableS3Bucket = void 0;
const isIpAddress_1 = __webpack_require__(23621);
const isValidHostLabel_1 = __webpack_require__(54172);
const isVirtualHostableS3Bucket = (value, allowSubDomains = false)=>{
    if (allowSubDomains) {
        for (const label of value.split(".")){
            if (!(0, exports.isVirtualHostableS3Bucket)(label)) {
                return false;
            }
        }
        return true;
    }
    if (!(0, isValidHostLabel_1.isValidHostLabel)(value)) {
        return false;
    }
    if (value.length < 3 || value.length > 63) {
        return false;
    }
    if (value !== value.toLowerCase()) {
        return false;
    }
    if ((0, isIpAddress_1.isIpAddress)(value)) {
        return false;
    }
    return true;
};
exports.isVirtualHostableS3Bucket = isVirtualHostableS3Bucket;


/***/ }),

/***/ 1863:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parseArn = void 0;
const parseArn = (value)=>{
    const segments = value.split(":");
    if (segments.length < 6) return null;
    const [arn, partition, service, region, accountId, ...resourceId] = segments;
    if (arn !== "arn" || partition === "" || service === "" || resourceId[0] === "") return null;
    return {
        partition,
        service,
        region,
        accountId,
        resourceId: resourceId[0].includes("/") ? resourceId[0].split("/") : resourceId
    };
};
exports.parseArn = parseArn;


/***/ }),

/***/ 97021:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getUserAgentPrefix = exports.useDefaultPartitionInfo = exports.setPartitionInfo = exports.partition = void 0;
const tslib_1 = __webpack_require__(35092);
const partitions_json_1 = tslib_1.__importDefault(__webpack_require__(22385));
let selectedPartitionsInfo = partitions_json_1.default;
let selectedUserAgentPrefix = "";
const partition = (value)=>{
    const { partitions } = selectedPartitionsInfo;
    for (const partition of partitions){
        const { regions, outputs } = partition;
        for (const [region, regionData] of Object.entries(regions)){
            if (region === value) {
                return {
                    ...outputs,
                    ...regionData
                };
            }
        }
    }
    for (const partition of partitions){
        const { regionRegex, outputs } = partition;
        if (new RegExp(regionRegex).test(value)) {
            return {
                ...outputs
            };
        }
    }
    const DEFAULT_PARTITION = partitions.find((partition)=>partition.id === "aws");
    if (!DEFAULT_PARTITION) {
        throw new Error("Provided region was not found in the partition array or regex," + " and default partition with id 'aws' doesn't exist.");
    }
    return {
        ...DEFAULT_PARTITION.outputs
    };
};
exports.partition = partition;
const setPartitionInfo = (partitionsInfo, userAgentPrefix = "")=>{
    selectedPartitionsInfo = partitionsInfo;
    selectedUserAgentPrefix = userAgentPrefix;
};
exports.setPartitionInfo = setPartitionInfo;
const useDefaultPartitionInfo = ()=>{
    (0, exports.setPartitionInfo)(partitions_json_1.default, "");
};
exports.useDefaultPartitionInfo = useDefaultPartitionInfo;
const getUserAgentPrefix = ()=>selectedUserAgentPrefix;
exports.getUserAgentPrefix = getUserAgentPrefix;


/***/ }),

/***/ 61420:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.booleanEquals = void 0;
const booleanEquals = (value1, value2)=>value1 === value2;
exports.booleanEquals = booleanEquals;


/***/ }),

/***/ 34451:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getAttr = void 0;
const types_1 = __webpack_require__(32258);
const getAttrPathList_1 = __webpack_require__(6392);
const getAttr = (value, path)=>(0, getAttrPathList_1.getAttrPathList)(path).reduce((acc, index)=>{
        if (typeof acc !== "object") {
            throw new types_1.EndpointError(`Index '${index}' in '${path}' not found in '${JSON.stringify(value)}'`);
        } else if (Array.isArray(acc)) {
            return acc[parseInt(index)];
        }
        return acc[index];
    }, value);
exports.getAttr = getAttr;


/***/ }),

/***/ 6392:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getAttrPathList = void 0;
const types_1 = __webpack_require__(32258);
const getAttrPathList = (path)=>{
    const parts = path.split(".");
    const pathList = [];
    for (const part of parts){
        const squareBracketIndex = part.indexOf("[");
        if (squareBracketIndex !== -1) {
            if (part.indexOf("]") !== part.length - 1) {
                throw new types_1.EndpointError(`Path: '${path}' does not end with ']'`);
            }
            const arrayIndex = part.slice(squareBracketIndex + 1, -1);
            if (Number.isNaN(parseInt(arrayIndex))) {
                throw new types_1.EndpointError(`Invalid array index: '${arrayIndex}' in path: '${path}'`);
            }
            if (squareBracketIndex !== 0) {
                pathList.push(part.slice(0, squareBracketIndex));
            }
            pathList.push(arrayIndex);
        } else {
            pathList.push(part);
        }
    }
    return pathList;
};
exports.getAttrPathList = getAttrPathList;


/***/ }),

/***/ 26819:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.aws = void 0;
const tslib_1 = __webpack_require__(35092);
exports.aws = tslib_1.__importStar(__webpack_require__(80672));
tslib_1.__exportStar(__webpack_require__(61420), exports);
tslib_1.__exportStar(__webpack_require__(34451), exports);
tslib_1.__exportStar(__webpack_require__(30615), exports);
tslib_1.__exportStar(__webpack_require__(54172), exports);
tslib_1.__exportStar(__webpack_require__(85499), exports);
tslib_1.__exportStar(__webpack_require__(11108), exports);
tslib_1.__exportStar(__webpack_require__(76305), exports);
tslib_1.__exportStar(__webpack_require__(86371), exports);
tslib_1.__exportStar(__webpack_require__(87612), exports);


/***/ }),

/***/ 23621:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isIpAddress = void 0;
const IP_V4_REGEX = new RegExp(`^(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)(?:\\.(?:25[0-5]|2[0-4]\\d|1\\d\\d|[1-9]\\d|\\d)){3}$`);
const isIpAddress = (value)=>IP_V4_REGEX.test(value) || value.startsWith("[") && value.endsWith("]");
exports.isIpAddress = isIpAddress;


/***/ }),

/***/ 30615:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isSet = void 0;
const isSet = (value)=>value != null;
exports.isSet = isSet;


/***/ }),

/***/ 54172:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isValidHostLabel = void 0;
const VALID_HOST_LABEL_REGEX = new RegExp(`^(?!.*-$)(?!-)[a-zA-Z0-9-]{1,63}$`);
const isValidHostLabel = (value, allowSubDomains = false)=>{
    if (!allowSubDomains) {
        return VALID_HOST_LABEL_REGEX.test(value);
    }
    const labels = value.split(".");
    for (const label of labels){
        if (!(0, exports.isValidHostLabel)(label)) {
            return false;
        }
    }
    return true;
};
exports.isValidHostLabel = isValidHostLabel;


/***/ }),

/***/ 85499:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.not = void 0;
const not = (value)=>!value;
exports.not = not;


/***/ }),

/***/ 11108:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parseURL = void 0;
const types_1 = __webpack_require__(18414);
const isIpAddress_1 = __webpack_require__(23621);
const DEFAULT_PORTS = {
    [types_1.EndpointURLScheme.HTTP]: 80,
    [types_1.EndpointURLScheme.HTTPS]: 443
};
const parseURL = (value)=>{
    const whatwgURL = (()=>{
        try {
            if (value instanceof URL) {
                return value;
            }
            if (typeof value === "object" && "hostname" in value) {
                const { hostname, port, protocol = "", path = "", query = {} } = value;
                const url = new URL(`${protocol}//${hostname}${port ? `:${port}` : ""}${path}`);
                url.search = Object.entries(query).map(([k, v])=>`${k}=${v}`).join("&");
                return url;
            }
            return new URL(value);
        } catch (error) {
            return null;
        }
    })();
    if (!whatwgURL) {
        console.error(`Unable to parse ${JSON.stringify(value)} as a whatwg URL.`);
        return null;
    }
    const urlString = whatwgURL.href;
    const { host, hostname, pathname, protocol, search } = whatwgURL;
    if (search) {
        return null;
    }
    const scheme = protocol.slice(0, -1);
    if (!Object.values(types_1.EndpointURLScheme).includes(scheme)) {
        return null;
    }
    const isIp = (0, isIpAddress_1.isIpAddress)(hostname);
    const inputContainsDefaultPort = urlString.includes(`${host}:${DEFAULT_PORTS[scheme]}`) || typeof value === "string" && value.includes(`${host}:${DEFAULT_PORTS[scheme]}`);
    const authority = `${host}${inputContainsDefaultPort ? `:${DEFAULT_PORTS[scheme]}` : ``}`;
    return {
        scheme,
        authority,
        path: pathname,
        normalizedPath: pathname.endsWith("/") ? pathname : `${pathname}/`,
        isIp
    };
};
exports.parseURL = parseURL;


/***/ }),

/***/ 76305:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.stringEquals = void 0;
const stringEquals = (value1, value2)=>value1 === value2;
exports.stringEquals = stringEquals;


/***/ }),

/***/ 86371:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.substring = void 0;
const substring = (input, start, stop, reverse)=>{
    if (start >= stop || input.length < stop) {
        return null;
    }
    if (!reverse) {
        return input.substring(start, stop);
    }
    return input.substring(input.length - stop, input.length - start);
};
exports.substring = substring;


/***/ }),

/***/ 87612:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.uriEncode = void 0;
const uriEncode = (value)=>encodeURIComponent(value).replace(/[!*'()]/g, (c)=>`%${c.charCodeAt(0).toString(16).toUpperCase()}`);
exports.uriEncode = uriEncode;


/***/ }),

/***/ 17447:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveEndpoint = void 0;
const debug_1 = __webpack_require__(90857);
const types_1 = __webpack_require__(32258);
const utils_1 = __webpack_require__(23659);
const resolveEndpoint = (ruleSetObject, options)=>{
    var _a, _b, _c, _d, _e, _f;
    const { endpointParams, logger } = options;
    const { parameters, rules } = ruleSetObject;
    (_b = (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, `${debug_1.debugId} Initial EndpointParams: ${(0, debug_1.toDebugString)(endpointParams)}`);
    const paramsWithDefault = Object.entries(parameters).filter(([, v])=>v.default != null).map(([k, v])=>[
            k,
            v.default
        ]);
    if (paramsWithDefault.length > 0) {
        for (const [paramKey, paramDefaultValue] of paramsWithDefault){
            endpointParams[paramKey] = (_c = endpointParams[paramKey]) !== null && _c !== void 0 ? _c : paramDefaultValue;
        }
    }
    const requiredParams = Object.entries(parameters).filter(([, v])=>v.required).map(([k])=>k);
    for (const requiredParam of requiredParams){
        if (endpointParams[requiredParam] == null) {
            throw new types_1.EndpointError(`Missing required parameter: '${requiredParam}'`);
        }
    }
    const endpoint = (0, utils_1.evaluateRules)(rules, {
        endpointParams,
        logger,
        referenceRecord: {}
    });
    if ((_d = options.endpointParams) === null || _d === void 0 ? void 0 : _d.Endpoint) {
        try {
            const givenEndpoint = new URL(options.endpointParams.Endpoint);
            const { protocol, port } = givenEndpoint;
            endpoint.url.protocol = protocol;
            endpoint.url.port = port;
        } catch (e) {}
    }
    (_f = (_e = options.logger) === null || _e === void 0 ? void 0 : _e.debug) === null || _f === void 0 ? void 0 : _f.call(_e, `${debug_1.debugId} Resolved endpoint: ${(0, debug_1.toDebugString)(endpoint)}`);
    return endpoint;
};
exports.resolveEndpoint = resolveEndpoint;


/***/ }),

/***/ 21568:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.EndpointError = void 0;
class EndpointError extends Error {
    constructor(message){
        super(message);
        this.name = "EndpointError";
    }
}
exports.EndpointError = EndpointError;


/***/ }),

/***/ 27410:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 41775:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 78976:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 62028:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 32258:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(21568), exports);
tslib_1.__exportStar(__webpack_require__(27410), exports);
tslib_1.__exportStar(__webpack_require__(41775), exports);
tslib_1.__exportStar(__webpack_require__(78976), exports);
tslib_1.__exportStar(__webpack_require__(62028), exports);
tslib_1.__exportStar(__webpack_require__(30607), exports);


/***/ }),

/***/ 30607:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 89890:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.callFunction = void 0;
const tslib_1 = __webpack_require__(35092);
const lib = tslib_1.__importStar(__webpack_require__(26819));
const evaluateExpression_1 = __webpack_require__(84021);
const callFunction = ({ fn, argv }, options)=>{
    const evaluatedArgs = argv.map((arg)=>[
            "boolean",
            "number"
        ].includes(typeof arg) ? arg : (0, evaluateExpression_1.evaluateExpression)(arg, "arg", options));
    return fn.split(".").reduce((acc, key)=>acc[key], lib)(...evaluatedArgs);
};
exports.callFunction = callFunction;


/***/ }),

/***/ 20835:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.evaluateCondition = void 0;
const debug_1 = __webpack_require__(90857);
const types_1 = __webpack_require__(32258);
const callFunction_1 = __webpack_require__(89890);
const evaluateCondition = ({ assign, ...fnArgs }, options)=>{
    var _a, _b;
    if (assign && assign in options.referenceRecord) {
        throw new types_1.EndpointError(`'${assign}' is already defined in Reference Record.`);
    }
    const value = (0, callFunction_1.callFunction)(fnArgs, options);
    (_b = (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, debug_1.debugId, `evaluateCondition: ${(0, debug_1.toDebugString)(fnArgs)} = ${(0, debug_1.toDebugString)(value)}`);
    return {
        result: value === "" ? true : !!value,
        ...assign != null && {
            toAssign: {
                name: assign,
                value
            }
        }
    };
};
exports.evaluateCondition = evaluateCondition;


/***/ }),

/***/ 46324:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.evaluateConditions = void 0;
const debug_1 = __webpack_require__(90857);
const evaluateCondition_1 = __webpack_require__(20835);
const evaluateConditions = (conditions = [], options)=>{
    var _a, _b;
    const conditionsReferenceRecord = {};
    for (const condition of conditions){
        const { result, toAssign } = (0, evaluateCondition_1.evaluateCondition)(condition, {
            ...options,
            referenceRecord: {
                ...options.referenceRecord,
                ...conditionsReferenceRecord
            }
        });
        if (!result) {
            return {
                result
            };
        }
        if (toAssign) {
            conditionsReferenceRecord[toAssign.name] = toAssign.value;
            (_b = (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, debug_1.debugId, `assign: ${toAssign.name} := ${(0, debug_1.toDebugString)(toAssign.value)}`);
        }
    }
    return {
        result: true,
        referenceRecord: conditionsReferenceRecord
    };
};
exports.evaluateConditions = evaluateConditions;


/***/ }),

/***/ 56582:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.evaluateEndpointRule = void 0;
const debug_1 = __webpack_require__(90857);
const evaluateConditions_1 = __webpack_require__(46324);
const getEndpointHeaders_1 = __webpack_require__(4383);
const getEndpointProperties_1 = __webpack_require__(89483);
const getEndpointUrl_1 = __webpack_require__(37189);
const evaluateEndpointRule = (endpointRule, options)=>{
    var _a, _b;
    const { conditions, endpoint } = endpointRule;
    const { result, referenceRecord } = (0, evaluateConditions_1.evaluateConditions)(conditions, options);
    if (!result) {
        return;
    }
    const endpointRuleOptions = {
        ...options,
        referenceRecord: {
            ...options.referenceRecord,
            ...referenceRecord
        }
    };
    const { url, properties, headers } = endpoint;
    (_b = (_a = options.logger) === null || _a === void 0 ? void 0 : _a.debug) === null || _b === void 0 ? void 0 : _b.call(_a, debug_1.debugId, `Resolving endpoint from template: ${(0, debug_1.toDebugString)(endpoint)}`);
    return {
        ...headers != undefined && {
            headers: (0, getEndpointHeaders_1.getEndpointHeaders)(headers, endpointRuleOptions)
        },
        ...properties != undefined && {
            properties: (0, getEndpointProperties_1.getEndpointProperties)(properties, endpointRuleOptions)
        },
        url: (0, getEndpointUrl_1.getEndpointUrl)(url, endpointRuleOptions)
    };
};
exports.evaluateEndpointRule = evaluateEndpointRule;


/***/ }),

/***/ 28759:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.evaluateErrorRule = void 0;
const types_1 = __webpack_require__(32258);
const evaluateConditions_1 = __webpack_require__(46324);
const evaluateExpression_1 = __webpack_require__(84021);
const evaluateErrorRule = (errorRule, options)=>{
    const { conditions, error } = errorRule;
    const { result, referenceRecord } = (0, evaluateConditions_1.evaluateConditions)(conditions, options);
    if (!result) {
        return;
    }
    throw new types_1.EndpointError((0, evaluateExpression_1.evaluateExpression)(error, "Error", {
        ...options,
        referenceRecord: {
            ...options.referenceRecord,
            ...referenceRecord
        }
    }));
};
exports.evaluateErrorRule = evaluateErrorRule;


/***/ }),

/***/ 84021:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.evaluateExpression = void 0;
const types_1 = __webpack_require__(32258);
const callFunction_1 = __webpack_require__(89890);
const evaluateTemplate_1 = __webpack_require__(83318);
const getReferenceValue_1 = __webpack_require__(20778);
const evaluateExpression = (obj, keyName, options)=>{
    if (typeof obj === "string") {
        return (0, evaluateTemplate_1.evaluateTemplate)(obj, options);
    } else if (obj["fn"]) {
        return (0, callFunction_1.callFunction)(obj, options);
    } else if (obj["ref"]) {
        return (0, getReferenceValue_1.getReferenceValue)(obj, options);
    }
    throw new types_1.EndpointError(`'${keyName}': ${String(obj)} is not a string, function or reference.`);
};
exports.evaluateExpression = evaluateExpression;


/***/ }),

/***/ 64889:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.evaluateRules = void 0;
const types_1 = __webpack_require__(32258);
const evaluateEndpointRule_1 = __webpack_require__(56582);
const evaluateErrorRule_1 = __webpack_require__(28759);
const evaluateTreeRule_1 = __webpack_require__(11643);
const evaluateRules = (rules, options)=>{
    for (const rule of rules){
        if (rule.type === "endpoint") {
            const endpointOrUndefined = (0, evaluateEndpointRule_1.evaluateEndpointRule)(rule, options);
            if (endpointOrUndefined) {
                return endpointOrUndefined;
            }
        } else if (rule.type === "error") {
            (0, evaluateErrorRule_1.evaluateErrorRule)(rule, options);
        } else if (rule.type === "tree") {
            const endpointOrUndefined = (0, evaluateTreeRule_1.evaluateTreeRule)(rule, options);
            if (endpointOrUndefined) {
                return endpointOrUndefined;
            }
        } else {
            throw new types_1.EndpointError(`Unknown endpoint rule: ${rule}`);
        }
    }
    throw new types_1.EndpointError(`Rules evaluation failed`);
};
exports.evaluateRules = evaluateRules;


/***/ }),

/***/ 83318:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.evaluateTemplate = void 0;
const lib_1 = __webpack_require__(26819);
const evaluateTemplate = (template, options)=>{
    const evaluatedTemplateArr = [];
    const templateContext = {
        ...options.endpointParams,
        ...options.referenceRecord
    };
    let currentIndex = 0;
    while(currentIndex < template.length){
        const openingBraceIndex = template.indexOf("{", currentIndex);
        if (openingBraceIndex === -1) {
            evaluatedTemplateArr.push(template.slice(currentIndex));
            break;
        }
        evaluatedTemplateArr.push(template.slice(currentIndex, openingBraceIndex));
        const closingBraceIndex = template.indexOf("}", openingBraceIndex);
        if (closingBraceIndex === -1) {
            evaluatedTemplateArr.push(template.slice(openingBraceIndex));
            break;
        }
        if (template[openingBraceIndex + 1] === "{" && template[closingBraceIndex + 1] === "}") {
            evaluatedTemplateArr.push(template.slice(openingBraceIndex + 1, closingBraceIndex));
            currentIndex = closingBraceIndex + 2;
        }
        const parameterName = template.substring(openingBraceIndex + 1, closingBraceIndex);
        if (parameterName.includes("#")) {
            const [refName, attrName] = parameterName.split("#");
            evaluatedTemplateArr.push((0, lib_1.getAttr)(templateContext[refName], attrName));
        } else {
            evaluatedTemplateArr.push(templateContext[parameterName]);
        }
        currentIndex = closingBraceIndex + 1;
    }
    return evaluatedTemplateArr.join("");
};
exports.evaluateTemplate = evaluateTemplate;


/***/ }),

/***/ 11643:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.evaluateTreeRule = void 0;
const evaluateConditions_1 = __webpack_require__(46324);
const evaluateRules_1 = __webpack_require__(64889);
const evaluateTreeRule = (treeRule, options)=>{
    const { conditions, rules } = treeRule;
    const { result, referenceRecord } = (0, evaluateConditions_1.evaluateConditions)(conditions, options);
    if (!result) {
        return;
    }
    return (0, evaluateRules_1.evaluateRules)(rules, {
        ...options,
        referenceRecord: {
            ...options.referenceRecord,
            ...referenceRecord
        }
    });
};
exports.evaluateTreeRule = evaluateTreeRule;


/***/ }),

/***/ 4383:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getEndpointHeaders = void 0;
const types_1 = __webpack_require__(32258);
const evaluateExpression_1 = __webpack_require__(84021);
const getEndpointHeaders = (headers, options)=>Object.entries(headers).reduce((acc, [headerKey, headerVal])=>({
            ...acc,
            [headerKey]: headerVal.map((headerValEntry)=>{
                const processedExpr = (0, evaluateExpression_1.evaluateExpression)(headerValEntry, "Header value entry", options);
                if (typeof processedExpr !== "string") {
                    throw new types_1.EndpointError(`Header '${headerKey}' value '${processedExpr}' is not a string`);
                }
                return processedExpr;
            })
        }), {});
exports.getEndpointHeaders = getEndpointHeaders;


/***/ }),

/***/ 89483:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getEndpointProperties = void 0;
const getEndpointProperty_1 = __webpack_require__(99003);
const getEndpointProperties = (properties, options)=>Object.entries(properties).reduce((acc, [propertyKey, propertyVal])=>({
            ...acc,
            [propertyKey]: (0, getEndpointProperty_1.getEndpointProperty)(propertyVal, options)
        }), {});
exports.getEndpointProperties = getEndpointProperties;


/***/ }),

/***/ 99003:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getEndpointProperty = void 0;
const types_1 = __webpack_require__(32258);
const evaluateTemplate_1 = __webpack_require__(83318);
const getEndpointProperties_1 = __webpack_require__(89483);
const getEndpointProperty = (property, options)=>{
    if (Array.isArray(property)) {
        return property.map((propertyEntry)=>(0, exports.getEndpointProperty)(propertyEntry, options));
    }
    switch(typeof property){
        case "string":
            return (0, evaluateTemplate_1.evaluateTemplate)(property, options);
        case "object":
            if (property === null) {
                throw new types_1.EndpointError(`Unexpected endpoint property: ${property}`);
            }
            return (0, getEndpointProperties_1.getEndpointProperties)(property, options);
        case "boolean":
            return property;
        default:
            throw new types_1.EndpointError(`Unexpected endpoint property type: ${typeof property}`);
    }
};
exports.getEndpointProperty = getEndpointProperty;


/***/ }),

/***/ 37189:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getEndpointUrl = void 0;
const types_1 = __webpack_require__(32258);
const evaluateExpression_1 = __webpack_require__(84021);
const getEndpointUrl = (endpointUrl, options)=>{
    const expression = (0, evaluateExpression_1.evaluateExpression)(endpointUrl, "Endpoint URL", options);
    if (typeof expression === "string") {
        try {
            return new URL(expression);
        } catch (error) {
            console.error(`Failed to construct URL with ${expression}`, error);
            throw error;
        }
    }
    throw new types_1.EndpointError(`Endpoint URL must be a string, got ${typeof expression}`);
};
exports.getEndpointUrl = getEndpointUrl;


/***/ }),

/***/ 20778:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getReferenceValue = void 0;
const getReferenceValue = ({ ref }, options)=>{
    const referenceRecord = {
        ...options.endpointParams,
        ...options.referenceRecord
    };
    return referenceRecord[ref];
};
exports.getReferenceValue = getReferenceValue;


/***/ }),

/***/ 23659:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(64889), exports);


/***/ }),

/***/ 62850:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.defaultUserAgent = exports.UA_APP_ID_INI_NAME = exports.UA_APP_ID_ENV_NAME = void 0;
const node_config_provider_1 = __webpack_require__(15829);
const os_1 = __webpack_require__(22037);
const process_1 = __webpack_require__(77282);
const is_crt_available_1 = __webpack_require__(69951);
exports.UA_APP_ID_ENV_NAME = "AWS_SDK_UA_APP_ID";
exports.UA_APP_ID_INI_NAME = "sdk-ua-app-id";
const defaultUserAgent = ({ serviceId, clientVersion })=>{
    const sections = [
        [
            "aws-sdk-js",
            clientVersion
        ],
        [
            "ua",
            "2.0"
        ],
        [
            `os/${(0, os_1.platform)()}`,
            (0, os_1.release)()
        ],
        [
            "lang/js"
        ],
        [
            "md/nodejs",
            `${process_1.versions.node}`
        ]
    ];
    const crtAvailable = (0, is_crt_available_1.isCrtAvailable)();
    if (crtAvailable) {
        sections.push(crtAvailable);
    }
    if (serviceId) {
        sections.push([
            `api/${serviceId}`,
            clientVersion
        ]);
    }
    if (process_1.env.AWS_EXECUTION_ENV) {
        sections.push([
            `exec-env/${process_1.env.AWS_EXECUTION_ENV}`
        ]);
    }
    const appIdPromise = (0, node_config_provider_1.loadConfig)({
        environmentVariableSelector: (env)=>env[exports.UA_APP_ID_ENV_NAME],
        configFileSelector: (profile)=>profile[exports.UA_APP_ID_INI_NAME],
        default: undefined
    })();
    let resolvedUserAgent = undefined;
    return async ()=>{
        if (!resolvedUserAgent) {
            const appId = await appIdPromise;
            resolvedUserAgent = appId ? [
                ...sections,
                [
                    `app/${appId}`
                ]
            ] : [
                ...sections
            ];
        }
        return resolvedUserAgent;
    };
};
exports.defaultUserAgent = defaultUserAgent;


/***/ }),

/***/ 69951:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isCrtAvailable = void 0;
const isCrtAvailable = ()=>{
    try {
        if ( true && __webpack_require__(36254)) {
            return [
                "md/crt-avail"
            ];
        }
        return null;
    } catch (e) {
        return null;
    }
};
exports.isCrtAvailable = isCrtAvailable;


/***/ }),

/***/ 50435:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = exports.DEFAULT_USE_DUALSTACK_ENDPOINT = exports.CONFIG_USE_DUALSTACK_ENDPOINT = exports.ENV_USE_DUALSTACK_ENDPOINT = void 0;
const util_config_provider_1 = __webpack_require__(71543);
exports.ENV_USE_DUALSTACK_ENDPOINT = "AWS_USE_DUALSTACK_ENDPOINT";
exports.CONFIG_USE_DUALSTACK_ENDPOINT = "use_dualstack_endpoint";
exports.DEFAULT_USE_DUALSTACK_ENDPOINT = false;
exports.NODE_USE_DUALSTACK_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env)=>(0, util_config_provider_1.booleanSelector)(env, exports.ENV_USE_DUALSTACK_ENDPOINT, util_config_provider_1.SelectorType.ENV),
    configFileSelector: (profile)=>(0, util_config_provider_1.booleanSelector)(profile, exports.CONFIG_USE_DUALSTACK_ENDPOINT, util_config_provider_1.SelectorType.CONFIG),
    default: false
};


/***/ }),

/***/ 27911:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = exports.DEFAULT_USE_FIPS_ENDPOINT = exports.CONFIG_USE_FIPS_ENDPOINT = exports.ENV_USE_FIPS_ENDPOINT = void 0;
const util_config_provider_1 = __webpack_require__(71543);
exports.ENV_USE_FIPS_ENDPOINT = "AWS_USE_FIPS_ENDPOINT";
exports.CONFIG_USE_FIPS_ENDPOINT = "use_fips_endpoint";
exports.DEFAULT_USE_FIPS_ENDPOINT = false;
exports.NODE_USE_FIPS_ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env)=>(0, util_config_provider_1.booleanSelector)(env, exports.ENV_USE_FIPS_ENDPOINT, util_config_provider_1.SelectorType.ENV),
    configFileSelector: (profile)=>(0, util_config_provider_1.booleanSelector)(profile, exports.CONFIG_USE_FIPS_ENDPOINT, util_config_provider_1.SelectorType.CONFIG),
    default: false
};


/***/ }),

/***/ 22049:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(50435), exports);
tslib_1.__exportStar(__webpack_require__(27911), exports);
tslib_1.__exportStar(__webpack_require__(88159), exports);
tslib_1.__exportStar(__webpack_require__(74898), exports);


/***/ }),

/***/ 88159:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveCustomEndpointsConfig = void 0;
const util_middleware_1 = __webpack_require__(5837);
const resolveCustomEndpointsConfig = (input)=>{
    var _a, _b;
    const { endpoint, urlParser } = input;
    return {
        ...input,
        tls: (_a = input.tls) !== null && _a !== void 0 ? _a : true,
        endpoint: (0, util_middleware_1.normalizeProvider)(typeof endpoint === "string" ? urlParser(endpoint) : endpoint),
        isCustomEndpoint: true,
        useDualstackEndpoint: (0, util_middleware_1.normalizeProvider)((_b = input.useDualstackEndpoint) !== null && _b !== void 0 ? _b : false)
    };
};
exports.resolveCustomEndpointsConfig = resolveCustomEndpointsConfig;


/***/ }),

/***/ 74898:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveEndpointsConfig = void 0;
const util_middleware_1 = __webpack_require__(5837);
const getEndpointFromRegion_1 = __webpack_require__(94158);
const resolveEndpointsConfig = (input)=>{
    var _a, _b;
    const useDualstackEndpoint = (0, util_middleware_1.normalizeProvider)((_a = input.useDualstackEndpoint) !== null && _a !== void 0 ? _a : false);
    const { endpoint, useFipsEndpoint, urlParser } = input;
    return {
        ...input,
        tls: (_b = input.tls) !== null && _b !== void 0 ? _b : true,
        endpoint: endpoint ? (0, util_middleware_1.normalizeProvider)(typeof endpoint === "string" ? urlParser(endpoint) : endpoint) : ()=>(0, getEndpointFromRegion_1.getEndpointFromRegion)({
                ...input,
                useDualstackEndpoint,
                useFipsEndpoint
            }),
        isCustomEndpoint: !!endpoint,
        useDualstackEndpoint
    };
};
exports.resolveEndpointsConfig = resolveEndpointsConfig;


/***/ }),

/***/ 94158:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getEndpointFromRegion = void 0;
const getEndpointFromRegion = async (input)=>{
    var _a;
    const { tls = true } = input;
    const region = await input.region();
    const dnsHostRegex = new RegExp(/^([a-zA-Z0-9]|[a-zA-Z0-9][a-zA-Z0-9-]{0,61}[a-zA-Z0-9])$/);
    if (!dnsHostRegex.test(region)) {
        throw new Error("Invalid region in client config");
    }
    const useDualstackEndpoint = await input.useDualstackEndpoint();
    const useFipsEndpoint = await input.useFipsEndpoint();
    const { hostname } = (_a = await input.regionInfoProvider(region, {
        useDualstackEndpoint,
        useFipsEndpoint
    })) !== null && _a !== void 0 ? _a : {};
    if (!hostname) {
        throw new Error("Cannot resolve hostname from client config");
    }
    return input.urlParser(`${tls ? "https:" : "http:"}//${hostname}`);
};
exports.getEndpointFromRegion = getEndpointFromRegion;


/***/ }),

/***/ 25708:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(22049), exports);
tslib_1.__exportStar(__webpack_require__(46619), exports);
tslib_1.__exportStar(__webpack_require__(85166), exports);


/***/ }),

/***/ 17152:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NODE_REGION_CONFIG_FILE_OPTIONS = exports.NODE_REGION_CONFIG_OPTIONS = exports.REGION_INI_NAME = exports.REGION_ENV_NAME = void 0;
exports.REGION_ENV_NAME = "AWS_REGION";
exports.REGION_INI_NAME = "region";
exports.NODE_REGION_CONFIG_OPTIONS = {
    environmentVariableSelector: (env)=>env[exports.REGION_ENV_NAME],
    configFileSelector: (profile)=>profile[exports.REGION_INI_NAME],
    default: ()=>{
        throw new Error("Region is missing");
    }
};
exports.NODE_REGION_CONFIG_FILE_OPTIONS = {
    preferredFile: "credentials"
};


/***/ }),

/***/ 26662:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getRealRegion = void 0;
const isFipsRegion_1 = __webpack_require__(87891);
const getRealRegion = (region)=>(0, isFipsRegion_1.isFipsRegion)(region) ? [
        "fips-aws-global",
        "aws-fips"
    ].includes(region) ? "us-east-1" : region.replace(/fips-(dkr-|prod-)?|-fips/, "") : region;
exports.getRealRegion = getRealRegion;


/***/ }),

/***/ 46619:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(17152), exports);
tslib_1.__exportStar(__webpack_require__(62407), exports);


/***/ }),

/***/ 87891:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isFipsRegion = void 0;
const isFipsRegion = (region)=>typeof region === "string" && (region.startsWith("fips-") || region.endsWith("-fips"));
exports.isFipsRegion = isFipsRegion;


/***/ }),

/***/ 62407:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveRegionConfig = void 0;
const getRealRegion_1 = __webpack_require__(26662);
const isFipsRegion_1 = __webpack_require__(87891);
const resolveRegionConfig = (input)=>{
    const { region, useFipsEndpoint } = input;
    if (!region) {
        throw new Error("Region is missing");
    }
    return {
        ...input,
        region: async ()=>{
            if (typeof region === "string") {
                return (0, getRealRegion_1.getRealRegion)(region);
            }
            const providedRegion = await region();
            return (0, getRealRegion_1.getRealRegion)(providedRegion);
        },
        useFipsEndpoint: async ()=>{
            const providedRegion = typeof region === "string" ? region : await region();
            if ((0, isFipsRegion_1.isFipsRegion)(providedRegion)) {
                return true;
            }
            return typeof useFipsEndpoint !== "function" ? Promise.resolve(!!useFipsEndpoint) : useFipsEndpoint();
        }
    };
};
exports.resolveRegionConfig = resolveRegionConfig;


/***/ }),

/***/ 25500:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 28274:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 62506:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getHostnameFromVariants = void 0;
const getHostnameFromVariants = (variants = [], { useFipsEndpoint, useDualstackEndpoint })=>{
    var _a;
    return (_a = variants.find(({ tags })=>useFipsEndpoint === tags.includes("fips") && useDualstackEndpoint === tags.includes("dualstack"))) === null || _a === void 0 ? void 0 : _a.hostname;
};
exports.getHostnameFromVariants = getHostnameFromVariants;


/***/ }),

/***/ 78343:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getRegionInfo = void 0;
const getHostnameFromVariants_1 = __webpack_require__(62506);
const getResolvedHostname_1 = __webpack_require__(51959);
const getResolvedPartition_1 = __webpack_require__(47514);
const getResolvedSigningRegion_1 = __webpack_require__(64358);
const getRegionInfo = (region, { useFipsEndpoint = false, useDualstackEndpoint = false, signingService, regionHash, partitionHash })=>{
    var _a, _b, _c, _d, _e, _f;
    const partition = (0, getResolvedPartition_1.getResolvedPartition)(region, {
        partitionHash
    });
    const resolvedRegion = region in regionHash ? region : (_b = (_a = partitionHash[partition]) === null || _a === void 0 ? void 0 : _a.endpoint) !== null && _b !== void 0 ? _b : region;
    const hostnameOptions = {
        useFipsEndpoint,
        useDualstackEndpoint
    };
    const regionHostname = (0, getHostnameFromVariants_1.getHostnameFromVariants)((_c = regionHash[resolvedRegion]) === null || _c === void 0 ? void 0 : _c.variants, hostnameOptions);
    const partitionHostname = (0, getHostnameFromVariants_1.getHostnameFromVariants)((_d = partitionHash[partition]) === null || _d === void 0 ? void 0 : _d.variants, hostnameOptions);
    const hostname = (0, getResolvedHostname_1.getResolvedHostname)(resolvedRegion, {
        regionHostname,
        partitionHostname
    });
    if (hostname === undefined) {
        throw new Error(`Endpoint resolution failed for: ${{
            resolvedRegion,
            useFipsEndpoint,
            useDualstackEndpoint
        }}`);
    }
    const signingRegion = (0, getResolvedSigningRegion_1.getResolvedSigningRegion)(hostname, {
        signingRegion: (_e = regionHash[resolvedRegion]) === null || _e === void 0 ? void 0 : _e.signingRegion,
        regionRegex: partitionHash[partition].regionRegex,
        useFipsEndpoint
    });
    return {
        partition,
        signingService,
        hostname,
        ...signingRegion && {
            signingRegion
        },
        ...((_f = regionHash[resolvedRegion]) === null || _f === void 0 ? void 0 : _f.signingService) && {
            signingService: regionHash[resolvedRegion].signingService
        }
    };
};
exports.getRegionInfo = getRegionInfo;


/***/ }),

/***/ 51959:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getResolvedHostname = void 0;
const getResolvedHostname = (resolvedRegion, { regionHostname, partitionHostname })=>regionHostname ? regionHostname : partitionHostname ? partitionHostname.replace("{region}", resolvedRegion) : undefined;
exports.getResolvedHostname = getResolvedHostname;


/***/ }),

/***/ 47514:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getResolvedPartition = void 0;
const getResolvedPartition = (region, { partitionHash })=>{
    var _a;
    return (_a = Object.keys(partitionHash || {}).find((key)=>partitionHash[key].regions.includes(region))) !== null && _a !== void 0 ? _a : "aws";
};
exports.getResolvedPartition = getResolvedPartition;


/***/ }),

/***/ 64358:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getResolvedSigningRegion = void 0;
const getResolvedSigningRegion = (hostname, { signingRegion, regionRegex, useFipsEndpoint })=>{
    if (signingRegion) {
        return signingRegion;
    } else if (useFipsEndpoint) {
        const regionRegexJs = regionRegex.replace("\\\\", "\\").replace(/^\^/g, "\\.").replace(/\$$/g, "\\.");
        const regionRegexmatchArray = hostname.match(regionRegexJs);
        if (regionRegexmatchArray) {
            return regionRegexmatchArray[0].slice(1, -1);
        }
    }
};
exports.getResolvedSigningRegion = getResolvedSigningRegion;


/***/ }),

/***/ 85166:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(25500), exports);
tslib_1.__exportStar(__webpack_require__(28274), exports);
tslib_1.__exportStar(__webpack_require__(78343), exports);


/***/ }),

/***/ 76538:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Endpoint = void 0;
var Endpoint;
(function(Endpoint) {
    Endpoint["IPv4"] = "http://169.254.169.254";
    Endpoint["IPv6"] = "http://[fd00:ec2::254]";
})(Endpoint = exports.Endpoint || (exports.Endpoint = {}));


/***/ }),

/***/ 95417:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ENDPOINT_CONFIG_OPTIONS = exports.CONFIG_ENDPOINT_NAME = exports.ENV_ENDPOINT_NAME = void 0;
exports.ENV_ENDPOINT_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT";
exports.CONFIG_ENDPOINT_NAME = "ec2_metadata_service_endpoint";
exports.ENDPOINT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env)=>env[exports.ENV_ENDPOINT_NAME],
    configFileSelector: (profile)=>profile[exports.CONFIG_ENDPOINT_NAME],
    default: undefined
};


/***/ }),

/***/ 72849:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.EndpointMode = void 0;
var EndpointMode;
(function(EndpointMode) {
    EndpointMode["IPv4"] = "IPv4";
    EndpointMode["IPv6"] = "IPv6";
})(EndpointMode = exports.EndpointMode || (exports.EndpointMode = {}));


/***/ }),

/***/ 41513:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ENDPOINT_MODE_CONFIG_OPTIONS = exports.CONFIG_ENDPOINT_MODE_NAME = exports.ENV_ENDPOINT_MODE_NAME = void 0;
const EndpointMode_1 = __webpack_require__(72849);
exports.ENV_ENDPOINT_MODE_NAME = "AWS_EC2_METADATA_SERVICE_ENDPOINT_MODE";
exports.CONFIG_ENDPOINT_MODE_NAME = "ec2_metadata_service_endpoint_mode";
exports.ENDPOINT_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env)=>env[exports.ENV_ENDPOINT_MODE_NAME],
    configFileSelector: (profile)=>profile[exports.CONFIG_ENDPOINT_MODE_NAME],
    default: EndpointMode_1.EndpointMode.IPv4
};


/***/ }),

/***/ 49080:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromContainerMetadata = exports.ENV_CMDS_AUTH_TOKEN = exports.ENV_CMDS_RELATIVE_URI = exports.ENV_CMDS_FULL_URI = void 0;
const property_provider_1 = __webpack_require__(29852);
const url_1 = __webpack_require__(57310);
const httpRequest_1 = __webpack_require__(30773);
const ImdsCredentials_1 = __webpack_require__(91574);
const RemoteProviderInit_1 = __webpack_require__(34113);
const retry_1 = __webpack_require__(34116);
exports.ENV_CMDS_FULL_URI = "AWS_CONTAINER_CREDENTIALS_FULL_URI";
exports.ENV_CMDS_RELATIVE_URI = "AWS_CONTAINER_CREDENTIALS_RELATIVE_URI";
exports.ENV_CMDS_AUTH_TOKEN = "AWS_CONTAINER_AUTHORIZATION_TOKEN";
const fromContainerMetadata = (init = {})=>{
    const { timeout, maxRetries } = (0, RemoteProviderInit_1.providerConfigFromInit)(init);
    return ()=>(0, retry_1.retry)(async ()=>{
            const requestOptions = await getCmdsUri();
            const credsResponse = JSON.parse(await requestFromEcsImds(timeout, requestOptions));
            if (!(0, ImdsCredentials_1.isImdsCredentials)(credsResponse)) {
                throw new property_provider_1.CredentialsProviderError("Invalid response received from instance metadata service.");
            }
            return (0, ImdsCredentials_1.fromImdsCredentials)(credsResponse);
        }, maxRetries);
};
exports.fromContainerMetadata = fromContainerMetadata;
const requestFromEcsImds = async (timeout, options)=>{
    if (process.env[exports.ENV_CMDS_AUTH_TOKEN]) {
        options.headers = {
            ...options.headers,
            Authorization: process.env[exports.ENV_CMDS_AUTH_TOKEN]
        };
    }
    const buffer = await (0, httpRequest_1.httpRequest)({
        ...options,
        timeout
    });
    return buffer.toString();
};
const CMDS_IP = "169.254.170.2";
const GREENGRASS_HOSTS = {
    localhost: true,
    "127.0.0.1": true
};
const GREENGRASS_PROTOCOLS = {
    "http:": true,
    "https:": true
};
const getCmdsUri = async ()=>{
    if (process.env[exports.ENV_CMDS_RELATIVE_URI]) {
        return {
            hostname: CMDS_IP,
            path: process.env[exports.ENV_CMDS_RELATIVE_URI]
        };
    }
    if (process.env[exports.ENV_CMDS_FULL_URI]) {
        const parsed = (0, url_1.parse)(process.env[exports.ENV_CMDS_FULL_URI]);
        if (!parsed.hostname || !(parsed.hostname in GREENGRASS_HOSTS)) {
            throw new property_provider_1.CredentialsProviderError(`${parsed.hostname} is not a valid container metadata service hostname`, false);
        }
        if (!parsed.protocol || !(parsed.protocol in GREENGRASS_PROTOCOLS)) {
            throw new property_provider_1.CredentialsProviderError(`${parsed.protocol} is not a valid container metadata service protocol`, false);
        }
        return {
            ...parsed,
            port: parsed.port ? parseInt(parsed.port, 10) : undefined
        };
    }
    throw new property_provider_1.CredentialsProviderError("The container metadata credential provider cannot be used unless" + ` the ${exports.ENV_CMDS_RELATIVE_URI} or ${exports.ENV_CMDS_FULL_URI} environment` + " variable is set", false);
};


/***/ }),

/***/ 38454:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromInstanceMetadata = void 0;
const property_provider_1 = __webpack_require__(29852);
const httpRequest_1 = __webpack_require__(30773);
const ImdsCredentials_1 = __webpack_require__(91574);
const RemoteProviderInit_1 = __webpack_require__(34113);
const retry_1 = __webpack_require__(34116);
const getInstanceMetadataEndpoint_1 = __webpack_require__(23705);
const staticStabilityProvider_1 = __webpack_require__(3559);
const IMDS_PATH = "/latest/meta-data/iam/security-credentials/";
const IMDS_TOKEN_PATH = "/latest/api/token";
const fromInstanceMetadata = (init = {})=>(0, staticStabilityProvider_1.staticStabilityProvider)(getInstanceImdsProvider(init), {
        logger: init.logger
    });
exports.fromInstanceMetadata = fromInstanceMetadata;
const getInstanceImdsProvider = (init)=>{
    let disableFetchToken = false;
    const { timeout, maxRetries } = (0, RemoteProviderInit_1.providerConfigFromInit)(init);
    const getCredentials = async (maxRetries, options)=>{
        const profile = (await (0, retry_1.retry)(async ()=>{
            let profile;
            try {
                profile = await getProfile(options);
            } catch (err) {
                if (err.statusCode === 401) {
                    disableFetchToken = false;
                }
                throw err;
            }
            return profile;
        }, maxRetries)).trim();
        return (0, retry_1.retry)(async ()=>{
            let creds;
            try {
                creds = await getCredentialsFromProfile(profile, options);
            } catch (err) {
                if (err.statusCode === 401) {
                    disableFetchToken = false;
                }
                throw err;
            }
            return creds;
        }, maxRetries);
    };
    return async ()=>{
        const endpoint = await (0, getInstanceMetadataEndpoint_1.getInstanceMetadataEndpoint)();
        if (disableFetchToken) {
            return getCredentials(maxRetries, {
                ...endpoint,
                timeout
            });
        } else {
            let token;
            try {
                token = (await getMetadataToken({
                    ...endpoint,
                    timeout
                })).toString();
            } catch (error) {
                if ((error === null || error === void 0 ? void 0 : error.statusCode) === 400) {
                    throw Object.assign(error, {
                        message: "EC2 Metadata token request returned error"
                    });
                } else if (error.message === "TimeoutError" || [
                    403,
                    404,
                    405
                ].includes(error.statusCode)) {
                    disableFetchToken = true;
                }
                return getCredentials(maxRetries, {
                    ...endpoint,
                    timeout
                });
            }
            return getCredentials(maxRetries, {
                ...endpoint,
                headers: {
                    "x-aws-ec2-metadata-token": token
                },
                timeout
            });
        }
    };
};
const getMetadataToken = async (options)=>(0, httpRequest_1.httpRequest)({
        ...options,
        path: IMDS_TOKEN_PATH,
        method: "PUT",
        headers: {
            "x-aws-ec2-metadata-token-ttl-seconds": "21600"
        }
    });
const getProfile = async (options)=>(await (0, httpRequest_1.httpRequest)({
        ...options,
        path: IMDS_PATH
    })).toString();
const getCredentialsFromProfile = async (profile, options)=>{
    const credsResponse = JSON.parse((await (0, httpRequest_1.httpRequest)({
        ...options,
        path: IMDS_PATH + profile
    })).toString());
    if (!(0, ImdsCredentials_1.isImdsCredentials)(credsResponse)) {
        throw new property_provider_1.CredentialsProviderError("Invalid response received from instance metadata service.");
    }
    return (0, ImdsCredentials_1.fromImdsCredentials)(credsResponse);
};


/***/ }),

/***/ 72214:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getInstanceMetadataEndpoint = exports.httpRequest = void 0;
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(49080), exports);
tslib_1.__exportStar(__webpack_require__(38454), exports);
tslib_1.__exportStar(__webpack_require__(34113), exports);
tslib_1.__exportStar(__webpack_require__(60674), exports);
var httpRequest_1 = __webpack_require__(30773);
Object.defineProperty(exports, "httpRequest", ({
    enumerable: true,
    get: function() {
        return httpRequest_1.httpRequest;
    }
}));
var getInstanceMetadataEndpoint_1 = __webpack_require__(23705);
Object.defineProperty(exports, "getInstanceMetadataEndpoint", ({
    enumerable: true,
    get: function() {
        return getInstanceMetadataEndpoint_1.getInstanceMetadataEndpoint;
    }
}));


/***/ }),

/***/ 91574:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromImdsCredentials = exports.isImdsCredentials = void 0;
const isImdsCredentials = (arg)=>Boolean(arg) && typeof arg === "object" && typeof arg.AccessKeyId === "string" && typeof arg.SecretAccessKey === "string" && typeof arg.Token === "string" && typeof arg.Expiration === "string";
exports.isImdsCredentials = isImdsCredentials;
const fromImdsCredentials = (creds)=>({
        accessKeyId: creds.AccessKeyId,
        secretAccessKey: creds.SecretAccessKey,
        sessionToken: creds.Token,
        expiration: new Date(creds.Expiration)
    });
exports.fromImdsCredentials = fromImdsCredentials;


/***/ }),

/***/ 34113:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.providerConfigFromInit = exports.DEFAULT_MAX_RETRIES = exports.DEFAULT_TIMEOUT = void 0;
exports.DEFAULT_TIMEOUT = 1000;
exports.DEFAULT_MAX_RETRIES = 0;
const providerConfigFromInit = ({ maxRetries = exports.DEFAULT_MAX_RETRIES, timeout = exports.DEFAULT_TIMEOUT })=>({
        maxRetries,
        timeout
    });
exports.providerConfigFromInit = providerConfigFromInit;


/***/ }),

/***/ 30773:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.httpRequest = void 0;
const property_provider_1 = __webpack_require__(29852);
const buffer_1 = __webpack_require__(14300);
const http_1 = __webpack_require__(13685);
function httpRequest(options) {
    return new Promise((resolve, reject)=>{
        var _a;
        const req = (0, http_1.request)({
            method: "GET",
            ...options,
            hostname: (_a = options.hostname) === null || _a === void 0 ? void 0 : _a.replace(/^\[(.+)\]$/, "$1")
        });
        req.on("error", (err)=>{
            reject(Object.assign(new property_provider_1.ProviderError("Unable to connect to instance metadata service"), err));
            req.destroy();
        });
        req.on("timeout", ()=>{
            reject(new property_provider_1.ProviderError("TimeoutError from instance metadata service"));
            req.destroy();
        });
        req.on("response", (res)=>{
            const { statusCode = 400 } = res;
            if (statusCode < 200 || 300 <= statusCode) {
                reject(Object.assign(new property_provider_1.ProviderError("Error response received from instance metadata service"), {
                    statusCode
                }));
                req.destroy();
            }
            const chunks = [];
            res.on("data", (chunk)=>{
                chunks.push(chunk);
            });
            res.on("end", ()=>{
                resolve(buffer_1.Buffer.concat(chunks));
                req.destroy();
            });
        });
        req.end();
    });
}
exports.httpRequest = httpRequest;


/***/ }),

/***/ 34116:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.retry = void 0;
const retry = (toRetry, maxRetries)=>{
    let promise = toRetry();
    for(let i = 0; i < maxRetries; i++){
        promise = promise.catch(toRetry);
    }
    return promise;
};
exports.retry = retry;


/***/ }),

/***/ 60674:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 32070:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getExtendedInstanceMetadataCredentials = void 0;
const STATIC_STABILITY_REFRESH_INTERVAL_SECONDS = 5 * 60;
const STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS = 5 * 60;
const STATIC_STABILITY_DOC_URL = "https://docs.aws.amazon.com/sdkref/latest/guide/feature-static-credentials.html";
const getExtendedInstanceMetadataCredentials = (credentials, logger)=>{
    var _a;
    const refreshInterval = STATIC_STABILITY_REFRESH_INTERVAL_SECONDS + Math.floor(Math.random() * STATIC_STABILITY_REFRESH_INTERVAL_JITTER_WINDOW_SECONDS);
    const newExpiration = new Date(Date.now() + refreshInterval * 1000);
    logger.warn("Attempting credential expiration extension due to a credential service availability issue. A refresh of these " + "credentials will be attempted after ${new Date(newExpiration)}.\nFor more information, please visit: " + STATIC_STABILITY_DOC_URL);
    const originalExpiration = (_a = credentials.originalExpiration) !== null && _a !== void 0 ? _a : credentials.expiration;
    return {
        ...credentials,
        ...originalExpiration ? {
            originalExpiration
        } : {},
        expiration: newExpiration
    };
};
exports.getExtendedInstanceMetadataCredentials = getExtendedInstanceMetadataCredentials;


/***/ }),

/***/ 23705:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getInstanceMetadataEndpoint = void 0;
const node_config_provider_1 = __webpack_require__(15829);
const url_parser_1 = __webpack_require__(45110);
const Endpoint_1 = __webpack_require__(76538);
const EndpointConfigOptions_1 = __webpack_require__(95417);
const EndpointMode_1 = __webpack_require__(72849);
const EndpointModeConfigOptions_1 = __webpack_require__(41513);
const getInstanceMetadataEndpoint = async ()=>(0, url_parser_1.parseUrl)(await getFromEndpointConfig() || await getFromEndpointModeConfig());
exports.getInstanceMetadataEndpoint = getInstanceMetadataEndpoint;
const getFromEndpointConfig = async ()=>(0, node_config_provider_1.loadConfig)(EndpointConfigOptions_1.ENDPOINT_CONFIG_OPTIONS)();
const getFromEndpointModeConfig = async ()=>{
    const endpointMode = await (0, node_config_provider_1.loadConfig)(EndpointModeConfigOptions_1.ENDPOINT_MODE_CONFIG_OPTIONS)();
    switch(endpointMode){
        case EndpointMode_1.EndpointMode.IPv4:
            return Endpoint_1.Endpoint.IPv4;
        case EndpointMode_1.EndpointMode.IPv6:
            return Endpoint_1.Endpoint.IPv6;
        default:
            throw new Error(`Unsupported endpoint mode: ${endpointMode}.` + ` Select from ${Object.values(EndpointMode_1.EndpointMode)}`);
    }
};


/***/ }),

/***/ 3559:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.staticStabilityProvider = void 0;
const getExtendedInstanceMetadataCredentials_1 = __webpack_require__(32070);
const staticStabilityProvider = (provider, options = {})=>{
    const logger = (options === null || options === void 0 ? void 0 : options.logger) || console;
    let pastCredentials;
    return async ()=>{
        let credentials;
        try {
            credentials = await provider();
            if (credentials.expiration && credentials.expiration.getTime() < Date.now()) {
                credentials = (0, getExtendedInstanceMetadataCredentials_1.getExtendedInstanceMetadataCredentials)(credentials, logger);
            }
        } catch (e) {
            if (pastCredentials) {
                logger.warn("Credential renew failed: ", e);
                credentials = (0, getExtendedInstanceMetadataCredentials_1.getExtendedInstanceMetadataCredentials)(pastCredentials, logger);
            } else {
                throw e;
            }
        }
        pastCredentials = credentials;
        return credentials;
    };
};
exports.staticStabilityProvider = staticStabilityProvider;


/***/ }),

/***/ 48802:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.EventStreamCodec = void 0;
const crc32_1 = __webpack_require__(71079);
const HeaderMarshaller_1 = __webpack_require__(13371);
const splitMessage_1 = __webpack_require__(85582);
class EventStreamCodec {
    constructor(toUtf8, fromUtf8){
        this.headerMarshaller = new HeaderMarshaller_1.HeaderMarshaller(toUtf8, fromUtf8);
        this.messageBuffer = [];
        this.isEndOfStream = false;
    }
    feed(message) {
        this.messageBuffer.push(this.decode(message));
    }
    endOfStream() {
        this.isEndOfStream = true;
    }
    getMessage() {
        const message = this.messageBuffer.pop();
        const isEndOfStream = this.isEndOfStream;
        return {
            getMessage () {
                return message;
            },
            isEndOfStream () {
                return isEndOfStream;
            }
        };
    }
    getAvailableMessages() {
        const messages = this.messageBuffer;
        this.messageBuffer = [];
        const isEndOfStream = this.isEndOfStream;
        return {
            getMessages () {
                return messages;
            },
            isEndOfStream () {
                return isEndOfStream;
            }
        };
    }
    encode({ headers: rawHeaders, body }) {
        const headers = this.headerMarshaller.format(rawHeaders);
        const length = headers.byteLength + body.byteLength + 16;
        const out = new Uint8Array(length);
        const view = new DataView(out.buffer, out.byteOffset, out.byteLength);
        const checksum = new crc32_1.Crc32();
        view.setUint32(0, length, false);
        view.setUint32(4, headers.byteLength, false);
        view.setUint32(8, checksum.update(out.subarray(0, 8)).digest(), false);
        out.set(headers, 12);
        out.set(body, headers.byteLength + 12);
        view.setUint32(length - 4, checksum.update(out.subarray(8, length - 4)).digest(), false);
        return out;
    }
    decode(message) {
        const { headers, body } = (0, splitMessage_1.splitMessage)(message);
        return {
            headers: this.headerMarshaller.parse(headers),
            body
        };
    }
    formatHeaders(rawHeaders) {
        return this.headerMarshaller.format(rawHeaders);
    }
}
exports.EventStreamCodec = EventStreamCodec;


/***/ }),

/***/ 13371:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.HeaderMarshaller = void 0;
const util_hex_encoding_1 = __webpack_require__(7214);
const Int64_1 = __webpack_require__(7403);
class HeaderMarshaller {
    constructor(toUtf8, fromUtf8){
        this.toUtf8 = toUtf8;
        this.fromUtf8 = fromUtf8;
    }
    format(headers) {
        const chunks = [];
        for (const headerName of Object.keys(headers)){
            const bytes = this.fromUtf8(headerName);
            chunks.push(Uint8Array.from([
                bytes.byteLength
            ]), bytes, this.formatHeaderValue(headers[headerName]));
        }
        const out = new Uint8Array(chunks.reduce((carry, bytes)=>carry + bytes.byteLength, 0));
        let position = 0;
        for (const chunk of chunks){
            out.set(chunk, position);
            position += chunk.byteLength;
        }
        return out;
    }
    formatHeaderValue(header) {
        switch(header.type){
            case "boolean":
                return Uint8Array.from([
                    header.value ? 0 : 1
                ]);
            case "byte":
                return Uint8Array.from([
                    2,
                    header.value
                ]);
            case "short":
                const shortView = new DataView(new ArrayBuffer(3));
                shortView.setUint8(0, 3);
                shortView.setInt16(1, header.value, false);
                return new Uint8Array(shortView.buffer);
            case "integer":
                const intView = new DataView(new ArrayBuffer(5));
                intView.setUint8(0, 4);
                intView.setInt32(1, header.value, false);
                return new Uint8Array(intView.buffer);
            case "long":
                const longBytes = new Uint8Array(9);
                longBytes[0] = 5;
                longBytes.set(header.value.bytes, 1);
                return longBytes;
            case "binary":
                const binView = new DataView(new ArrayBuffer(3 + header.value.byteLength));
                binView.setUint8(0, 6);
                binView.setUint16(1, header.value.byteLength, false);
                const binBytes = new Uint8Array(binView.buffer);
                binBytes.set(header.value, 3);
                return binBytes;
            case "string":
                const utf8Bytes = this.fromUtf8(header.value);
                const strView = new DataView(new ArrayBuffer(3 + utf8Bytes.byteLength));
                strView.setUint8(0, 7);
                strView.setUint16(1, utf8Bytes.byteLength, false);
                const strBytes = new Uint8Array(strView.buffer);
                strBytes.set(utf8Bytes, 3);
                return strBytes;
            case "timestamp":
                const tsBytes = new Uint8Array(9);
                tsBytes[0] = 8;
                tsBytes.set(Int64_1.Int64.fromNumber(header.value.valueOf()).bytes, 1);
                return tsBytes;
            case "uuid":
                if (!UUID_PATTERN.test(header.value)) {
                    throw new Error(`Invalid UUID received: ${header.value}`);
                }
                const uuidBytes = new Uint8Array(17);
                uuidBytes[0] = 9;
                uuidBytes.set((0, util_hex_encoding_1.fromHex)(header.value.replace(/\-/g, "")), 1);
                return uuidBytes;
        }
    }
    parse(headers) {
        const out = {};
        let position = 0;
        while(position < headers.byteLength){
            const nameLength = headers.getUint8(position++);
            const name = this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, nameLength));
            position += nameLength;
            switch(headers.getUint8(position++)){
                case 0:
                    out[name] = {
                        type: BOOLEAN_TAG,
                        value: true
                    };
                    break;
                case 1:
                    out[name] = {
                        type: BOOLEAN_TAG,
                        value: false
                    };
                    break;
                case 2:
                    out[name] = {
                        type: BYTE_TAG,
                        value: headers.getInt8(position++)
                    };
                    break;
                case 3:
                    out[name] = {
                        type: SHORT_TAG,
                        value: headers.getInt16(position, false)
                    };
                    position += 2;
                    break;
                case 4:
                    out[name] = {
                        type: INT_TAG,
                        value: headers.getInt32(position, false)
                    };
                    position += 4;
                    break;
                case 5:
                    out[name] = {
                        type: LONG_TAG,
                        value: new Int64_1.Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8))
                    };
                    position += 8;
                    break;
                case 6:
                    const binaryLength = headers.getUint16(position, false);
                    position += 2;
                    out[name] = {
                        type: BINARY_TAG,
                        value: new Uint8Array(headers.buffer, headers.byteOffset + position, binaryLength)
                    };
                    position += binaryLength;
                    break;
                case 7:
                    const stringLength = headers.getUint16(position, false);
                    position += 2;
                    out[name] = {
                        type: STRING_TAG,
                        value: this.toUtf8(new Uint8Array(headers.buffer, headers.byteOffset + position, stringLength))
                    };
                    position += stringLength;
                    break;
                case 8:
                    out[name] = {
                        type: TIMESTAMP_TAG,
                        value: new Date(new Int64_1.Int64(new Uint8Array(headers.buffer, headers.byteOffset + position, 8)).valueOf())
                    };
                    position += 8;
                    break;
                case 9:
                    const uuidBytes = new Uint8Array(headers.buffer, headers.byteOffset + position, 16);
                    position += 16;
                    out[name] = {
                        type: UUID_TAG,
                        value: `${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(0, 4))}-${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(4, 6))}-${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(6, 8))}-${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(8, 10))}-${(0, util_hex_encoding_1.toHex)(uuidBytes.subarray(10))}`
                    };
                    break;
                default:
                    throw new Error(`Unrecognized header type tag`);
            }
        }
        return out;
    }
}
exports.HeaderMarshaller = HeaderMarshaller;
var HEADER_VALUE_TYPE;
(function(HEADER_VALUE_TYPE) {
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolTrue"] = 0] = "boolTrue";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["boolFalse"] = 1] = "boolFalse";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byte"] = 2] = "byte";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["short"] = 3] = "short";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["integer"] = 4] = "integer";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["long"] = 5] = "long";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["byteArray"] = 6] = "byteArray";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["string"] = 7] = "string";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["timestamp"] = 8] = "timestamp";
    HEADER_VALUE_TYPE[HEADER_VALUE_TYPE["uuid"] = 9] = "uuid";
})(HEADER_VALUE_TYPE || (HEADER_VALUE_TYPE = {}));
const BOOLEAN_TAG = "boolean";
const BYTE_TAG = "byte";
const SHORT_TAG = "short";
const INT_TAG = "integer";
const LONG_TAG = "long";
const BINARY_TAG = "binary";
const STRING_TAG = "string";
const TIMESTAMP_TAG = "timestamp";
const UUID_TAG = "uuid";
const UUID_PATTERN = /^[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}$/;


/***/ }),

/***/ 7403:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Int64 = void 0;
const util_hex_encoding_1 = __webpack_require__(7214);
class Int64 {
    constructor(bytes){
        this.bytes = bytes;
        if (bytes.byteLength !== 8) {
            throw new Error("Int64 buffers must be exactly 8 bytes");
        }
    }
    static fromNumber(number) {
        if (number > 9223372036854776000 || number < -9223372036854776000) {
            throw new Error(`${number} is too large (or, if negative, too small) to represent as an Int64`);
        }
        const bytes = new Uint8Array(8);
        for(let i = 7, remaining = Math.abs(Math.round(number)); i > -1 && remaining > 0; i--, remaining /= 256){
            bytes[i] = remaining;
        }
        if (number < 0) {
            negate(bytes);
        }
        return new Int64(bytes);
    }
    valueOf() {
        const bytes = this.bytes.slice(0);
        const negative = bytes[0] & 128;
        if (negative) {
            negate(bytes);
        }
        return parseInt((0, util_hex_encoding_1.toHex)(bytes), 16) * (negative ? -1 : 1);
    }
    toString() {
        return String(this.valueOf());
    }
}
exports.Int64 = Int64;
function negate(bytes) {
    for(let i = 0; i < 8; i++){
        bytes[i] ^= 0xff;
    }
    for(let i = 7; i > -1; i--){
        bytes[i]++;
        if (bytes[i] !== 0) break;
    }
}


/***/ }),

/***/ 74707:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 36544:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.MessageDecoderStream = void 0;
class MessageDecoderStream {
    constructor(options){
        this.options = options;
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }
    async *asyncIterator() {
        for await (const bytes of this.options.inputStream){
            const decoded = this.options.decoder.decode(bytes);
            yield decoded;
        }
    }
}
exports.MessageDecoderStream = MessageDecoderStream;


/***/ }),

/***/ 9093:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.MessageEncoderStream = void 0;
class MessageEncoderStream {
    constructor(options){
        this.options = options;
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }
    async *asyncIterator() {
        for await (const msg of this.options.messageStream){
            const encoded = this.options.encoder.encode(msg);
            yield encoded;
        }
        if (this.options.includeEndFrame) {
            yield new Uint8Array(0);
        }
    }
}
exports.MessageEncoderStream = MessageEncoderStream;


/***/ }),

/***/ 66724:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SmithyMessageDecoderStream = void 0;
class SmithyMessageDecoderStream {
    constructor(options){
        this.options = options;
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }
    async *asyncIterator() {
        for await (const message of this.options.messageStream){
            const deserialized = await this.options.deserializer(message);
            if (deserialized === undefined) continue;
            yield deserialized;
        }
    }
}
exports.SmithyMessageDecoderStream = SmithyMessageDecoderStream;


/***/ }),

/***/ 13770:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SmithyMessageEncoderStream = void 0;
class SmithyMessageEncoderStream {
    constructor(options){
        this.options = options;
    }
    [Symbol.asyncIterator]() {
        return this.asyncIterator();
    }
    async *asyncIterator() {
        for await (const chunk of this.options.inputStream){
            const payloadBuf = this.options.serializer(chunk);
            yield payloadBuf;
        }
    }
}
exports.SmithyMessageEncoderStream = SmithyMessageEncoderStream;


/***/ }),

/***/ 41992:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(48802), exports);
tslib_1.__exportStar(__webpack_require__(13371), exports);
tslib_1.__exportStar(__webpack_require__(7403), exports);
tslib_1.__exportStar(__webpack_require__(74707), exports);
tslib_1.__exportStar(__webpack_require__(36544), exports);
tslib_1.__exportStar(__webpack_require__(9093), exports);
tslib_1.__exportStar(__webpack_require__(66724), exports);
tslib_1.__exportStar(__webpack_require__(13770), exports);


/***/ }),

/***/ 85582:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.splitMessage = void 0;
const crc32_1 = __webpack_require__(71079);
const PRELUDE_MEMBER_LENGTH = 4;
const PRELUDE_LENGTH = PRELUDE_MEMBER_LENGTH * 2;
const CHECKSUM_LENGTH = 4;
const MINIMUM_MESSAGE_LENGTH = PRELUDE_LENGTH + CHECKSUM_LENGTH * 2;
function splitMessage({ byteLength, byteOffset, buffer }) {
    if (byteLength < MINIMUM_MESSAGE_LENGTH) {
        throw new Error("Provided message too short to accommodate event stream message overhead");
    }
    const view = new DataView(buffer, byteOffset, byteLength);
    const messageLength = view.getUint32(0, false);
    if (byteLength !== messageLength) {
        throw new Error("Reported message length does not match received message length");
    }
    const headerLength = view.getUint32(PRELUDE_MEMBER_LENGTH, false);
    const expectedPreludeChecksum = view.getUint32(PRELUDE_LENGTH, false);
    const expectedMessageChecksum = view.getUint32(byteLength - CHECKSUM_LENGTH, false);
    const checksummer = new crc32_1.Crc32().update(new Uint8Array(buffer, byteOffset, PRELUDE_LENGTH));
    if (expectedPreludeChecksum !== checksummer.digest()) {
        throw new Error(`The prelude checksum specified in the message (${expectedPreludeChecksum}) does not match the calculated CRC32 checksum (${checksummer.digest()})`);
    }
    checksummer.update(new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH, byteLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH)));
    if (expectedMessageChecksum !== checksummer.digest()) {
        throw new Error(`The message checksum (${checksummer.digest()}) did not match the expected value of ${expectedMessageChecksum}`);
    }
    return {
        headers: new DataView(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH, headerLength),
        body: new Uint8Array(buffer, byteOffset + PRELUDE_LENGTH + CHECKSUM_LENGTH + headerLength, messageLength - headerLength - (PRELUDE_LENGTH + CHECKSUM_LENGTH + CHECKSUM_LENGTH))
    };
}
exports.splitMessage = splitMessage;


/***/ }),

/***/ 44341:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Hash = void 0;
const util_buffer_from_1 = __webpack_require__(72813);
const util_utf8_1 = __webpack_require__(66120);
const buffer_1 = __webpack_require__(14300);
const crypto_1 = __webpack_require__(6113);
class Hash {
    constructor(algorithmIdentifier, secret){
        this.algorithmIdentifier = algorithmIdentifier;
        this.secret = secret;
        this.reset();
    }
    update(toHash, encoding) {
        this.hash.update((0, util_utf8_1.toUint8Array)(castSourceData(toHash, encoding)));
    }
    digest() {
        return Promise.resolve(this.hash.digest());
    }
    reset() {
        this.hash = this.secret ? (0, crypto_1.createHmac)(this.algorithmIdentifier, castSourceData(this.secret)) : (0, crypto_1.createHash)(this.algorithmIdentifier);
    }
}
exports.Hash = Hash;
function castSourceData(toCast, encoding) {
    if (buffer_1.Buffer.isBuffer(toCast)) {
        return toCast;
    }
    if (typeof toCast === "string") {
        return (0, util_buffer_from_1.fromString)(toCast, encoding);
    }
    if (ArrayBuffer.isView(toCast)) {
        return (0, util_buffer_from_1.fromArrayBuffer)(toCast.buffer, toCast.byteOffset, toCast.byteLength);
    }
    return (0, util_buffer_from_1.fromArrayBuffer)(toCast);
}


/***/ }),

/***/ 63530:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isArrayBuffer = void 0;
const isArrayBuffer = (arg)=>typeof ArrayBuffer === "function" && arg instanceof ArrayBuffer || Object.prototype.toString.call(arg) === "[object ArrayBuffer]";
exports.isArrayBuffer = isArrayBuffer;


/***/ }),

/***/ 32636:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getContentLengthPlugin = exports.contentLengthMiddlewareOptions = exports.contentLengthMiddleware = void 0;
const protocol_http_1 = __webpack_require__(64082);
const CONTENT_LENGTH_HEADER = "content-length";
function contentLengthMiddleware(bodyLengthChecker) {
    return (next)=>async (args)=>{
            const request = args.request;
            if (protocol_http_1.HttpRequest.isInstance(request)) {
                const { body, headers } = request;
                if (body && Object.keys(headers).map((str)=>str.toLowerCase()).indexOf(CONTENT_LENGTH_HEADER) === -1) {
                    try {
                        const length = bodyLengthChecker(body);
                        request.headers = {
                            ...request.headers,
                            [CONTENT_LENGTH_HEADER]: String(length)
                        };
                    } catch (error) {}
                }
            }
            return next({
                ...args,
                request
            });
        };
}
exports.contentLengthMiddleware = contentLengthMiddleware;
exports.contentLengthMiddlewareOptions = {
    step: "build",
    tags: [
        "SET_CONTENT_LENGTH",
        "CONTENT_LENGTH"
    ],
    name: "contentLengthMiddleware",
    override: true
};
const getContentLengthPlugin = (options)=>({
        applyToStack: (clientStack)=>{
            clientStack.add(contentLengthMiddleware(options.bodyLengthChecker), exports.contentLengthMiddlewareOptions);
        }
    });
exports.getContentLengthPlugin = getContentLengthPlugin;


/***/ }),

/***/ 94649:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createConfigValueProvider = void 0;
const createConfigValueProvider = (configKey, canonicalEndpointParamKey, config)=>{
    const configProvider = async ()=>{
        var _a;
        const configValue = (_a = config[configKey]) !== null && _a !== void 0 ? _a : config[canonicalEndpointParamKey];
        if (typeof configValue === "function") {
            return configValue();
        }
        return configValue;
    };
    if (configKey === "endpoint" || canonicalEndpointParamKey === "endpoint") {
        return async ()=>{
            const endpoint = await configProvider();
            if (endpoint && typeof endpoint === "object") {
                if ("url" in endpoint) {
                    return endpoint.url.href;
                }
                if ("hostname" in endpoint) {
                    const { protocol, hostname, port, path } = endpoint;
                    return `${protocol}//${hostname}${port ? ":" + port : ""}${path}`;
                }
            }
            return endpoint;
        };
    }
    return configProvider;
};
exports.createConfigValueProvider = createConfigValueProvider;


/***/ }),

/***/ 41069:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveParams = exports.getEndpointFromInstructions = void 0;
const service_customizations_1 = __webpack_require__(78480);
const createConfigValueProvider_1 = __webpack_require__(94649);
const getEndpointFromInstructions = async (commandInput, instructionsSupplier, clientConfig, context)=>{
    const endpointParams = await (0, exports.resolveParams)(commandInput, instructionsSupplier, clientConfig);
    if (typeof clientConfig.endpointProvider !== "function") {
        throw new Error("config.endpointProvider is not set.");
    }
    const endpoint = clientConfig.endpointProvider(endpointParams, context);
    return endpoint;
};
exports.getEndpointFromInstructions = getEndpointFromInstructions;
const resolveParams = async (commandInput, instructionsSupplier, clientConfig)=>{
    var _a;
    const endpointParams = {};
    const instructions = ((_a = instructionsSupplier === null || instructionsSupplier === void 0 ? void 0 : instructionsSupplier.getEndpointParameterInstructions) === null || _a === void 0 ? void 0 : _a.call(instructionsSupplier)) || {};
    for (const [name, instruction] of Object.entries(instructions)){
        switch(instruction.type){
            case "staticContextParams":
                endpointParams[name] = instruction.value;
                break;
            case "contextParams":
                endpointParams[name] = commandInput[instruction.name];
                break;
            case "clientContextParams":
            case "builtInParams":
                endpointParams[name] = await (0, createConfigValueProvider_1.createConfigValueProvider)(instruction.name, name, clientConfig)();
                break;
            default:
                throw new Error("Unrecognized endpoint parameter instruction: " + JSON.stringify(instruction));
        }
    }
    if (Object.keys(instructions).length === 0) {
        Object.assign(endpointParams, clientConfig);
    }
    if (String(clientConfig.serviceId).toLowerCase() === "s3") {
        await (0, service_customizations_1.resolveParamsForS3)(endpointParams);
    }
    return endpointParams;
};
exports.resolveParams = resolveParams;


/***/ }),

/***/ 82242:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(41069), exports);
tslib_1.__exportStar(__webpack_require__(35445), exports);


/***/ }),

/***/ 35445:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.toEndpointV1 = void 0;
const url_parser_1 = __webpack_require__(45110);
const toEndpointV1 = (endpoint)=>{
    if (typeof endpoint === "object") {
        if ("url" in endpoint) {
            return (0, url_parser_1.parseUrl)(endpoint.url);
        }
        return endpoint;
    }
    return (0, url_parser_1.parseUrl)(endpoint);
};
exports.toEndpointV1 = toEndpointV1;


/***/ }),

/***/ 89592:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.endpointMiddleware = void 0;
const getEndpointFromInstructions_1 = __webpack_require__(41069);
const endpointMiddleware = ({ config, instructions })=>{
    return (next, context)=>async (args)=>{
            var _a, _b;
            const endpoint = await (0, getEndpointFromInstructions_1.getEndpointFromInstructions)(args.input, {
                getEndpointParameterInstructions () {
                    return instructions;
                }
            }, {
                ...config
            }, context);
            context.endpointV2 = endpoint;
            context.authSchemes = (_a = endpoint.properties) === null || _a === void 0 ? void 0 : _a.authSchemes;
            const authScheme = (_b = context.authSchemes) === null || _b === void 0 ? void 0 : _b[0];
            if (authScheme) {
                context["signing_region"] = authScheme.signingRegion;
                context["signing_service"] = authScheme.signingName;
            }
            return next({
                ...args
            });
        };
};
exports.endpointMiddleware = endpointMiddleware;


/***/ }),

/***/ 16682:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getEndpointPlugin = exports.endpointMiddlewareOptions = void 0;
const middleware_serde_1 = __webpack_require__(22406);
const endpointMiddleware_1 = __webpack_require__(89592);
exports.endpointMiddlewareOptions = {
    step: "serialize",
    tags: [
        "ENDPOINT_PARAMETERS",
        "ENDPOINT_V2",
        "ENDPOINT"
    ],
    name: "endpointV2Middleware",
    override: true,
    relation: "before",
    toMiddleware: middleware_serde_1.serializerMiddlewareOption.name
};
const getEndpointPlugin = (config, instructions)=>({
        applyToStack: (clientStack)=>{
            clientStack.addRelativeTo((0, endpointMiddleware_1.endpointMiddleware)({
                config,
                instructions
            }), exports.endpointMiddlewareOptions);
        }
    });
exports.getEndpointPlugin = getEndpointPlugin;


/***/ }),

/***/ 33692:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(82242), exports);
tslib_1.__exportStar(__webpack_require__(89592), exports);
tslib_1.__exportStar(__webpack_require__(16682), exports);
tslib_1.__exportStar(__webpack_require__(77126), exports);
tslib_1.__exportStar(__webpack_require__(59477), exports);


/***/ }),

/***/ 77126:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveEndpointConfig = void 0;
const util_middleware_1 = __webpack_require__(5837);
const toEndpointV1_1 = __webpack_require__(35445);
const resolveEndpointConfig = (input)=>{
    var _a, _b, _c;
    const tls = (_a = input.tls) !== null && _a !== void 0 ? _a : true;
    const { endpoint } = input;
    const customEndpointProvider = endpoint != null ? async ()=>(0, toEndpointV1_1.toEndpointV1)(await (0, util_middleware_1.normalizeProvider)(endpoint)()) : undefined;
    const isCustomEndpoint = !!endpoint;
    return {
        ...input,
        endpoint: customEndpointProvider,
        tls,
        isCustomEndpoint,
        useDualstackEndpoint: (0, util_middleware_1.normalizeProvider)((_b = input.useDualstackEndpoint) !== null && _b !== void 0 ? _b : false),
        useFipsEndpoint: (0, util_middleware_1.normalizeProvider)((_c = input.useFipsEndpoint) !== null && _c !== void 0 ? _c : false)
    };
};
exports.resolveEndpointConfig = resolveEndpointConfig;


/***/ }),

/***/ 78480:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(17280), exports);


/***/ }),

/***/ 17280:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isArnBucketName = exports.isDnsCompatibleBucketName = exports.S3_HOSTNAME_PATTERN = exports.DOT_PATTERN = exports.resolveParamsForS3 = void 0;
const resolveParamsForS3 = async (endpointParams)=>{
    const bucket = (endpointParams === null || endpointParams === void 0 ? void 0 : endpointParams.Bucket) || "";
    if (typeof endpointParams.Bucket === "string") {
        endpointParams.Bucket = bucket.replace(/#/g, encodeURIComponent("#")).replace(/\?/g, encodeURIComponent("?"));
    }
    if ((0, exports.isArnBucketName)(bucket)) {
        if (endpointParams.ForcePathStyle === true) {
            throw new Error("Path-style addressing cannot be used with ARN buckets");
        }
    } else if (!(0, exports.isDnsCompatibleBucketName)(bucket) || bucket.indexOf(".") !== -1 && !String(endpointParams.Endpoint).startsWith("http:") || bucket.toLowerCase() !== bucket || bucket.length < 3) {
        endpointParams.ForcePathStyle = true;
    }
    if (endpointParams.DisableMultiRegionAccessPoints) {
        endpointParams.disableMultiRegionAccessPoints = true;
        endpointParams.DisableMRAP = true;
    }
    return endpointParams;
};
exports.resolveParamsForS3 = resolveParamsForS3;
const DOMAIN_PATTERN = /^[a-z0-9][a-z0-9\.\-]{1,61}[a-z0-9]$/;
const IP_ADDRESS_PATTERN = /(\d+\.){3}\d+/;
const DOTS_PATTERN = /\.\./;
exports.DOT_PATTERN = /\./;
exports.S3_HOSTNAME_PATTERN = /^(.+\.)?s3(-fips)?(\.dualstack)?[.-]([a-z0-9-]+)\./;
const isDnsCompatibleBucketName = (bucketName)=>DOMAIN_PATTERN.test(bucketName) && !IP_ADDRESS_PATTERN.test(bucketName) && !DOTS_PATTERN.test(bucketName);
exports.isDnsCompatibleBucketName = isDnsCompatibleBucketName;
const isArnBucketName = (bucketName)=>{
    const [arn, partition, service, region, account, typeOrId] = bucketName.split(":");
    const isArn = arn === "arn" && bucketName.split(":").length >= 6;
    const isValidArn = [
        arn,
        partition,
        service,
        account,
        typeOrId
    ].filter(Boolean).length === 5;
    if (isArn && !isValidArn) {
        throw new Error(`Invalid ARN: ${bucketName} was an invalid ARN.`);
    }
    return arn === "arn" && !!partition && !!service && !!account && !!typeOrId;
};
exports.isArnBucketName = isArnBucketName;


/***/ }),

/***/ 59477:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 51667:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdaptiveRetryStrategy = void 0;
const util_retry_1 = __webpack_require__(7885);
const StandardRetryStrategy_1 = __webpack_require__(89292);
class AdaptiveRetryStrategy extends StandardRetryStrategy_1.StandardRetryStrategy {
    constructor(maxAttemptsProvider, options){
        const { rateLimiter, ...superOptions } = options !== null && options !== void 0 ? options : {};
        super(maxAttemptsProvider, superOptions);
        this.rateLimiter = rateLimiter !== null && rateLimiter !== void 0 ? rateLimiter : new util_retry_1.DefaultRateLimiter();
        this.mode = util_retry_1.RETRY_MODES.ADAPTIVE;
    }
    async retry(next, args) {
        return super.retry(next, args, {
            beforeRequest: async ()=>{
                return this.rateLimiter.getSendToken();
            },
            afterRequest: (response)=>{
                this.rateLimiter.updateClientSendingRate(response);
            }
        });
    }
}
exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;


/***/ }),

/***/ 89292:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.StandardRetryStrategy = void 0;
const protocol_http_1 = __webpack_require__(64082);
const service_error_classification_1 = __webpack_require__(69121);
const util_retry_1 = __webpack_require__(7885);
const uuid_1 = __webpack_require__(73078);
const defaultRetryQuota_1 = __webpack_require__(81177);
const delayDecider_1 = __webpack_require__(52411);
const retryDecider_1 = __webpack_require__(80282);
const util_1 = __webpack_require__(5592);
class StandardRetryStrategy {
    constructor(maxAttemptsProvider, options){
        var _a, _b, _c;
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.mode = util_retry_1.RETRY_MODES.STANDARD;
        this.retryDecider = (_a = options === null || options === void 0 ? void 0 : options.retryDecider) !== null && _a !== void 0 ? _a : retryDecider_1.defaultRetryDecider;
        this.delayDecider = (_b = options === null || options === void 0 ? void 0 : options.delayDecider) !== null && _b !== void 0 ? _b : delayDecider_1.defaultDelayDecider;
        this.retryQuota = (_c = options === null || options === void 0 ? void 0 : options.retryQuota) !== null && _c !== void 0 ? _c : (0, defaultRetryQuota_1.getDefaultRetryQuota)(util_retry_1.INITIAL_RETRY_TOKENS);
    }
    shouldRetry(error, attempts, maxAttempts) {
        return attempts < maxAttempts && this.retryDecider(error) && this.retryQuota.hasRetryTokens(error);
    }
    async getMaxAttempts() {
        let maxAttempts;
        try {
            maxAttempts = await this.maxAttemptsProvider();
        } catch (error) {
            maxAttempts = util_retry_1.DEFAULT_MAX_ATTEMPTS;
        }
        return maxAttempts;
    }
    async retry(next, args, options) {
        let retryTokenAmount;
        let attempts = 0;
        let totalDelay = 0;
        const maxAttempts = await this.getMaxAttempts();
        const { request } = args;
        if (protocol_http_1.HttpRequest.isInstance(request)) {
            request.headers[util_retry_1.INVOCATION_ID_HEADER] = (0, uuid_1.v4)();
        }
        while(true){
            try {
                if (protocol_http_1.HttpRequest.isInstance(request)) {
                    request.headers[util_retry_1.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                }
                if (options === null || options === void 0 ? void 0 : options.beforeRequest) {
                    await options.beforeRequest();
                }
                const { response, output } = await next(args);
                if (options === null || options === void 0 ? void 0 : options.afterRequest) {
                    options.afterRequest(response);
                }
                this.retryQuota.releaseRetryTokens(retryTokenAmount);
                output.$metadata.attempts = attempts + 1;
                output.$metadata.totalRetryDelay = totalDelay;
                return {
                    response,
                    output
                };
            } catch (e) {
                const err = (0, util_1.asSdkError)(e);
                attempts++;
                if (this.shouldRetry(err, attempts, maxAttempts)) {
                    retryTokenAmount = this.retryQuota.retrieveRetryTokens(err);
                    const delayFromDecider = this.delayDecider((0, service_error_classification_1.isThrottlingError)(err) ? util_retry_1.THROTTLING_RETRY_DELAY_BASE : util_retry_1.DEFAULT_RETRY_DELAY_BASE, attempts);
                    const delayFromResponse = getDelayFromRetryAfterHeader(err.$response);
                    const delay = Math.max(delayFromResponse || 0, delayFromDecider);
                    totalDelay += delay;
                    await new Promise((resolve)=>setTimeout(resolve, delay));
                    continue;
                }
                if (!err.$metadata) {
                    err.$metadata = {};
                }
                err.$metadata.attempts = attempts;
                err.$metadata.totalRetryDelay = totalDelay;
                throw err;
            }
        }
    }
}
exports.StandardRetryStrategy = StandardRetryStrategy;
const getDelayFromRetryAfterHeader = (response)=>{
    if (!protocol_http_1.HttpResponse.isInstance(response)) return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key)=>key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName) return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds)) return retryAfterSeconds * 1000;
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate.getTime() - Date.now();
};


/***/ }),

/***/ 25793:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NODE_RETRY_MODE_CONFIG_OPTIONS = exports.CONFIG_RETRY_MODE = exports.ENV_RETRY_MODE = exports.resolveRetryConfig = exports.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = exports.CONFIG_MAX_ATTEMPTS = exports.ENV_MAX_ATTEMPTS = void 0;
const util_middleware_1 = __webpack_require__(5837);
const util_retry_1 = __webpack_require__(7885);
exports.ENV_MAX_ATTEMPTS = "AWS_MAX_ATTEMPTS";
exports.CONFIG_MAX_ATTEMPTS = "max_attempts";
exports.NODE_MAX_ATTEMPT_CONFIG_OPTIONS = {
    environmentVariableSelector: (env)=>{
        const value = env[exports.ENV_MAX_ATTEMPTS];
        if (!value) return undefined;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
            throw new Error(`Environment variable ${exports.ENV_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
    },
    configFileSelector: (profile)=>{
        const value = profile[exports.CONFIG_MAX_ATTEMPTS];
        if (!value) return undefined;
        const maxAttempt = parseInt(value);
        if (Number.isNaN(maxAttempt)) {
            throw new Error(`Shared config file entry ${exports.CONFIG_MAX_ATTEMPTS} mast be a number, got "${value}"`);
        }
        return maxAttempt;
    },
    default: util_retry_1.DEFAULT_MAX_ATTEMPTS
};
const resolveRetryConfig = (input)=>{
    var _a;
    const { retryStrategy } = input;
    const maxAttempts = (0, util_middleware_1.normalizeProvider)((_a = input.maxAttempts) !== null && _a !== void 0 ? _a : util_retry_1.DEFAULT_MAX_ATTEMPTS);
    return {
        ...input,
        maxAttempts,
        retryStrategy: async ()=>{
            if (retryStrategy) {
                return retryStrategy;
            }
            const retryMode = await (0, util_middleware_1.normalizeProvider)(input.retryMode)();
            if (retryMode === util_retry_1.RETRY_MODES.ADAPTIVE) {
                return new util_retry_1.AdaptiveRetryStrategy(maxAttempts);
            }
            return new util_retry_1.StandardRetryStrategy(maxAttempts);
        }
    };
};
exports.resolveRetryConfig = resolveRetryConfig;
exports.ENV_RETRY_MODE = "AWS_RETRY_MODE";
exports.CONFIG_RETRY_MODE = "retry_mode";
exports.NODE_RETRY_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env)=>env[exports.ENV_RETRY_MODE],
    configFileSelector: (profile)=>profile[exports.CONFIG_RETRY_MODE],
    default: util_retry_1.DEFAULT_RETRY_MODE
};


/***/ }),

/***/ 81177:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getDefaultRetryQuota = void 0;
const util_retry_1 = __webpack_require__(7885);
const getDefaultRetryQuota = (initialRetryTokens, options)=>{
    var _a, _b, _c;
    const MAX_CAPACITY = initialRetryTokens;
    const noRetryIncrement = (_a = options === null || options === void 0 ? void 0 : options.noRetryIncrement) !== null && _a !== void 0 ? _a : util_retry_1.NO_RETRY_INCREMENT;
    const retryCost = (_b = options === null || options === void 0 ? void 0 : options.retryCost) !== null && _b !== void 0 ? _b : util_retry_1.RETRY_COST;
    const timeoutRetryCost = (_c = options === null || options === void 0 ? void 0 : options.timeoutRetryCost) !== null && _c !== void 0 ? _c : util_retry_1.TIMEOUT_RETRY_COST;
    let availableCapacity = initialRetryTokens;
    const getCapacityAmount = (error)=>error.name === "TimeoutError" ? timeoutRetryCost : retryCost;
    const hasRetryTokens = (error)=>getCapacityAmount(error) <= availableCapacity;
    const retrieveRetryTokens = (error)=>{
        if (!hasRetryTokens(error)) {
            throw new Error("No retry token available");
        }
        const capacityAmount = getCapacityAmount(error);
        availableCapacity -= capacityAmount;
        return capacityAmount;
    };
    const releaseRetryTokens = (capacityReleaseAmount)=>{
        availableCapacity += capacityReleaseAmount !== null && capacityReleaseAmount !== void 0 ? capacityReleaseAmount : noRetryIncrement;
        availableCapacity = Math.min(availableCapacity, MAX_CAPACITY);
    };
    return Object.freeze({
        hasRetryTokens,
        retrieveRetryTokens,
        releaseRetryTokens
    });
};
exports.getDefaultRetryQuota = getDefaultRetryQuota;


/***/ }),

/***/ 52411:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.defaultDelayDecider = void 0;
const util_retry_1 = __webpack_require__(7885);
const defaultDelayDecider = (delayBase, attempts)=>Math.floor(Math.min(util_retry_1.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
exports.defaultDelayDecider = defaultDelayDecider;


/***/ }),

/***/ 75567:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(51667), exports);
tslib_1.__exportStar(__webpack_require__(89292), exports);
tslib_1.__exportStar(__webpack_require__(25793), exports);
tslib_1.__exportStar(__webpack_require__(52411), exports);
tslib_1.__exportStar(__webpack_require__(32798), exports);
tslib_1.__exportStar(__webpack_require__(80282), exports);
tslib_1.__exportStar(__webpack_require__(76611), exports);


/***/ }),

/***/ 32798:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getOmitRetryHeadersPlugin = exports.omitRetryHeadersMiddlewareOptions = exports.omitRetryHeadersMiddleware = void 0;
const protocol_http_1 = __webpack_require__(64082);
const util_retry_1 = __webpack_require__(7885);
const omitRetryHeadersMiddleware = ()=>(next)=>async (args)=>{
            const { request } = args;
            if (protocol_http_1.HttpRequest.isInstance(request)) {
                delete request.headers[util_retry_1.INVOCATION_ID_HEADER];
                delete request.headers[util_retry_1.REQUEST_HEADER];
            }
            return next(args);
        };
exports.omitRetryHeadersMiddleware = omitRetryHeadersMiddleware;
exports.omitRetryHeadersMiddlewareOptions = {
    name: "omitRetryHeadersMiddleware",
    tags: [
        "RETRY",
        "HEADERS",
        "OMIT_RETRY_HEADERS"
    ],
    relation: "before",
    toMiddleware: "awsAuthMiddleware",
    override: true
};
const getOmitRetryHeadersPlugin = (options)=>({
        applyToStack: (clientStack)=>{
            clientStack.addRelativeTo((0, exports.omitRetryHeadersMiddleware)(), exports.omitRetryHeadersMiddlewareOptions);
        }
    });
exports.getOmitRetryHeadersPlugin = getOmitRetryHeadersPlugin;


/***/ }),

/***/ 80282:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.defaultRetryDecider = void 0;
const service_error_classification_1 = __webpack_require__(69121);
const defaultRetryDecider = (error)=>{
    if (!error) {
        return false;
    }
    return (0, service_error_classification_1.isRetryableByTrait)(error) || (0, service_error_classification_1.isClockSkewError)(error) || (0, service_error_classification_1.isThrottlingError)(error) || (0, service_error_classification_1.isTransientError)(error);
};
exports.defaultRetryDecider = defaultRetryDecider;


/***/ }),

/***/ 76611:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getRetryAfterHint = exports.getRetryPlugin = exports.retryMiddlewareOptions = exports.retryMiddleware = void 0;
const protocol_http_1 = __webpack_require__(64082);
const service_error_classification_1 = __webpack_require__(69121);
const util_retry_1 = __webpack_require__(7885);
const uuid_1 = __webpack_require__(73078);
const util_1 = __webpack_require__(5592);
const retryMiddleware = (options)=>(next, context)=>async (args)=>{
            let retryStrategy = await options.retryStrategy();
            const maxAttempts = await options.maxAttempts();
            if (isRetryStrategyV2(retryStrategy)) {
                retryStrategy = retryStrategy;
                let retryToken = await retryStrategy.acquireInitialRetryToken(context["partition_id"]);
                let lastError = new Error();
                let attempts = 0;
                let totalRetryDelay = 0;
                const { request } = args;
                if (protocol_http_1.HttpRequest.isInstance(request)) {
                    request.headers[util_retry_1.INVOCATION_ID_HEADER] = (0, uuid_1.v4)();
                }
                while(true){
                    try {
                        if (protocol_http_1.HttpRequest.isInstance(request)) {
                            request.headers[util_retry_1.REQUEST_HEADER] = `attempt=${attempts + 1}; max=${maxAttempts}`;
                        }
                        const { response, output } = await next(args);
                        retryStrategy.recordSuccess(retryToken);
                        output.$metadata.attempts = attempts + 1;
                        output.$metadata.totalRetryDelay = totalRetryDelay;
                        return {
                            response,
                            output
                        };
                    } catch (e) {
                        const retryErrorInfo = getRetryErrorInfo(e);
                        lastError = (0, util_1.asSdkError)(e);
                        try {
                            retryToken = await retryStrategy.refreshRetryTokenForRetry(retryToken, retryErrorInfo);
                        } catch (refreshError) {
                            if (!lastError.$metadata) {
                                lastError.$metadata = {};
                            }
                            lastError.$metadata.attempts = attempts + 1;
                            lastError.$metadata.totalRetryDelay = totalRetryDelay;
                            throw lastError;
                        }
                        attempts = retryToken.getRetryCount();
                        const delay = retryToken.getRetryDelay();
                        totalRetryDelay += delay;
                        await new Promise((resolve)=>setTimeout(resolve, delay));
                    }
                }
            } else {
                retryStrategy = retryStrategy;
                if (retryStrategy === null || retryStrategy === void 0 ? void 0 : retryStrategy.mode) context.userAgent = [
                    ...context.userAgent || [],
                    [
                        "cfg/retry-mode",
                        retryStrategy.mode
                    ]
                ];
                return retryStrategy.retry(next, args);
            }
        };
exports.retryMiddleware = retryMiddleware;
const isRetryStrategyV2 = (retryStrategy)=>typeof retryStrategy.acquireInitialRetryToken !== "undefined" && typeof retryStrategy.refreshRetryTokenForRetry !== "undefined" && typeof retryStrategy.recordSuccess !== "undefined";
const getRetryErrorInfo = (error)=>{
    const errorInfo = {
        errorType: getRetryErrorType(error)
    };
    const retryAfterHint = (0, exports.getRetryAfterHint)(error.$response);
    if (retryAfterHint) {
        errorInfo.retryAfterHint = retryAfterHint;
    }
    return errorInfo;
};
const getRetryErrorType = (error)=>{
    if ((0, service_error_classification_1.isThrottlingError)(error)) return "THROTTLING";
    if ((0, service_error_classification_1.isTransientError)(error)) return "TRANSIENT";
    if ((0, service_error_classification_1.isServerError)(error)) return "SERVER_ERROR";
    return "CLIENT_ERROR";
};
exports.retryMiddlewareOptions = {
    name: "retryMiddleware",
    tags: [
        "RETRY"
    ],
    step: "finalizeRequest",
    priority: "high",
    override: true
};
const getRetryPlugin = (options)=>({
        applyToStack: (clientStack)=>{
            clientStack.add((0, exports.retryMiddleware)(options), exports.retryMiddlewareOptions);
        }
    });
exports.getRetryPlugin = getRetryPlugin;
const getRetryAfterHint = (response)=>{
    if (!protocol_http_1.HttpResponse.isInstance(response)) return;
    const retryAfterHeaderName = Object.keys(response.headers).find((key)=>key.toLowerCase() === "retry-after");
    if (!retryAfterHeaderName) return;
    const retryAfter = response.headers[retryAfterHeaderName];
    const retryAfterSeconds = Number(retryAfter);
    if (!Number.isNaN(retryAfterSeconds)) return new Date(retryAfterSeconds * 1000);
    const retryAfterDate = new Date(retryAfter);
    return retryAfterDate;
};
exports.getRetryAfterHint = getRetryAfterHint;


/***/ }),

/***/ 5592:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.asSdkError = void 0;
const asSdkError = (error)=>{
    if (error instanceof Error) return error;
    if (error instanceof Object) return Object.assign(new Error(), error);
    if (typeof error === "string") return new Error(error);
    return new Error(`AWS SDK error wrapper for ${error}`);
};
exports.asSdkError = asSdkError;


/***/ }),

/***/ 52828:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.deserializerMiddleware = void 0;
const deserializerMiddleware = (options, deserializer)=>(next, context)=>async (args)=>{
            const { response } = await next(args);
            try {
                const parsed = await deserializer(response, options);
                return {
                    response,
                    output: parsed
                };
            } catch (error) {
                Object.defineProperty(error, "$response", {
                    value: response
                });
                if (!("$metadata" in error)) {
                    const hint = `Deserialization error: to see the raw response, inspect the hidden field {error}.$response on this object.`;
                    error.message += "\n  " + hint;
                }
                throw error;
            }
        };
exports.deserializerMiddleware = deserializerMiddleware;


/***/ }),

/***/ 22406:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(52828), exports);
tslib_1.__exportStar(__webpack_require__(27887), exports);
tslib_1.__exportStar(__webpack_require__(23441), exports);


/***/ }),

/***/ 27887:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getSerdePlugin = exports.serializerMiddlewareOption = exports.deserializerMiddlewareOption = void 0;
const deserializerMiddleware_1 = __webpack_require__(52828);
const serializerMiddleware_1 = __webpack_require__(23441);
exports.deserializerMiddlewareOption = {
    name: "deserializerMiddleware",
    step: "deserialize",
    tags: [
        "DESERIALIZER"
    ],
    override: true
};
exports.serializerMiddlewareOption = {
    name: "serializerMiddleware",
    step: "serialize",
    tags: [
        "SERIALIZER"
    ],
    override: true
};
function getSerdePlugin(config, serializer, deserializer) {
    return {
        applyToStack: (commandStack)=>{
            commandStack.add((0, deserializerMiddleware_1.deserializerMiddleware)(config, deserializer), exports.deserializerMiddlewareOption);
            commandStack.add((0, serializerMiddleware_1.serializerMiddleware)(config, serializer), exports.serializerMiddlewareOption);
        }
    };
}
exports.getSerdePlugin = getSerdePlugin;


/***/ }),

/***/ 23441:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.serializerMiddleware = void 0;
const serializerMiddleware = (options, serializer)=>(next, context)=>async (args)=>{
            var _a;
            const endpoint = ((_a = context.endpointV2) === null || _a === void 0 ? void 0 : _a.url) && options.urlParser ? async ()=>options.urlParser(context.endpointV2.url) : options.endpoint;
            if (!endpoint) {
                throw new Error("No valid endpoint provider available.");
            }
            const request = await serializer(args.input, {
                ...options,
                endpoint
            });
            return next({
                ...args,
                request
            });
        };
exports.serializerMiddleware = serializerMiddleware;


/***/ }),

/***/ 23708:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.constructStack = void 0;
const constructStack = ()=>{
    let absoluteEntries = [];
    let relativeEntries = [];
    const entriesNameSet = new Set();
    const sort = (entries)=>entries.sort((a, b)=>stepWeights[b.step] - stepWeights[a.step] || priorityWeights[b.priority || "normal"] - priorityWeights[a.priority || "normal"]);
    const removeByName = (toRemove)=>{
        let isRemoved = false;
        const filterCb = (entry)=>{
            if (entry.name && entry.name === toRemove) {
                isRemoved = true;
                entriesNameSet.delete(toRemove);
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const removeByReference = (toRemove)=>{
        let isRemoved = false;
        const filterCb = (entry)=>{
            if (entry.middleware === toRemove) {
                isRemoved = true;
                if (entry.name) entriesNameSet.delete(entry.name);
                return false;
            }
            return true;
        };
        absoluteEntries = absoluteEntries.filter(filterCb);
        relativeEntries = relativeEntries.filter(filterCb);
        return isRemoved;
    };
    const cloneTo = (toStack)=>{
        absoluteEntries.forEach((entry)=>{
            toStack.add(entry.middleware, {
                ...entry
            });
        });
        relativeEntries.forEach((entry)=>{
            toStack.addRelativeTo(entry.middleware, {
                ...entry
            });
        });
        return toStack;
    };
    const expandRelativeMiddlewareList = (from)=>{
        const expandedMiddlewareList = [];
        from.before.forEach((entry)=>{
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            } else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        expandedMiddlewareList.push(from);
        from.after.reverse().forEach((entry)=>{
            if (entry.before.length === 0 && entry.after.length === 0) {
                expandedMiddlewareList.push(entry);
            } else {
                expandedMiddlewareList.push(...expandRelativeMiddlewareList(entry));
            }
        });
        return expandedMiddlewareList;
    };
    const getMiddlewareList = (debug = false)=>{
        const normalizedAbsoluteEntries = [];
        const normalizedRelativeEntries = [];
        const normalizedEntriesNameMap = {};
        absoluteEntries.forEach((entry)=>{
            const normalizedEntry = {
                ...entry,
                before: [],
                after: []
            };
            if (normalizedEntry.name) normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
            normalizedAbsoluteEntries.push(normalizedEntry);
        });
        relativeEntries.forEach((entry)=>{
            const normalizedEntry = {
                ...entry,
                before: [],
                after: []
            };
            if (normalizedEntry.name) normalizedEntriesNameMap[normalizedEntry.name] = normalizedEntry;
            normalizedRelativeEntries.push(normalizedEntry);
        });
        normalizedRelativeEntries.forEach((entry)=>{
            if (entry.toMiddleware) {
                const toMiddleware = normalizedEntriesNameMap[entry.toMiddleware];
                if (toMiddleware === undefined) {
                    if (debug) {
                        return;
                    }
                    throw new Error(`${entry.toMiddleware} is not found when adding ${entry.name || "anonymous"} middleware ${entry.relation} ${entry.toMiddleware}`);
                }
                if (entry.relation === "after") {
                    toMiddleware.after.push(entry);
                }
                if (entry.relation === "before") {
                    toMiddleware.before.push(entry);
                }
            }
        });
        const mainChain = sort(normalizedAbsoluteEntries).map(expandRelativeMiddlewareList).reduce((wholeList, expandedMiddlewareList)=>{
            wholeList.push(...expandedMiddlewareList);
            return wholeList;
        }, []);
        return mainChain;
    };
    const stack = {
        add: (middleware, options = {})=>{
            const { name, override } = options;
            const entry = {
                step: "initialize",
                priority: "normal",
                middleware,
                ...options
            };
            if (name) {
                if (entriesNameSet.has(name)) {
                    if (!override) throw new Error(`Duplicate middleware name '${name}'`);
                    const toOverrideIndex = absoluteEntries.findIndex((entry)=>entry.name === name);
                    const toOverride = absoluteEntries[toOverrideIndex];
                    if (toOverride.step !== entry.step || toOverride.priority !== entry.priority) {
                        throw new Error(`"${name}" middleware with ${toOverride.priority} priority in ${toOverride.step} step cannot be ` + `overridden by same-name middleware with ${entry.priority} priority in ${entry.step} step.`);
                    }
                    absoluteEntries.splice(toOverrideIndex, 1);
                }
                entriesNameSet.add(name);
            }
            absoluteEntries.push(entry);
        },
        addRelativeTo: (middleware, options)=>{
            const { name, override } = options;
            const entry = {
                middleware,
                ...options
            };
            if (name) {
                if (entriesNameSet.has(name)) {
                    if (!override) throw new Error(`Duplicate middleware name '${name}'`);
                    const toOverrideIndex = relativeEntries.findIndex((entry)=>entry.name === name);
                    const toOverride = relativeEntries[toOverrideIndex];
                    if (toOverride.toMiddleware !== entry.toMiddleware || toOverride.relation !== entry.relation) {
                        throw new Error(`"${name}" middleware ${toOverride.relation} "${toOverride.toMiddleware}" middleware cannot be overridden ` + `by same-name middleware ${entry.relation} "${entry.toMiddleware}" middleware.`);
                    }
                    relativeEntries.splice(toOverrideIndex, 1);
                }
                entriesNameSet.add(name);
            }
            relativeEntries.push(entry);
        },
        clone: ()=>cloneTo((0, exports.constructStack)()),
        use: (plugin)=>{
            plugin.applyToStack(stack);
        },
        remove: (toRemove)=>{
            if (typeof toRemove === "string") return removeByName(toRemove);
            else return removeByReference(toRemove);
        },
        removeByTag: (toRemove)=>{
            let isRemoved = false;
            const filterCb = (entry)=>{
                const { tags, name } = entry;
                if (tags && tags.includes(toRemove)) {
                    if (name) entriesNameSet.delete(name);
                    isRemoved = true;
                    return false;
                }
                return true;
            };
            absoluteEntries = absoluteEntries.filter(filterCb);
            relativeEntries = relativeEntries.filter(filterCb);
            return isRemoved;
        },
        concat: (from)=>{
            const cloned = cloneTo((0, exports.constructStack)());
            cloned.use(from);
            return cloned;
        },
        applyToStack: cloneTo,
        identify: ()=>{
            return getMiddlewareList(true).map((mw)=>{
                return mw.name + ": " + (mw.tags || []).join(",");
            });
        },
        resolve: (handler, context)=>{
            for (const middleware of getMiddlewareList().map((entry)=>entry.middleware).reverse()){
                handler = middleware(handler, context);
            }
            return handler;
        }
    };
    return stack;
};
exports.constructStack = constructStack;
const stepWeights = {
    initialize: 5,
    serialize: 4,
    build: 3,
    finalizeRequest: 2,
    deserialize: 1
};
const priorityWeights = {
    high: 3,
    normal: 2,
    low: 1
};


/***/ }),

/***/ 65992:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(23708), exports);


/***/ }),

/***/ 93740:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.loadConfig = void 0;
const property_provider_1 = __webpack_require__(29852);
const fromEnv_1 = __webpack_require__(64527);
const fromSharedConfigFiles_1 = __webpack_require__(10500);
const fromStatic_1 = __webpack_require__(36964);
const loadConfig = ({ environmentVariableSelector, configFileSelector, default: defaultValue }, configuration = {})=>(0, property_provider_1.memoize)((0, property_provider_1.chain)((0, fromEnv_1.fromEnv)(environmentVariableSelector), (0, fromSharedConfigFiles_1.fromSharedConfigFiles)(configFileSelector, configuration), (0, fromStatic_1.fromStatic)(defaultValue)));
exports.loadConfig = loadConfig;


/***/ }),

/***/ 64527:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromEnv = void 0;
const property_provider_1 = __webpack_require__(29852);
const fromEnv = (envVarSelector)=>async ()=>{
        try {
            const config = envVarSelector(process.env);
            if (config === undefined) {
                throw new Error();
            }
            return config;
        } catch (e) {
            throw new property_provider_1.CredentialsProviderError(e.message || `Cannot load config from environment variables with getter: ${envVarSelector}`);
        }
    };
exports.fromEnv = fromEnv;


/***/ }),

/***/ 10500:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromSharedConfigFiles = void 0;
const property_provider_1 = __webpack_require__(29852);
const shared_ini_file_loader_1 = __webpack_require__(3666);
const fromSharedConfigFiles = (configSelector, { preferredFile = "config", ...init } = {})=>async ()=>{
        const profile = (0, shared_ini_file_loader_1.getProfileName)(init);
        const { configFile, credentialsFile } = await (0, shared_ini_file_loader_1.loadSharedConfigFiles)(init);
        const profileFromCredentials = credentialsFile[profile] || {};
        const profileFromConfig = configFile[profile] || {};
        const mergedProfile = preferredFile === "config" ? {
            ...profileFromCredentials,
            ...profileFromConfig
        } : {
            ...profileFromConfig,
            ...profileFromCredentials
        };
        try {
            const configValue = configSelector(mergedProfile);
            if (configValue === undefined) {
                throw new Error();
            }
            return configValue;
        } catch (e) {
            throw new property_provider_1.CredentialsProviderError(e.message || `Cannot load config for profile ${profile} in SDK configuration files with getter: ${configSelector}`);
        }
    };
exports.fromSharedConfigFiles = fromSharedConfigFiles;


/***/ }),

/***/ 36964:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromStatic = void 0;
const property_provider_1 = __webpack_require__(29852);
const isFunction = (func)=>typeof func === "function";
const fromStatic = (defaultValue)=>isFunction(defaultValue) ? async ()=>await defaultValue() : (0, property_provider_1.fromStatic)(defaultValue);
exports.fromStatic = fromStatic;


/***/ }),

/***/ 15829:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(93740), exports);


/***/ }),

/***/ 92694:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NODEJS_TIMEOUT_ERROR_CODES = void 0;
exports.NODEJS_TIMEOUT_ERROR_CODES = [
    "ECONNRESET",
    "EPIPE",
    "ETIMEDOUT"
];


/***/ }),

/***/ 26448:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getTransformedHeaders = void 0;
const getTransformedHeaders = (headers)=>{
    const transformedHeaders = {};
    for (const name of Object.keys(headers)){
        const headerValues = headers[name];
        transformedHeaders[name] = Array.isArray(headerValues) ? headerValues.join(",") : headerValues;
    }
    return transformedHeaders;
};
exports.getTransformedHeaders = getTransformedHeaders;


/***/ }),

/***/ 44025:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(77460), exports);
tslib_1.__exportStar(__webpack_require__(70944), exports);
tslib_1.__exportStar(__webpack_require__(19499), exports);


/***/ }),

/***/ 77460:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NodeHttpHandler = exports.DEFAULT_REQUEST_TIMEOUT = void 0;
const protocol_http_1 = __webpack_require__(64082);
const querystring_builder_1 = __webpack_require__(83140);
const http_1 = __webpack_require__(13685);
const https_1 = __webpack_require__(95687);
const constants_1 = __webpack_require__(92694);
const get_transformed_headers_1 = __webpack_require__(26448);
const set_connection_timeout_1 = __webpack_require__(41305);
const set_socket_keep_alive_1 = __webpack_require__(77915);
const set_socket_timeout_1 = __webpack_require__(44139);
const write_request_body_1 = __webpack_require__(37945);
exports.DEFAULT_REQUEST_TIMEOUT = 0;
class NodeHttpHandler {
    constructor(options){
        this.metadata = {
            handlerProtocol: "http/1.1"
        };
        this.configProvider = new Promise((resolve, reject)=>{
            if (typeof options === "function") {
                options().then((_options)=>{
                    resolve(this.resolveDefaultConfig(_options));
                }).catch(reject);
            } else {
                resolve(this.resolveDefaultConfig(options));
            }
        });
    }
    resolveDefaultConfig(options) {
        const { requestTimeout, connectionTimeout, socketTimeout, httpAgent, httpsAgent } = options || {};
        const keepAlive = true;
        const maxSockets = 50;
        return {
            connectionTimeout,
            requestTimeout: requestTimeout !== null && requestTimeout !== void 0 ? requestTimeout : socketTimeout,
            httpAgent: httpAgent || new http_1.Agent({
                keepAlive,
                maxSockets
            }),
            httpsAgent: httpsAgent || new https_1.Agent({
                keepAlive,
                maxSockets
            })
        };
    }
    destroy() {
        var _a, _b, _c, _d;
        (_b = (_a = this.config) === null || _a === void 0 ? void 0 : _a.httpAgent) === null || _b === void 0 ? void 0 : _b.destroy();
        (_d = (_c = this.config) === null || _c === void 0 ? void 0 : _c.httpsAgent) === null || _d === void 0 ? void 0 : _d.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
        }
        return new Promise((_resolve, _reject)=>{
            var _a, _b;
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg)=>{
                await writeRequestBodyPromise;
                _resolve(arg);
            };
            const reject = async (arg)=>{
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (!this.config) {
                throw new Error("Node HTTP request handler config is not resolved");
            }
            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const isSSL = request.protocol === "https:";
            const queryString = (0, querystring_builder_1.buildQueryString)(request.query || {});
            let auth = undefined;
            if (request.username != null || request.password != null) {
                const username = (_a = request.username) !== null && _a !== void 0 ? _a : "";
                const password = (_b = request.password) !== null && _b !== void 0 ? _b : "";
                auth = `${username}:${password}`;
            }
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const nodeHttpsOptions = {
                headers: request.headers,
                host: request.hostname,
                method: request.method,
                path,
                port: request.port,
                agent: isSSL ? this.config.httpsAgent : this.config.httpAgent,
                auth
            };
            const requestFunc = isSSL ? https_1.request : http_1.request;
            const req = requestFunc(nodeHttpsOptions, (res)=>{
                const httpResponse = new protocol_http_1.HttpResponse({
                    statusCode: res.statusCode || -1,
                    reason: res.statusMessage,
                    headers: (0, get_transformed_headers_1.getTransformedHeaders)(res.headers),
                    body: res
                });
                resolve({
                    response: httpResponse
                });
            });
            req.on("error", (err)=>{
                if (constants_1.NODEJS_TIMEOUT_ERROR_CODES.includes(err.code)) {
                    reject(Object.assign(err, {
                        name: "TimeoutError"
                    }));
                } else {
                    reject(err);
                }
            });
            (0, set_connection_timeout_1.setConnectionTimeout)(req, reject, this.config.connectionTimeout);
            (0, set_socket_timeout_1.setSocketTimeout)(req, reject, this.config.requestTimeout);
            if (abortSignal) {
                abortSignal.onabort = ()=>{
                    req.abort();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    reject(abortError);
                };
            }
            const httpAgent = nodeHttpsOptions.agent;
            if (typeof httpAgent === "object" && "keepAlive" in httpAgent) {
                (0, set_socket_keep_alive_1.setSocketKeepAlive)(req, {
                    keepAlive: httpAgent.keepAlive,
                    keepAliveMsecs: httpAgent.keepAliveMsecs
                });
            }
            writeRequestBodyPromise = (0, write_request_body_1.writeRequestBody)(req, request, this.config.requestTimeout).catch(_reject);
        });
    }
}
exports.NodeHttpHandler = NodeHttpHandler;


/***/ }),

/***/ 41749:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NodeHttp2ConnectionManager = void 0;
const tslib_1 = __webpack_require__(35092);
const http2_1 = tslib_1.__importDefault(__webpack_require__(85158));
const node_http2_connection_pool_1 = __webpack_require__(25813);
class NodeHttp2ConnectionManager {
    constructor(config){
        this.sessionCache = new Map();
        this.config = config;
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrency must be greater than zero.");
        }
    }
    lease(requestContext, connectionConfiguration) {
        const url = this.getUrlString(requestContext);
        const existingPool = this.sessionCache.get(url);
        if (existingPool) {
            const existingSession = existingPool.poll();
            if (existingSession && !this.config.disableConcurrency) {
                return existingSession;
            }
        }
        const session = http2_1.default.connect(url);
        if (this.config.maxConcurrency) {
            session.settings({
                maxConcurrentStreams: this.config.maxConcurrency
            }, (err)=>{
                if (err) {
                    throw new Error("Fail to set maxConcurrentStreams to " + this.config.maxConcurrency + "when creating new session for " + requestContext.destination.toString());
                }
            });
        }
        session.unref();
        const destroySessionCb = ()=>{
            session.destroy();
            this.deleteSession(url, session);
        };
        session.on("goaway", destroySessionCb);
        session.on("error", destroySessionCb);
        session.on("frameError", destroySessionCb);
        session.on("close", ()=>this.deleteSession(url, session));
        if (connectionConfiguration.requestTimeout) {
            session.setTimeout(connectionConfiguration.requestTimeout, destroySessionCb);
        }
        const connectionPool = this.sessionCache.get(url) || new node_http2_connection_pool_1.NodeHttp2ConnectionPool();
        connectionPool.offerLast(session);
        this.sessionCache.set(url, connectionPool);
        return session;
    }
    deleteSession(authority, session) {
        const existingConnectionPool = this.sessionCache.get(authority);
        if (!existingConnectionPool) {
            return;
        }
        if (!existingConnectionPool.contains(session)) {
            return;
        }
        existingConnectionPool.remove(session);
        this.sessionCache.set(authority, existingConnectionPool);
    }
    release(requestContext, session) {
        var _a;
        const cacheKey = this.getUrlString(requestContext);
        (_a = this.sessionCache.get(cacheKey)) === null || _a === void 0 ? void 0 : _a.offerLast(session);
    }
    destroy() {
        for (const [key, connectionPool] of this.sessionCache){
            for (const session of connectionPool){
                if (!session.destroyed) {
                    session.destroy();
                }
                connectionPool.remove(session);
            }
            this.sessionCache.delete(key);
        }
    }
    setMaxConcurrentStreams(maxConcurrentStreams) {
        if (this.config.maxConcurrency && this.config.maxConcurrency <= 0) {
            throw new RangeError("maxConcurrentStreams must be greater than zero.");
        }
        this.config.maxConcurrency = maxConcurrentStreams;
    }
    setDisableConcurrentStreams(disableConcurrentStreams) {
        this.config.disableConcurrency = disableConcurrentStreams;
    }
    getUrlString(request) {
        return request.destination.toString();
    }
}
exports.NodeHttp2ConnectionManager = NodeHttp2ConnectionManager;


/***/ }),

/***/ 25813:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NodeHttp2ConnectionPool = void 0;
class NodeHttp2ConnectionPool {
    constructor(sessions){
        this.sessions = [];
        this.sessions = sessions !== null && sessions !== void 0 ? sessions : [];
    }
    poll() {
        if (this.sessions.length > 0) {
            return this.sessions.shift();
        }
    }
    offerLast(session) {
        this.sessions.push(session);
    }
    contains(session) {
        return this.sessions.includes(session);
    }
    remove(session) {
        this.sessions = this.sessions.filter((s)=>s !== session);
    }
    [Symbol.iterator]() {
        return this.sessions[Symbol.iterator]();
    }
    destroy(connection) {
        for (const session of this.sessions){
            if (session === connection) {
                if (!session.destroyed) {
                    session.destroy();
                }
            }
        }
    }
}
exports.NodeHttp2ConnectionPool = NodeHttp2ConnectionPool;


/***/ }),

/***/ 70944:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NodeHttp2Handler = void 0;
const protocol_http_1 = __webpack_require__(64082);
const querystring_builder_1 = __webpack_require__(83140);
const http2_1 = __webpack_require__(85158);
const get_transformed_headers_1 = __webpack_require__(26448);
const node_http2_connection_manager_1 = __webpack_require__(41749);
const write_request_body_1 = __webpack_require__(37945);
class NodeHttp2Handler {
    constructor(options){
        this.metadata = {
            handlerProtocol: "h2"
        };
        this.connectionManager = new node_http2_connection_manager_1.NodeHttp2ConnectionManager({});
        this.configProvider = new Promise((resolve, reject)=>{
            if (typeof options === "function") {
                options().then((opts)=>{
                    resolve(opts || {});
                }).catch(reject);
            } else {
                resolve(options || {});
            }
        });
    }
    destroy() {
        this.connectionManager.destroy();
    }
    async handle(request, { abortSignal } = {}) {
        if (!this.config) {
            this.config = await this.configProvider;
            this.connectionManager.setDisableConcurrentStreams(this.config.disableConcurrentStreams || false);
            if (this.config.maxConcurrentStreams) {
                this.connectionManager.setMaxConcurrentStreams(this.config.maxConcurrentStreams);
            }
        }
        const { requestTimeout, disableConcurrentStreams } = this.config;
        return new Promise((_resolve, _reject)=>{
            var _a, _b, _c;
            let fulfilled = false;
            let writeRequestBodyPromise = undefined;
            const resolve = async (arg)=>{
                await writeRequestBodyPromise;
                _resolve(arg);
            };
            const reject = async (arg)=>{
                await writeRequestBodyPromise;
                _reject(arg);
            };
            if (abortSignal === null || abortSignal === void 0 ? void 0 : abortSignal.aborted) {
                fulfilled = true;
                const abortError = new Error("Request aborted");
                abortError.name = "AbortError";
                reject(abortError);
                return;
            }
            const { hostname, method, port, protocol, query } = request;
            let auth = "";
            if (request.username != null || request.password != null) {
                const username = (_a = request.username) !== null && _a !== void 0 ? _a : "";
                const password = (_b = request.password) !== null && _b !== void 0 ? _b : "";
                auth = `${username}:${password}@`;
            }
            const authority = `${protocol}//${auth}${hostname}${port ? `:${port}` : ""}`;
            const requestContext = {
                destination: new URL(authority)
            };
            const session = this.connectionManager.lease(requestContext, {
                requestTimeout: (_c = this.config) === null || _c === void 0 ? void 0 : _c.sessionTimeout,
                disableConcurrentStreams: disableConcurrentStreams || false
            });
            const rejectWithDestroy = (err)=>{
                if (disableConcurrentStreams) {
                    this.destroySession(session);
                }
                fulfilled = true;
                reject(err);
            };
            const queryString = (0, querystring_builder_1.buildQueryString)(query || {});
            let path = request.path;
            if (queryString) {
                path += `?${queryString}`;
            }
            if (request.fragment) {
                path += `#${request.fragment}`;
            }
            const req = session.request({
                ...request.headers,
                [http2_1.constants.HTTP2_HEADER_PATH]: path,
                [http2_1.constants.HTTP2_HEADER_METHOD]: method
            });
            session.ref();
            req.on("response", (headers)=>{
                const httpResponse = new protocol_http_1.HttpResponse({
                    statusCode: headers[":status"] || -1,
                    headers: (0, get_transformed_headers_1.getTransformedHeaders)(headers),
                    body: req
                });
                fulfilled = true;
                resolve({
                    response: httpResponse
                });
                if (disableConcurrentStreams) {
                    session.close();
                    this.connectionManager.deleteSession(authority, session);
                }
            });
            if (requestTimeout) {
                req.setTimeout(requestTimeout, ()=>{
                    req.close();
                    const timeoutError = new Error(`Stream timed out because of no activity for ${requestTimeout} ms`);
                    timeoutError.name = "TimeoutError";
                    rejectWithDestroy(timeoutError);
                });
            }
            if (abortSignal) {
                abortSignal.onabort = ()=>{
                    req.close();
                    const abortError = new Error("Request aborted");
                    abortError.name = "AbortError";
                    rejectWithDestroy(abortError);
                };
            }
            req.on("frameError", (type, code, id)=>{
                rejectWithDestroy(new Error(`Frame type id ${type} in stream id ${id} has failed with code ${code}.`));
            });
            req.on("error", rejectWithDestroy);
            req.on("aborted", ()=>{
                rejectWithDestroy(new Error(`HTTP/2 stream is abnormally aborted in mid-communication with result code ${req.rstCode}.`));
            });
            req.on("close", ()=>{
                session.unref();
                if (disableConcurrentStreams) {
                    session.destroy();
                }
                if (!fulfilled) {
                    rejectWithDestroy(new Error("Unexpected error: http2 request did not get a response"));
                }
            });
            writeRequestBodyPromise = (0, write_request_body_1.writeRequestBody)(req, request, requestTimeout);
        });
    }
    destroySession(session) {
        if (!session.destroyed) {
            session.destroy();
        }
    }
}
exports.NodeHttp2Handler = NodeHttp2Handler;


/***/ }),

/***/ 41305:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.setConnectionTimeout = void 0;
const setConnectionTimeout = (request, reject, timeoutInMs = 0)=>{
    if (!timeoutInMs) {
        return;
    }
    const timeoutId = setTimeout(()=>{
        request.destroy();
        reject(Object.assign(new Error(`Socket timed out without establishing a connection within ${timeoutInMs} ms`), {
            name: "TimeoutError"
        }));
    }, timeoutInMs);
    request.on("socket", (socket)=>{
        if (socket.connecting) {
            socket.on("connect", ()=>{
                clearTimeout(timeoutId);
            });
        } else {
            clearTimeout(timeoutId);
        }
    });
};
exports.setConnectionTimeout = setConnectionTimeout;


/***/ }),

/***/ 77915:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.setSocketKeepAlive = void 0;
const setSocketKeepAlive = (request, { keepAlive, keepAliveMsecs })=>{
    if (keepAlive !== true) {
        return;
    }
    request.on("socket", (socket)=>{
        socket.setKeepAlive(keepAlive, keepAliveMsecs || 0);
    });
};
exports.setSocketKeepAlive = setSocketKeepAlive;


/***/ }),

/***/ 44139:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.setSocketTimeout = void 0;
const setSocketTimeout = (request, reject, timeoutInMs = 0)=>{
    request.setTimeout(timeoutInMs, ()=>{
        request.destroy();
        reject(Object.assign(new Error(`Connection timed out after ${timeoutInMs} ms`), {
            name: "TimeoutError"
        }));
    });
};
exports.setSocketTimeout = setSocketTimeout;


/***/ }),

/***/ 8592:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Collector = void 0;
const stream_1 = __webpack_require__(12781);
class Collector extends stream_1.Writable {
    constructor(){
        super(...arguments);
        this.bufferedBytes = [];
    }
    _write(chunk, encoding, callback) {
        this.bufferedBytes.push(chunk);
        callback();
    }
}
exports.Collector = Collector;


/***/ }),

/***/ 19499:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.streamCollector = void 0;
const collector_1 = __webpack_require__(8592);
const streamCollector = (stream)=>new Promise((resolve, reject)=>{
        const collector = new collector_1.Collector();
        stream.pipe(collector);
        stream.on("error", (err)=>{
            collector.end();
            reject(err);
        });
        collector.on("error", reject);
        collector.on("finish", function() {
            const bytes = new Uint8Array(Buffer.concat(this.bufferedBytes));
            resolve(bytes);
        });
    });
exports.streamCollector = streamCollector;


/***/ }),

/***/ 37945:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.writeRequestBody = void 0;
const stream_1 = __webpack_require__(12781);
const MIN_WAIT_TIME = 1000;
async function writeRequestBody(httpRequest, request, maxContinueTimeoutMs = MIN_WAIT_TIME) {
    var _a;
    const headers = (_a = request.headers) !== null && _a !== void 0 ? _a : {};
    const expect = headers["Expect"] || headers["expect"];
    let timeoutId = -1;
    let hasError = false;
    if (expect === "100-continue") {
        await Promise.race([
            new Promise((resolve)=>{
                timeoutId = Number(setTimeout(resolve, Math.max(MIN_WAIT_TIME, maxContinueTimeoutMs)));
            }),
            new Promise((resolve)=>{
                httpRequest.on("continue", ()=>{
                    clearTimeout(timeoutId);
                    resolve();
                });
                httpRequest.on("error", ()=>{
                    hasError = true;
                    clearTimeout(timeoutId);
                    resolve();
                });
            })
        ]);
    }
    if (!hasError) {
        writeBody(httpRequest, request.body);
    }
}
exports.writeRequestBody = writeRequestBody;
function writeBody(httpRequest, body) {
    if (body instanceof stream_1.Readable) {
        body.pipe(httpRequest);
    } else if (body) {
        httpRequest.end(Buffer.from(body));
    } else {
        httpRequest.end();
    }
}


/***/ }),

/***/ 99477:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.CredentialsProviderError = void 0;
const ProviderError_1 = __webpack_require__(15860);
class CredentialsProviderError extends ProviderError_1.ProviderError {
    constructor(message, tryNextLink = true){
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "CredentialsProviderError";
        Object.setPrototypeOf(this, CredentialsProviderError.prototype);
    }
}
exports.CredentialsProviderError = CredentialsProviderError;


/***/ }),

/***/ 15860:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ProviderError = void 0;
class ProviderError extends Error {
    constructor(message, tryNextLink = true){
        super(message);
        this.tryNextLink = tryNextLink;
        this.name = "ProviderError";
        Object.setPrototypeOf(this, ProviderError.prototype);
    }
    static from(error, tryNextLink = true) {
        return Object.assign(new this(error.message, tryNextLink), error);
    }
}
exports.ProviderError = ProviderError;


/***/ }),

/***/ 81363:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.TokenProviderError = void 0;
const ProviderError_1 = __webpack_require__(15860);
class TokenProviderError extends ProviderError_1.ProviderError {
    constructor(message, tryNextLink = true){
        super(message, tryNextLink);
        this.tryNextLink = tryNextLink;
        this.name = "TokenProviderError";
        Object.setPrototypeOf(this, TokenProviderError.prototype);
    }
}
exports.TokenProviderError = TokenProviderError;


/***/ }),

/***/ 97467:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.chain = void 0;
const ProviderError_1 = __webpack_require__(15860);
const chain = (...providers)=>async ()=>{
        if (providers.length === 0) {
            throw new ProviderError_1.ProviderError("No providers in chain");
        }
        let lastProviderError;
        for (const provider of providers){
            try {
                const credentials = await provider();
                return credentials;
            } catch (err) {
                lastProviderError = err;
                if (err === null || err === void 0 ? void 0 : err.tryNextLink) {
                    continue;
                }
                throw err;
            }
        }
        throw lastProviderError;
    };
exports.chain = chain;


/***/ }),

/***/ 62148:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromStatic = void 0;
const fromStatic = (staticValue)=>()=>Promise.resolve(staticValue);
exports.fromStatic = fromStatic;


/***/ }),

/***/ 29852:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(99477), exports);
tslib_1.__exportStar(__webpack_require__(15860), exports);
tslib_1.__exportStar(__webpack_require__(81363), exports);
tslib_1.__exportStar(__webpack_require__(97467), exports);
tslib_1.__exportStar(__webpack_require__(62148), exports);
tslib_1.__exportStar(__webpack_require__(39839), exports);


/***/ }),

/***/ 39839:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.memoize = void 0;
const memoize = (provider, isExpired, requiresRefresh)=>{
    let resolved;
    let pending;
    let hasResult;
    let isConstant = false;
    const coalesceProvider = async ()=>{
        if (!pending) {
            pending = provider();
        }
        try {
            resolved = await pending;
            hasResult = true;
            isConstant = false;
        } finally{
            pending = undefined;
        }
        return resolved;
    };
    if (isExpired === undefined) {
        return async (options)=>{
            if (!hasResult || (options === null || options === void 0 ? void 0 : options.forceRefresh)) {
                resolved = await coalesceProvider();
            }
            return resolved;
        };
    }
    return async (options)=>{
        if (!hasResult || (options === null || options === void 0 ? void 0 : options.forceRefresh)) {
            resolved = await coalesceProvider();
        }
        if (isConstant) {
            return resolved;
        }
        if (requiresRefresh && !requiresRefresh(resolved)) {
            isConstant = true;
            return resolved;
        }
        if (isExpired(resolved)) {
            await coalesceProvider();
            return resolved;
        }
        return resolved;
    };
};
exports.memoize = memoize;


/***/ }),

/***/ 37893:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Field = void 0;
const types_1 = __webpack_require__(46754);
class Field {
    constructor({ name, kind = types_1.FieldPosition.HEADER, values = [] }){
        this.name = name;
        this.kind = kind;
        this.values = values;
    }
    add(value) {
        this.values.push(value);
    }
    set(values) {
        this.values = values;
    }
    remove(value) {
        this.values = this.values.filter((v)=>v !== value);
    }
    toString() {
        return this.values.map((v)=>v.includes(",") || v.includes(" ") ? `"${v}"` : v).join(", ");
    }
    get() {
        return this.values;
    }
}
exports.Field = Field;


/***/ }),

/***/ 9359:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Fields = void 0;
class Fields {
    constructor({ fields = [], encoding = "utf-8" }){
        this.entries = {};
        fields.forEach(this.setField.bind(this));
        this.encoding = encoding;
    }
    setField(field) {
        this.entries[field.name.toLowerCase()] = field;
    }
    getField(name) {
        return this.entries[name.toLowerCase()];
    }
    removeField(name) {
        delete this.entries[name.toLowerCase()];
    }
    getByType(kind) {
        return Object.values(this.entries).filter((field)=>field.kind === kind);
    }
}
exports.Fields = Fields;


/***/ }),

/***/ 17997:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 98681:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.HttpRequest = void 0;
class HttpRequest {
    constructor(options){
        this.method = options.method || "GET";
        this.hostname = options.hostname || "localhost";
        this.port = options.port;
        this.query = options.query || {};
        this.headers = options.headers || {};
        this.body = options.body;
        this.protocol = options.protocol ? options.protocol.slice(-1) !== ":" ? `${options.protocol}:` : options.protocol : "https:";
        this.path = options.path ? options.path.charAt(0) !== "/" ? `/${options.path}` : options.path : "/";
        this.username = options.username;
        this.password = options.password;
        this.fragment = options.fragment;
    }
    static isInstance(request) {
        if (!request) return false;
        const req = request;
        return "method" in req && "protocol" in req && "hostname" in req && "path" in req && typeof req["query"] === "object" && typeof req["headers"] === "object";
    }
    clone() {
        const cloned = new HttpRequest({
            ...this,
            headers: {
                ...this.headers
            }
        });
        if (cloned.query) cloned.query = cloneQuery(cloned.query);
        return cloned;
    }
}
exports.HttpRequest = HttpRequest;
function cloneQuery(query) {
    return Object.keys(query).reduce((carry, paramName)=>{
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [
                ...param
            ] : param
        };
    }, {});
}


/***/ }),

/***/ 77388:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.HttpResponse = void 0;
class HttpResponse {
    constructor(options){
        this.statusCode = options.statusCode;
        this.reason = options.reason;
        this.headers = options.headers || {};
        this.body = options.body;
    }
    static isInstance(response) {
        if (!response) return false;
        const resp = response;
        return typeof resp.statusCode === "number" && typeof resp.headers === "object";
    }
}
exports.HttpResponse = HttpResponse;


/***/ }),

/***/ 64082:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(37893), exports);
tslib_1.__exportStar(__webpack_require__(9359), exports);
tslib_1.__exportStar(__webpack_require__(17997), exports);
tslib_1.__exportStar(__webpack_require__(98681), exports);
tslib_1.__exportStar(__webpack_require__(77388), exports);
tslib_1.__exportStar(__webpack_require__(32831), exports);
tslib_1.__exportStar(__webpack_require__(78821), exports);


/***/ }),

/***/ 32831:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isValidHostname = void 0;
function isValidHostname(hostname) {
    const hostPattern = /^[a-z0-9][a-z0-9\.\-]*[a-z0-9]$/;
    return hostPattern.test(hostname);
}
exports.isValidHostname = isValidHostname;


/***/ }),

/***/ 78821:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 83140:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.buildQueryString = void 0;
const util_uri_escape_1 = __webpack_require__(49731);
function buildQueryString(query) {
    const parts = [];
    for (let key of Object.keys(query).sort()){
        const value = query[key];
        key = (0, util_uri_escape_1.escapeUri)(key);
        if (Array.isArray(value)) {
            for(let i = 0, iLen = value.length; i < iLen; i++){
                parts.push(`${key}=${(0, util_uri_escape_1.escapeUri)(value[i])}`);
            }
        } else {
            let qsEntry = key;
            if (value || typeof value === "string") {
                qsEntry += `=${(0, util_uri_escape_1.escapeUri)(value)}`;
            }
            parts.push(qsEntry);
        }
    }
    return parts.join("&");
}
exports.buildQueryString = buildQueryString;


/***/ }),

/***/ 66639:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parseQueryString = void 0;
function parseQueryString(querystring) {
    const query = {};
    querystring = querystring.replace(/^\?/, "");
    if (querystring) {
        for (const pair of querystring.split("&")){
            let [key, value = null] = pair.split("=");
            key = decodeURIComponent(key);
            if (value) {
                value = decodeURIComponent(value);
            }
            if (!(key in query)) {
                query[key] = value;
            } else if (Array.isArray(query[key])) {
                query[key].push(value);
            } else {
                query[key] = [
                    query[key],
                    value
                ];
            }
        }
    }
    return query;
}
exports.parseQueryString = parseQueryString;


/***/ }),

/***/ 99788:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NODEJS_TIMEOUT_ERROR_CODES = exports.TRANSIENT_ERROR_STATUS_CODES = exports.TRANSIENT_ERROR_CODES = exports.THROTTLING_ERROR_CODES = exports.CLOCK_SKEW_ERROR_CODES = void 0;
exports.CLOCK_SKEW_ERROR_CODES = [
    "AuthFailure",
    "InvalidSignatureException",
    "RequestExpired",
    "RequestInTheFuture",
    "RequestTimeTooSkewed",
    "SignatureDoesNotMatch"
];
exports.THROTTLING_ERROR_CODES = [
    "BandwidthLimitExceeded",
    "EC2ThrottledException",
    "LimitExceededException",
    "PriorRequestNotComplete",
    "ProvisionedThroughputExceededException",
    "RequestLimitExceeded",
    "RequestThrottled",
    "RequestThrottledException",
    "SlowDown",
    "ThrottledException",
    "Throttling",
    "ThrottlingException",
    "TooManyRequestsException",
    "TransactionInProgressException"
];
exports.TRANSIENT_ERROR_CODES = [
    "TimeoutError",
    "RequestTimeout",
    "RequestTimeoutException"
];
exports.TRANSIENT_ERROR_STATUS_CODES = [
    500,
    502,
    503,
    504
];
exports.NODEJS_TIMEOUT_ERROR_CODES = [
    "ECONNRESET",
    "ECONNREFUSED",
    "EPIPE",
    "ETIMEDOUT"
];


/***/ }),

/***/ 69121:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.isServerError = exports.isTransientError = exports.isThrottlingError = exports.isClockSkewError = exports.isRetryableByTrait = void 0;
const constants_1 = __webpack_require__(99788);
const isRetryableByTrait = (error)=>error.$retryable !== undefined;
exports.isRetryableByTrait = isRetryableByTrait;
const isClockSkewError = (error)=>constants_1.CLOCK_SKEW_ERROR_CODES.includes(error.name);
exports.isClockSkewError = isClockSkewError;
const isThrottlingError = (error)=>{
    var _a, _b;
    return ((_a = error.$metadata) === null || _a === void 0 ? void 0 : _a.httpStatusCode) === 429 || constants_1.THROTTLING_ERROR_CODES.includes(error.name) || ((_b = error.$retryable) === null || _b === void 0 ? void 0 : _b.throttling) == true;
};
exports.isThrottlingError = isThrottlingError;
const isTransientError = (error)=>{
    var _a;
    return constants_1.TRANSIENT_ERROR_CODES.includes(error.name) || constants_1.NODEJS_TIMEOUT_ERROR_CODES.includes((error === null || error === void 0 ? void 0 : error.code) || "") || constants_1.TRANSIENT_ERROR_STATUS_CODES.includes(((_a = error.$metadata) === null || _a === void 0 ? void 0 : _a.httpStatusCode) || 0);
};
exports.isTransientError = isTransientError;
const isServerError = (error)=>{
    var _a;
    if (((_a = error.$metadata) === null || _a === void 0 ? void 0 : _a.httpStatusCode) !== undefined) {
        const statusCode = error.$metadata.httpStatusCode;
        if (500 <= statusCode && statusCode <= 599 && !(0, exports.isTransientError)(error)) {
            return true;
        }
        return false;
    }
    return false;
};
exports.isServerError = isServerError;


/***/ }),

/***/ 6692:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getConfigFilepath = exports.ENV_CONFIG_PATH = void 0;
const path_1 = __webpack_require__(71017);
const getHomeDir_1 = __webpack_require__(69451);
exports.ENV_CONFIG_PATH = "AWS_CONFIG_FILE";
const getConfigFilepath = ()=>process.env[exports.ENV_CONFIG_PATH] || (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "config");
exports.getConfigFilepath = getConfigFilepath;


/***/ }),

/***/ 83488:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getCredentialsFilepath = exports.ENV_CREDENTIALS_PATH = void 0;
const path_1 = __webpack_require__(71017);
const getHomeDir_1 = __webpack_require__(69451);
exports.ENV_CREDENTIALS_PATH = "AWS_SHARED_CREDENTIALS_FILE";
const getCredentialsFilepath = ()=>process.env[exports.ENV_CREDENTIALS_PATH] || (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "credentials");
exports.getCredentialsFilepath = getCredentialsFilepath;


/***/ }),

/***/ 69451:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getHomeDir = void 0;
const os_1 = __webpack_require__(22037);
const path_1 = __webpack_require__(71017);
const process_1 = __webpack_require__(77282);
const homeDirCache = {};
const getHomeDirCacheKey = ()=>{
    if (process_1.geteuid) {
        return `${(0, process_1.geteuid)()}`;
    }
    return "DEFAULT";
};
const getHomeDir = ()=>{
    const { HOME, USERPROFILE, HOMEPATH, HOMEDRIVE = `C:${path_1.sep}` } = process.env;
    if (HOME) return HOME;
    if (USERPROFILE) return USERPROFILE;
    if (HOMEPATH) return `${HOMEDRIVE}${HOMEPATH}`;
    const homeDirCacheKey = getHomeDirCacheKey();
    if (!homeDirCache[homeDirCacheKey]) homeDirCache[homeDirCacheKey] = (0, os_1.homedir)();
    return homeDirCache[homeDirCacheKey];
};
exports.getHomeDir = getHomeDir;


/***/ }),

/***/ 34271:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getProfileData = void 0;
const profileKeyRegex = /^profile\s(["'])?([^\1]+)\1$/;
const getProfileData = (data)=>Object.entries(data).filter(([key])=>profileKeyRegex.test(key)).reduce((acc, [key, value])=>({
            ...acc,
            [profileKeyRegex.exec(key)[2]]: value
        }), {
        ...data.default && {
            default: data.default
        }
    });
exports.getProfileData = getProfileData;


/***/ }),

/***/ 87779:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getProfileName = exports.DEFAULT_PROFILE = exports.ENV_PROFILE = void 0;
exports.ENV_PROFILE = "AWS_PROFILE";
exports.DEFAULT_PROFILE = "default";
const getProfileName = (init)=>init.profile || process.env[exports.ENV_PROFILE] || exports.DEFAULT_PROFILE;
exports.getProfileName = getProfileName;


/***/ }),

/***/ 4890:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getSSOTokenFilepath = void 0;
const crypto_1 = __webpack_require__(6113);
const path_1 = __webpack_require__(71017);
const getHomeDir_1 = __webpack_require__(69451);
const getSSOTokenFilepath = (id)=>{
    const hasher = (0, crypto_1.createHash)("sha1");
    const cacheName = hasher.update(id).digest("hex");
    return (0, path_1.join)((0, getHomeDir_1.getHomeDir)(), ".aws", "sso", "cache", `${cacheName}.json`);
};
exports.getSSOTokenFilepath = getSSOTokenFilepath;


/***/ }),

/***/ 89820:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getSSOTokenFromFile = void 0;
const fs_1 = __webpack_require__(57147);
const getSSOTokenFilepath_1 = __webpack_require__(4890);
const { readFile } = fs_1.promises;
const getSSOTokenFromFile = async (id)=>{
    const ssoTokenFilepath = (0, getSSOTokenFilepath_1.getSSOTokenFilepath)(id);
    const ssoTokenText = await readFile(ssoTokenFilepath, "utf8");
    return JSON.parse(ssoTokenText);
};
exports.getSSOTokenFromFile = getSSOTokenFromFile;


/***/ }),

/***/ 20192:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getSsoSessionData = void 0;
const ssoSessionKeyRegex = /^sso-session\s(["'])?([^\1]+)\1$/;
const getSsoSessionData = (data)=>Object.entries(data).filter(([key])=>ssoSessionKeyRegex.test(key)).reduce((acc, [key, value])=>({
            ...acc,
            [ssoSessionKeyRegex.exec(key)[2]]: value
        }), {});
exports.getSsoSessionData = getSsoSessionData;


/***/ }),

/***/ 3666:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(69451), exports);
tslib_1.__exportStar(__webpack_require__(87779), exports);
tslib_1.__exportStar(__webpack_require__(4890), exports);
tslib_1.__exportStar(__webpack_require__(89820), exports);
tslib_1.__exportStar(__webpack_require__(34420), exports);
tslib_1.__exportStar(__webpack_require__(29699), exports);
tslib_1.__exportStar(__webpack_require__(1397), exports);
tslib_1.__exportStar(__webpack_require__(63515), exports);


/***/ }),

/***/ 34420:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.loadSharedConfigFiles = void 0;
const getConfigFilepath_1 = __webpack_require__(6692);
const getCredentialsFilepath_1 = __webpack_require__(83488);
const getProfileData_1 = __webpack_require__(34271);
const parseIni_1 = __webpack_require__(47276);
const slurpFile_1 = __webpack_require__(14187);
const swallowError = ()=>({});
const loadSharedConfigFiles = async (init = {})=>{
    const { filepath = (0, getCredentialsFilepath_1.getCredentialsFilepath)(), configFilepath = (0, getConfigFilepath_1.getConfigFilepath)() } = init;
    const parsedFiles = await Promise.all([
        (0, slurpFile_1.slurpFile)(configFilepath, {
            ignoreCache: init.ignoreCache
        }).then(parseIni_1.parseIni).then(getProfileData_1.getProfileData).catch(swallowError),
        (0, slurpFile_1.slurpFile)(filepath, {
            ignoreCache: init.ignoreCache
        }).then(parseIni_1.parseIni).catch(swallowError)
    ]);
    return {
        configFile: parsedFiles[0],
        credentialsFile: parsedFiles[1]
    };
};
exports.loadSharedConfigFiles = loadSharedConfigFiles;


/***/ }),

/***/ 29699:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.loadSsoSessionData = void 0;
const getConfigFilepath_1 = __webpack_require__(6692);
const getSsoSessionData_1 = __webpack_require__(20192);
const parseIni_1 = __webpack_require__(47276);
const slurpFile_1 = __webpack_require__(14187);
const swallowError = ()=>({});
const loadSsoSessionData = async (init = {})=>{
    var _a;
    return (0, slurpFile_1.slurpFile)((_a = init.configFilepath) !== null && _a !== void 0 ? _a : (0, getConfigFilepath_1.getConfigFilepath)()).then(parseIni_1.parseIni).then(getSsoSessionData_1.getSsoSessionData).catch(swallowError);
};
exports.loadSsoSessionData = loadSsoSessionData;


/***/ }),

/***/ 64161:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.mergeConfigFiles = void 0;
const mergeConfigFiles = (...files)=>{
    const merged = {};
    for (const file of files){
        for (const [key, values] of Object.entries(file)){
            if (merged[key] !== undefined) {
                Object.assign(merged[key], values);
            } else {
                merged[key] = values;
            }
        }
    }
    return merged;
};
exports.mergeConfigFiles = mergeConfigFiles;


/***/ }),

/***/ 47276:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parseIni = void 0;
const profileNameBlockList = [
    "__proto__",
    "profile __proto__"
];
const parseIni = (iniData)=>{
    const map = {};
    let currentSection;
    for (let line of iniData.split(/\r?\n/)){
        line = line.split(/(^|\s)[;#]/)[0].trim();
        const isSection = line[0] === "[" && line[line.length - 1] === "]";
        if (isSection) {
            currentSection = line.substring(1, line.length - 1);
            if (profileNameBlockList.includes(currentSection)) {
                throw new Error(`Found invalid profile name "${currentSection}"`);
            }
        } else if (currentSection) {
            const indexOfEqualsSign = line.indexOf("=");
            const start = 0;
            const end = line.length - 1;
            const isAssignment = indexOfEqualsSign !== -1 && indexOfEqualsSign !== start && indexOfEqualsSign !== end;
            if (isAssignment) {
                const [name, value] = [
                    line.substring(0, indexOfEqualsSign).trim(),
                    line.substring(indexOfEqualsSign + 1).trim()
                ];
                map[currentSection] = map[currentSection] || {};
                map[currentSection][name] = value;
            }
        }
    }
    return map;
};
exports.parseIni = parseIni;


/***/ }),

/***/ 1397:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parseKnownFiles = void 0;
const loadSharedConfigFiles_1 = __webpack_require__(34420);
const mergeConfigFiles_1 = __webpack_require__(64161);
const parseKnownFiles = async (init)=>{
    const parsedFiles = await (0, loadSharedConfigFiles_1.loadSharedConfigFiles)(init);
    return (0, mergeConfigFiles_1.mergeConfigFiles)(parsedFiles.configFile, parsedFiles.credentialsFile);
};
exports.parseKnownFiles = parseKnownFiles;


/***/ }),

/***/ 14187:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.slurpFile = void 0;
const fs_1 = __webpack_require__(57147);
const { readFile } = fs_1.promises;
const filePromisesHash = {};
const slurpFile = (path, options)=>{
    if (!filePromisesHash[path] || (options === null || options === void 0 ? void 0 : options.ignoreCache)) {
        filePromisesHash[path] = readFile(path, "utf8");
    }
    return filePromisesHash[path];
};
exports.slurpFile = slurpFile;


/***/ }),

/***/ 63515:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 98305:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SignatureV4 = void 0;
const eventstream_codec_1 = __webpack_require__(41992);
const util_hex_encoding_1 = __webpack_require__(7214);
const util_middleware_1 = __webpack_require__(5837);
const util_utf8_1 = __webpack_require__(66120);
const constants_1 = __webpack_require__(43016);
const credentialDerivation_1 = __webpack_require__(31188);
const getCanonicalHeaders_1 = __webpack_require__(24043);
const getCanonicalQuery_1 = __webpack_require__(47694);
const getPayloadHash_1 = __webpack_require__(62136);
const headerUtil_1 = __webpack_require__(62781);
const moveHeadersToQuery_1 = __webpack_require__(55166);
const prepareRequest_1 = __webpack_require__(64638);
const utilDate_1 = __webpack_require__(53516);
class SignatureV4 {
    constructor({ applyChecksum, credentials, region, service, sha256, uriEscapePath = true }){
        this.headerMarshaller = new eventstream_codec_1.HeaderMarshaller(util_utf8_1.toUtf8, util_utf8_1.fromUtf8);
        this.service = service;
        this.sha256 = sha256;
        this.uriEscapePath = uriEscapePath;
        this.applyChecksum = typeof applyChecksum === "boolean" ? applyChecksum : true;
        this.regionProvider = (0, util_middleware_1.normalizeProvider)(region);
        this.credentialProvider = (0, util_middleware_1.normalizeProvider)(credentials);
    }
    async presign(originalRequest, options = {}) {
        const { signingDate = new Date(), expiresIn = 3600, unsignableHeaders, unhoistableHeaders, signableHeaders, signingRegion, signingService } = options;
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : await this.regionProvider();
        const { longDate, shortDate } = formatDate(signingDate);
        if (expiresIn > constants_1.MAX_PRESIGNED_TTL) {
            return Promise.reject("Signature version 4 presigned URLs" + " must have an expiration date less than one week in" + " the future");
        }
        const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
        const request = (0, moveHeadersToQuery_1.moveHeadersToQuery)((0, prepareRequest_1.prepareRequest)(originalRequest), {
            unhoistableHeaders
        });
        if (credentials.sessionToken) {
            request.query[constants_1.TOKEN_QUERY_PARAM] = credentials.sessionToken;
        }
        request.query[constants_1.ALGORITHM_QUERY_PARAM] = constants_1.ALGORITHM_IDENTIFIER;
        request.query[constants_1.CREDENTIAL_QUERY_PARAM] = `${credentials.accessKeyId}/${scope}`;
        request.query[constants_1.AMZ_DATE_QUERY_PARAM] = longDate;
        request.query[constants_1.EXPIRES_QUERY_PARAM] = expiresIn.toString(10);
        const canonicalHeaders = (0, getCanonicalHeaders_1.getCanonicalHeaders)(request, unsignableHeaders, signableHeaders);
        request.query[constants_1.SIGNED_HEADERS_QUERY_PARAM] = getCanonicalHeaderList(canonicalHeaders);
        request.query[constants_1.SIGNATURE_QUERY_PARAM] = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, await (0, getPayloadHash_1.getPayloadHash)(originalRequest, this.sha256)));
        return request;
    }
    async sign(toSign, options) {
        if (typeof toSign === "string") {
            return this.signString(toSign, options);
        } else if (toSign.headers && toSign.payload) {
            return this.signEvent(toSign, options);
        } else if (toSign.message) {
            return this.signMessage(toSign, options);
        } else {
            return this.signRequest(toSign, options);
        }
    }
    async signEvent({ headers, payload }, { signingDate = new Date(), priorSignature, signingRegion, signingService }) {
        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : await this.regionProvider();
        const { shortDate, longDate } = formatDate(signingDate);
        const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
        const hashedPayload = await (0, getPayloadHash_1.getPayloadHash)({
            headers: {},
            body: payload
        }, this.sha256);
        const hash = new this.sha256();
        hash.update(headers);
        const hashedHeaders = (0, util_hex_encoding_1.toHex)(await hash.digest());
        const stringToSign = [
            constants_1.EVENT_ALGORITHM_IDENTIFIER,
            longDate,
            scope,
            priorSignature,
            hashedHeaders,
            hashedPayload
        ].join("\n");
        return this.signString(stringToSign, {
            signingDate,
            signingRegion: region,
            signingService
        });
    }
    async signMessage(signableMessage, { signingDate = new Date(), signingRegion, signingService }) {
        const promise = this.signEvent({
            headers: this.headerMarshaller.format(signableMessage.message.headers),
            payload: signableMessage.message.body
        }, {
            signingDate,
            signingRegion,
            signingService,
            priorSignature: signableMessage.priorSignature
        });
        return promise.then((signature)=>{
            return {
                message: signableMessage.message,
                signature
            };
        });
    }
    async signString(stringToSign, { signingDate = new Date(), signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : await this.regionProvider();
        const { shortDate } = formatDate(signingDate);
        const hash = new this.sha256(await this.getSigningKey(credentials, region, shortDate, signingService));
        hash.update((0, util_utf8_1.toUint8Array)(stringToSign));
        return (0, util_hex_encoding_1.toHex)(await hash.digest());
    }
    async signRequest(requestToSign, { signingDate = new Date(), signableHeaders, unsignableHeaders, signingRegion, signingService } = {}) {
        const credentials = await this.credentialProvider();
        this.validateResolvedCredentials(credentials);
        const region = signingRegion !== null && signingRegion !== void 0 ? signingRegion : await this.regionProvider();
        const request = (0, prepareRequest_1.prepareRequest)(requestToSign);
        const { longDate, shortDate } = formatDate(signingDate);
        const scope = (0, credentialDerivation_1.createScope)(shortDate, region, signingService !== null && signingService !== void 0 ? signingService : this.service);
        request.headers[constants_1.AMZ_DATE_HEADER] = longDate;
        if (credentials.sessionToken) {
            request.headers[constants_1.TOKEN_HEADER] = credentials.sessionToken;
        }
        const payloadHash = await (0, getPayloadHash_1.getPayloadHash)(request, this.sha256);
        if (!(0, headerUtil_1.hasHeader)(constants_1.SHA256_HEADER, request.headers) && this.applyChecksum) {
            request.headers[constants_1.SHA256_HEADER] = payloadHash;
        }
        const canonicalHeaders = (0, getCanonicalHeaders_1.getCanonicalHeaders)(request, unsignableHeaders, signableHeaders);
        const signature = await this.getSignature(longDate, scope, this.getSigningKey(credentials, region, shortDate, signingService), this.createCanonicalRequest(request, canonicalHeaders, payloadHash));
        request.headers[constants_1.AUTH_HEADER] = `${constants_1.ALGORITHM_IDENTIFIER} ` + `Credential=${credentials.accessKeyId}/${scope}, ` + `SignedHeaders=${getCanonicalHeaderList(canonicalHeaders)}, ` + `Signature=${signature}`;
        return request;
    }
    createCanonicalRequest(request, canonicalHeaders, payloadHash) {
        const sortedHeaders = Object.keys(canonicalHeaders).sort();
        return `${request.method}
${this.getCanonicalPath(request)}
${(0, getCanonicalQuery_1.getCanonicalQuery)(request)}
${sortedHeaders.map((name)=>`${name}:${canonicalHeaders[name]}`).join("\n")}

${sortedHeaders.join(";")}
${payloadHash}`;
    }
    async createStringToSign(longDate, credentialScope, canonicalRequest) {
        const hash = new this.sha256();
        hash.update((0, util_utf8_1.toUint8Array)(canonicalRequest));
        const hashedRequest = await hash.digest();
        return `${constants_1.ALGORITHM_IDENTIFIER}
${longDate}
${credentialScope}
${(0, util_hex_encoding_1.toHex)(hashedRequest)}`;
    }
    getCanonicalPath({ path }) {
        if (this.uriEscapePath) {
            const normalizedPathSegments = [];
            for (const pathSegment of path.split("/")){
                if ((pathSegment === null || pathSegment === void 0 ? void 0 : pathSegment.length) === 0) continue;
                if (pathSegment === ".") continue;
                if (pathSegment === "..") {
                    normalizedPathSegments.pop();
                } else {
                    normalizedPathSegments.push(pathSegment);
                }
            }
            const normalizedPath = `${(path === null || path === void 0 ? void 0 : path.startsWith("/")) ? "/" : ""}${normalizedPathSegments.join("/")}${normalizedPathSegments.length > 0 && (path === null || path === void 0 ? void 0 : path.endsWith("/")) ? "/" : ""}`;
            const doubleEncoded = encodeURIComponent(normalizedPath);
            return doubleEncoded.replace(/%2F/g, "/");
        }
        return path;
    }
    async getSignature(longDate, credentialScope, keyPromise, canonicalRequest) {
        const stringToSign = await this.createStringToSign(longDate, credentialScope, canonicalRequest);
        const hash = new this.sha256(await keyPromise);
        hash.update((0, util_utf8_1.toUint8Array)(stringToSign));
        return (0, util_hex_encoding_1.toHex)(await hash.digest());
    }
    getSigningKey(credentials, region, shortDate, service) {
        return (0, credentialDerivation_1.getSigningKey)(this.sha256, credentials, shortDate, region, service || this.service);
    }
    validateResolvedCredentials(credentials) {
        if (typeof credentials !== "object" || typeof credentials.accessKeyId !== "string" || typeof credentials.secretAccessKey !== "string") {
            throw new Error("Resolved credential object is not valid");
        }
    }
}
exports.SignatureV4 = SignatureV4;
const formatDate = (now)=>{
    const longDate = (0, utilDate_1.iso8601)(now).replace(/[\-:]/g, "");
    return {
        longDate,
        shortDate: longDate.slice(0, 8)
    };
};
const getCanonicalHeaderList = (headers)=>Object.keys(headers).sort().join(";");


/***/ }),

/***/ 52202:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.cloneQuery = exports.cloneRequest = void 0;
const cloneRequest = ({ headers, query, ...rest })=>({
        ...rest,
        headers: {
            ...headers
        },
        query: query ? (0, exports.cloneQuery)(query) : undefined
    });
exports.cloneRequest = cloneRequest;
const cloneQuery = (query)=>Object.keys(query).reduce((carry, paramName)=>{
        const param = query[paramName];
        return {
            ...carry,
            [paramName]: Array.isArray(param) ? [
                ...param
            ] : param
        };
    }, {});
exports.cloneQuery = cloneQuery;


/***/ }),

/***/ 43016:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.MAX_PRESIGNED_TTL = exports.KEY_TYPE_IDENTIFIER = exports.MAX_CACHE_SIZE = exports.UNSIGNED_PAYLOAD = exports.EVENT_ALGORITHM_IDENTIFIER = exports.ALGORITHM_IDENTIFIER_V4A = exports.ALGORITHM_IDENTIFIER = exports.UNSIGNABLE_PATTERNS = exports.SEC_HEADER_PATTERN = exports.PROXY_HEADER_PATTERN = exports.ALWAYS_UNSIGNABLE_HEADERS = exports.HOST_HEADER = exports.TOKEN_HEADER = exports.SHA256_HEADER = exports.SIGNATURE_HEADER = exports.GENERATED_HEADERS = exports.DATE_HEADER = exports.AMZ_DATE_HEADER = exports.AUTH_HEADER = exports.REGION_SET_PARAM = exports.TOKEN_QUERY_PARAM = exports.SIGNATURE_QUERY_PARAM = exports.EXPIRES_QUERY_PARAM = exports.SIGNED_HEADERS_QUERY_PARAM = exports.AMZ_DATE_QUERY_PARAM = exports.CREDENTIAL_QUERY_PARAM = exports.ALGORITHM_QUERY_PARAM = void 0;
exports.ALGORITHM_QUERY_PARAM = "X-Amz-Algorithm";
exports.CREDENTIAL_QUERY_PARAM = "X-Amz-Credential";
exports.AMZ_DATE_QUERY_PARAM = "X-Amz-Date";
exports.SIGNED_HEADERS_QUERY_PARAM = "X-Amz-SignedHeaders";
exports.EXPIRES_QUERY_PARAM = "X-Amz-Expires";
exports.SIGNATURE_QUERY_PARAM = "X-Amz-Signature";
exports.TOKEN_QUERY_PARAM = "X-Amz-Security-Token";
exports.REGION_SET_PARAM = "X-Amz-Region-Set";
exports.AUTH_HEADER = "authorization";
exports.AMZ_DATE_HEADER = exports.AMZ_DATE_QUERY_PARAM.toLowerCase();
exports.DATE_HEADER = "date";
exports.GENERATED_HEADERS = [
    exports.AUTH_HEADER,
    exports.AMZ_DATE_HEADER,
    exports.DATE_HEADER
];
exports.SIGNATURE_HEADER = exports.SIGNATURE_QUERY_PARAM.toLowerCase();
exports.SHA256_HEADER = "x-amz-content-sha256";
exports.TOKEN_HEADER = exports.TOKEN_QUERY_PARAM.toLowerCase();
exports.HOST_HEADER = "host";
exports.ALWAYS_UNSIGNABLE_HEADERS = {
    authorization: true,
    "cache-control": true,
    connection: true,
    expect: true,
    from: true,
    "keep-alive": true,
    "max-forwards": true,
    pragma: true,
    referer: true,
    te: true,
    trailer: true,
    "transfer-encoding": true,
    upgrade: true,
    "user-agent": true,
    "x-amzn-trace-id": true
};
exports.PROXY_HEADER_PATTERN = /^proxy-/;
exports.SEC_HEADER_PATTERN = /^sec-/;
exports.UNSIGNABLE_PATTERNS = [
    /^proxy-/i,
    /^sec-/i
];
exports.ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256";
exports.ALGORITHM_IDENTIFIER_V4A = "AWS4-ECDSA-P256-SHA256";
exports.EVENT_ALGORITHM_IDENTIFIER = "AWS4-HMAC-SHA256-PAYLOAD";
exports.UNSIGNED_PAYLOAD = "UNSIGNED-PAYLOAD";
exports.MAX_CACHE_SIZE = 50;
exports.KEY_TYPE_IDENTIFIER = "aws4_request";
exports.MAX_PRESIGNED_TTL = 60 * 60 * 24 * 7;


/***/ }),

/***/ 31188:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.clearCredentialCache = exports.getSigningKey = exports.createScope = void 0;
const util_hex_encoding_1 = __webpack_require__(7214);
const util_utf8_1 = __webpack_require__(66120);
const constants_1 = __webpack_require__(43016);
const signingKeyCache = {};
const cacheQueue = [];
const createScope = (shortDate, region, service)=>`${shortDate}/${region}/${service}/${constants_1.KEY_TYPE_IDENTIFIER}`;
exports.createScope = createScope;
const getSigningKey = async (sha256Constructor, credentials, shortDate, region, service)=>{
    const credsHash = await hmac(sha256Constructor, credentials.secretAccessKey, credentials.accessKeyId);
    const cacheKey = `${shortDate}:${region}:${service}:${(0, util_hex_encoding_1.toHex)(credsHash)}:${credentials.sessionToken}`;
    if (cacheKey in signingKeyCache) {
        return signingKeyCache[cacheKey];
    }
    cacheQueue.push(cacheKey);
    while(cacheQueue.length > constants_1.MAX_CACHE_SIZE){
        delete signingKeyCache[cacheQueue.shift()];
    }
    let key = `AWS4${credentials.secretAccessKey}`;
    for (const signable of [
        shortDate,
        region,
        service,
        constants_1.KEY_TYPE_IDENTIFIER
    ]){
        key = await hmac(sha256Constructor, key, signable);
    }
    return signingKeyCache[cacheKey] = key;
};
exports.getSigningKey = getSigningKey;
const clearCredentialCache = ()=>{
    cacheQueue.length = 0;
    Object.keys(signingKeyCache).forEach((cacheKey)=>{
        delete signingKeyCache[cacheKey];
    });
};
exports.clearCredentialCache = clearCredentialCache;
const hmac = (ctor, secret, data)=>{
    const hash = new ctor(secret);
    hash.update((0, util_utf8_1.toUint8Array)(data));
    return hash.digest();
};


/***/ }),

/***/ 24043:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getCanonicalHeaders = void 0;
const constants_1 = __webpack_require__(43016);
const getCanonicalHeaders = ({ headers }, unsignableHeaders, signableHeaders)=>{
    const canonical = {};
    for (const headerName of Object.keys(headers).sort()){
        if (headers[headerName] == undefined) {
            continue;
        }
        const canonicalHeaderName = headerName.toLowerCase();
        if (canonicalHeaderName in constants_1.ALWAYS_UNSIGNABLE_HEADERS || (unsignableHeaders === null || unsignableHeaders === void 0 ? void 0 : unsignableHeaders.has(canonicalHeaderName)) || constants_1.PROXY_HEADER_PATTERN.test(canonicalHeaderName) || constants_1.SEC_HEADER_PATTERN.test(canonicalHeaderName)) {
            if (!signableHeaders || signableHeaders && !signableHeaders.has(canonicalHeaderName)) {
                continue;
            }
        }
        canonical[canonicalHeaderName] = headers[headerName].trim().replace(/\s+/g, " ");
    }
    return canonical;
};
exports.getCanonicalHeaders = getCanonicalHeaders;


/***/ }),

/***/ 47694:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getCanonicalQuery = void 0;
const util_uri_escape_1 = __webpack_require__(49731);
const constants_1 = __webpack_require__(43016);
const getCanonicalQuery = ({ query = {} })=>{
    const keys = [];
    const serialized = {};
    for (const key of Object.keys(query).sort()){
        if (key.toLowerCase() === constants_1.SIGNATURE_HEADER) {
            continue;
        }
        keys.push(key);
        const value = query[key];
        if (typeof value === "string") {
            serialized[key] = `${(0, util_uri_escape_1.escapeUri)(key)}=${(0, util_uri_escape_1.escapeUri)(value)}`;
        } else if (Array.isArray(value)) {
            serialized[key] = value.slice(0).reduce((encoded, value)=>encoded.concat([
                    `${(0, util_uri_escape_1.escapeUri)(key)}=${(0, util_uri_escape_1.escapeUri)(value)}`
                ]), []).sort().join("&");
        }
    }
    return keys.map((key)=>serialized[key]).filter((serialized)=>serialized).join("&");
};
exports.getCanonicalQuery = getCanonicalQuery;


/***/ }),

/***/ 62136:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getPayloadHash = void 0;
const is_array_buffer_1 = __webpack_require__(63530);
const util_hex_encoding_1 = __webpack_require__(7214);
const util_utf8_1 = __webpack_require__(66120);
const constants_1 = __webpack_require__(43016);
const getPayloadHash = async ({ headers, body }, hashConstructor)=>{
    for (const headerName of Object.keys(headers)){
        if (headerName.toLowerCase() === constants_1.SHA256_HEADER) {
            return headers[headerName];
        }
    }
    if (body == undefined) {
        return "e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855";
    } else if (typeof body === "string" || ArrayBuffer.isView(body) || (0, is_array_buffer_1.isArrayBuffer)(body)) {
        const hashCtor = new hashConstructor();
        hashCtor.update((0, util_utf8_1.toUint8Array)(body));
        return (0, util_hex_encoding_1.toHex)(await hashCtor.digest());
    }
    return constants_1.UNSIGNED_PAYLOAD;
};
exports.getPayloadHash = getPayloadHash;


/***/ }),

/***/ 62781:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.deleteHeader = exports.getHeaderValue = exports.hasHeader = void 0;
const hasHeader = (soughtHeader, headers)=>{
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)){
        if (soughtHeader === headerName.toLowerCase()) {
            return true;
        }
    }
    return false;
};
exports.hasHeader = hasHeader;
const getHeaderValue = (soughtHeader, headers)=>{
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)){
        if (soughtHeader === headerName.toLowerCase()) {
            return headers[headerName];
        }
    }
    return undefined;
};
exports.getHeaderValue = getHeaderValue;
const deleteHeader = (soughtHeader, headers)=>{
    soughtHeader = soughtHeader.toLowerCase();
    for (const headerName of Object.keys(headers)){
        if (soughtHeader === headerName.toLowerCase()) {
            delete headers[headerName];
        }
    }
};
exports.deleteHeader = deleteHeader;


/***/ }),

/***/ 19671:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.prepareRequest = exports.moveHeadersToQuery = exports.getPayloadHash = exports.getCanonicalQuery = exports.getCanonicalHeaders = void 0;
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(98305), exports);
var getCanonicalHeaders_1 = __webpack_require__(24043);
Object.defineProperty(exports, "getCanonicalHeaders", ({
    enumerable: true,
    get: function() {
        return getCanonicalHeaders_1.getCanonicalHeaders;
    }
}));
var getCanonicalQuery_1 = __webpack_require__(47694);
Object.defineProperty(exports, "getCanonicalQuery", ({
    enumerable: true,
    get: function() {
        return getCanonicalQuery_1.getCanonicalQuery;
    }
}));
var getPayloadHash_1 = __webpack_require__(62136);
Object.defineProperty(exports, "getPayloadHash", ({
    enumerable: true,
    get: function() {
        return getPayloadHash_1.getPayloadHash;
    }
}));
var moveHeadersToQuery_1 = __webpack_require__(55166);
Object.defineProperty(exports, "moveHeadersToQuery", ({
    enumerable: true,
    get: function() {
        return moveHeadersToQuery_1.moveHeadersToQuery;
    }
}));
var prepareRequest_1 = __webpack_require__(64638);
Object.defineProperty(exports, "prepareRequest", ({
    enumerable: true,
    get: function() {
        return prepareRequest_1.prepareRequest;
    }
}));
tslib_1.__exportStar(__webpack_require__(31188), exports);


/***/ }),

/***/ 55166:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.moveHeadersToQuery = void 0;
const cloneRequest_1 = __webpack_require__(52202);
const moveHeadersToQuery = (request, options = {})=>{
    var _a;
    const { headers, query = {} } = typeof request.clone === "function" ? request.clone() : (0, cloneRequest_1.cloneRequest)(request);
    for (const name of Object.keys(headers)){
        const lname = name.toLowerCase();
        if (lname.slice(0, 6) === "x-amz-" && !((_a = options.unhoistableHeaders) === null || _a === void 0 ? void 0 : _a.has(lname))) {
            query[name] = headers[name];
            delete headers[name];
        }
    }
    return {
        ...request,
        headers,
        query
    };
};
exports.moveHeadersToQuery = moveHeadersToQuery;


/***/ }),

/***/ 64638:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.prepareRequest = void 0;
const cloneRequest_1 = __webpack_require__(52202);
const constants_1 = __webpack_require__(43016);
const prepareRequest = (request)=>{
    request = typeof request.clone === "function" ? request.clone() : (0, cloneRequest_1.cloneRequest)(request);
    for (const headerName of Object.keys(request.headers)){
        if (constants_1.GENERATED_HEADERS.indexOf(headerName.toLowerCase()) > -1) {
            delete request.headers[headerName];
        }
    }
    return request;
};
exports.prepareRequest = prepareRequest;


/***/ }),

/***/ 53516:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.toDate = exports.iso8601 = void 0;
const iso8601 = (time)=>(0, exports.toDate)(time).toISOString().replace(/\.\d{3}Z$/, "Z");
exports.iso8601 = iso8601;
const toDate = (time)=>{
    if (typeof time === "number") {
        return new Date(time * 1000);
    }
    if (typeof time === "string") {
        if (Number(time)) {
            return new Date(Number(time) * 1000);
        }
        return new Date(time);
    }
    return time;
};
exports.toDate = toDate;


/***/ }),

/***/ 30158:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NoOpLogger = void 0;
class NoOpLogger {
    trace() {}
    debug() {}
    info() {}
    warn() {}
    error() {}
}
exports.NoOpLogger = NoOpLogger;


/***/ }),

/***/ 74910:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Client = void 0;
const middleware_stack_1 = __webpack_require__(65992);
class Client {
    constructor(config){
        this.middlewareStack = (0, middleware_stack_1.constructStack)();
        this.config = config;
    }
    send(command, optionsOrCb, cb) {
        const options = typeof optionsOrCb !== "function" ? optionsOrCb : undefined;
        const callback = typeof optionsOrCb === "function" ? optionsOrCb : cb;
        const handler = command.resolveMiddleware(this.middlewareStack, this.config, options);
        if (callback) {
            handler(command).then((result)=>callback(null, result.output), (err)=>callback(err)).catch(()=>{});
        } else {
            return handler(command).then((result)=>result.output);
        }
    }
    destroy() {
        if (this.config.requestHandler.destroy) this.config.requestHandler.destroy();
    }
}
exports.Client = Client;


/***/ }),

/***/ 72930:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.collectBody = void 0;
const util_stream_1 = __webpack_require__(70260);
const collectBody = async (streamBody = new Uint8Array(), context)=>{
    if (streamBody instanceof Uint8Array) {
        return util_stream_1.Uint8ArrayBlobAdapter.mutate(streamBody);
    }
    if (!streamBody) {
        return util_stream_1.Uint8ArrayBlobAdapter.mutate(new Uint8Array());
    }
    const fromContext = context.streamCollector(streamBody);
    return util_stream_1.Uint8ArrayBlobAdapter.mutate(await fromContext);
};
exports.collectBody = collectBody;


/***/ }),

/***/ 24638:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Command = void 0;
const middleware_stack_1 = __webpack_require__(65992);
class Command {
    constructor(){
        this.middlewareStack = (0, middleware_stack_1.constructStack)();
    }
}
exports.Command = Command;


/***/ }),

/***/ 56050:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.SENSITIVE_STRING = void 0;
exports.SENSITIVE_STRING = "***SensitiveInformation***";


/***/ }),

/***/ 59757:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createAggregatedClient = void 0;
const createAggregatedClient = (commands, Client)=>{
    for (const command of Object.keys(commands)){
        const CommandCtor = commands[command];
        const methodImpl = async function(args, optionsOrCb, cb) {
            const command = new CommandCtor(args);
            if (typeof optionsOrCb === "function") {
                this.send(command, optionsOrCb);
            } else if (typeof cb === "function") {
                if (typeof optionsOrCb !== "object") throw new Error(`Expected http options but got ${typeof optionsOrCb}`);
                this.send(command, optionsOrCb || {}, cb);
            } else {
                return this.send(command, optionsOrCb);
            }
        };
        const methodName = (command[0].toLowerCase() + command.slice(1)).replace(/Command$/, "");
        Client.prototype[methodName] = methodImpl;
    }
};
exports.createAggregatedClient = createAggregatedClient;


/***/ }),

/***/ 27214:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parseEpochTimestamp = exports.parseRfc7231DateTime = exports.parseRfc3339DateTimeWithOffset = exports.parseRfc3339DateTime = exports.dateToUtcString = void 0;
const parse_utils_1 = __webpack_require__(44209);
const DAYS = [
    "Sun",
    "Mon",
    "Tue",
    "Wed",
    "Thu",
    "Fri",
    "Sat"
];
const MONTHS = [
    "Jan",
    "Feb",
    "Mar",
    "Apr",
    "May",
    "Jun",
    "Jul",
    "Aug",
    "Sep",
    "Oct",
    "Nov",
    "Dec"
];
function dateToUtcString(date) {
    const year = date.getUTCFullYear();
    const month = date.getUTCMonth();
    const dayOfWeek = date.getUTCDay();
    const dayOfMonthInt = date.getUTCDate();
    const hoursInt = date.getUTCHours();
    const minutesInt = date.getUTCMinutes();
    const secondsInt = date.getUTCSeconds();
    const dayOfMonthString = dayOfMonthInt < 10 ? `0${dayOfMonthInt}` : `${dayOfMonthInt}`;
    const hoursString = hoursInt < 10 ? `0${hoursInt}` : `${hoursInt}`;
    const minutesString = minutesInt < 10 ? `0${minutesInt}` : `${minutesInt}`;
    const secondsString = secondsInt < 10 ? `0${secondsInt}` : `${secondsInt}`;
    return `${DAYS[dayOfWeek]}, ${dayOfMonthString} ${MONTHS[month]} ${year} ${hoursString}:${minutesString}:${secondsString} GMT`;
}
exports.dateToUtcString = dateToUtcString;
const RFC3339 = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?[zZ]$/);
const parseRfc3339DateTime = (value)=>{
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds] = match;
    const year = (0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    return buildDate(year, month, day, {
        hours,
        minutes,
        seconds,
        fractionalMilliseconds
    });
};
exports.parseRfc3339DateTime = parseRfc3339DateTime;
const RFC3339_WITH_OFFSET = new RegExp(/^(\d{4})-(\d{2})-(\d{2})[tT](\d{2}):(\d{2}):(\d{2})(?:\.(\d+))?(([-+]\d{2}\:\d{2})|[zZ])$/);
const parseRfc3339DateTimeWithOffset = (value)=>{
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-3339 date-times must be expressed as strings");
    }
    const match = RFC3339_WITH_OFFSET.exec(value);
    if (!match) {
        throw new TypeError("Invalid RFC-3339 date-time value");
    }
    const [_, yearStr, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, offsetStr] = match;
    const year = (0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr));
    const month = parseDateValue(monthStr, "month", 1, 12);
    const day = parseDateValue(dayStr, "day", 1, 31);
    const date = buildDate(year, month, day, {
        hours,
        minutes,
        seconds,
        fractionalMilliseconds
    });
    if (offsetStr.toUpperCase() != "Z") {
        date.setTime(date.getTime() - parseOffsetToMilliseconds(offsetStr));
    }
    return date;
};
exports.parseRfc3339DateTimeWithOffset = parseRfc3339DateTimeWithOffset;
const IMF_FIXDATE = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun), (\d{2}) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) (\d{4}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
const RFC_850_DATE = new RegExp(/^(?:Monday|Tuesday|Wednesday|Thursday|Friday|Saturday|Sunday), (\d{2})-(Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec)-(\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? GMT$/);
const ASC_TIME = new RegExp(/^(?:Mon|Tue|Wed|Thu|Fri|Sat|Sun) (Jan|Feb|Mar|Apr|May|Jun|Jul|Aug|Sep|Oct|Nov|Dec) ( [1-9]|\d{2}) (\d{1,2}):(\d{2}):(\d{2})(?:\.(\d+))? (\d{4})$/);
const parseRfc7231DateTime = (value)=>{
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value !== "string") {
        throw new TypeError("RFC-7231 date-times must be expressed as strings");
    }
    let match = IMF_FIXDATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return buildDate((0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds
        });
    }
    match = RFC_850_DATE.exec(value);
    if (match) {
        const [_, dayStr, monthStr, yearStr, hours, minutes, seconds, fractionalMilliseconds] = match;
        return adjustRfc850Year(buildDate(parseTwoDigitYear(yearStr), parseMonthByShortName(monthStr), parseDateValue(dayStr, "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds
        }));
    }
    match = ASC_TIME.exec(value);
    if (match) {
        const [_, monthStr, dayStr, hours, minutes, seconds, fractionalMilliseconds, yearStr] = match;
        return buildDate((0, parse_utils_1.strictParseShort)(stripLeadingZeroes(yearStr)), parseMonthByShortName(monthStr), parseDateValue(dayStr.trimLeft(), "day", 1, 31), {
            hours,
            minutes,
            seconds,
            fractionalMilliseconds
        });
    }
    throw new TypeError("Invalid RFC-7231 date-time value");
};
exports.parseRfc7231DateTime = parseRfc7231DateTime;
const parseEpochTimestamp = (value)=>{
    if (value === null || value === undefined) {
        return undefined;
    }
    let valueAsDouble;
    if (typeof value === "number") {
        valueAsDouble = value;
    } else if (typeof value === "string") {
        valueAsDouble = (0, parse_utils_1.strictParseDouble)(value);
    } else {
        throw new TypeError("Epoch timestamps must be expressed as floating point numbers or their string representation");
    }
    if (Number.isNaN(valueAsDouble) || valueAsDouble === Infinity || valueAsDouble === -Infinity) {
        throw new TypeError("Epoch timestamps must be valid, non-Infinite, non-NaN numerics");
    }
    return new Date(Math.round(valueAsDouble * 1000));
};
exports.parseEpochTimestamp = parseEpochTimestamp;
const buildDate = (year, month, day, time)=>{
    const adjustedMonth = month - 1;
    validateDayOfMonth(year, adjustedMonth, day);
    return new Date(Date.UTC(year, adjustedMonth, day, parseDateValue(time.hours, "hour", 0, 23), parseDateValue(time.minutes, "minute", 0, 59), parseDateValue(time.seconds, "seconds", 0, 60), parseMilliseconds(time.fractionalMilliseconds)));
};
const parseTwoDigitYear = (value)=>{
    const thisYear = new Date().getUTCFullYear();
    const valueInThisCentury = Math.floor(thisYear / 100) * 100 + (0, parse_utils_1.strictParseShort)(stripLeadingZeroes(value));
    if (valueInThisCentury < thisYear) {
        return valueInThisCentury + 100;
    }
    return valueInThisCentury;
};
const FIFTY_YEARS_IN_MILLIS = 50 * 365 * 24 * 60 * 60 * 1000;
const adjustRfc850Year = (input)=>{
    if (input.getTime() - new Date().getTime() > FIFTY_YEARS_IN_MILLIS) {
        return new Date(Date.UTC(input.getUTCFullYear() - 100, input.getUTCMonth(), input.getUTCDate(), input.getUTCHours(), input.getUTCMinutes(), input.getUTCSeconds(), input.getUTCMilliseconds()));
    }
    return input;
};
const parseMonthByShortName = (value)=>{
    const monthIdx = MONTHS.indexOf(value);
    if (monthIdx < 0) {
        throw new TypeError(`Invalid month: ${value}`);
    }
    return monthIdx + 1;
};
const DAYS_IN_MONTH = [
    31,
    28,
    31,
    30,
    31,
    30,
    31,
    31,
    30,
    31,
    30,
    31
];
const validateDayOfMonth = (year, month, day)=>{
    let maxDays = DAYS_IN_MONTH[month];
    if (month === 1 && isLeapYear(year)) {
        maxDays = 29;
    }
    if (day > maxDays) {
        throw new TypeError(`Invalid day for ${MONTHS[month]} in ${year}: ${day}`);
    }
};
const isLeapYear = (year)=>{
    return year % 4 === 0 && (year % 100 !== 0 || year % 400 === 0);
};
const parseDateValue = (value, type, lower, upper)=>{
    const dateVal = (0, parse_utils_1.strictParseByte)(stripLeadingZeroes(value));
    if (dateVal < lower || dateVal > upper) {
        throw new TypeError(`${type} must be between ${lower} and ${upper}, inclusive`);
    }
    return dateVal;
};
const parseMilliseconds = (value)=>{
    if (value === null || value === undefined) {
        return 0;
    }
    return (0, parse_utils_1.strictParseFloat32)("0." + value) * 1000;
};
const parseOffsetToMilliseconds = (value)=>{
    const directionStr = value[0];
    let direction = 1;
    if (directionStr == "+") {
        direction = 1;
    } else if (directionStr == "-") {
        direction = -1;
    } else {
        throw new TypeError(`Offset direction, ${directionStr}, must be "+" or "-"`);
    }
    const hour = Number(value.substring(1, 3));
    const minute = Number(value.substring(4, 6));
    return direction * (hour * 60 + minute) * 60 * 1000;
};
const stripLeadingZeroes = (value)=>{
    let idx = 0;
    while(idx < value.length - 1 && value.charAt(idx) === "0"){
        idx++;
    }
    if (idx === 0) {
        return value;
    }
    return value.slice(idx);
};


/***/ }),

/***/ 77773:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.withBaseException = exports.throwDefaultError = void 0;
const exceptions_1 = __webpack_require__(69429);
const throwDefaultError = ({ output, parsedBody, exceptionCtor, errorCode })=>{
    const $metadata = deserializeMetadata(output);
    const statusCode = $metadata.httpStatusCode ? $metadata.httpStatusCode + "" : undefined;
    const response = new exceptionCtor({
        name: (parsedBody === null || parsedBody === void 0 ? void 0 : parsedBody.code) || (parsedBody === null || parsedBody === void 0 ? void 0 : parsedBody.Code) || errorCode || statusCode || "UnknownError",
        $fault: "client",
        $metadata
    });
    throw (0, exceptions_1.decorateServiceException)(response, parsedBody);
};
exports.throwDefaultError = throwDefaultError;
const withBaseException = (ExceptionCtor)=>{
    return ({ output, parsedBody, errorCode })=>{
        (0, exports.throwDefaultError)({
            output,
            parsedBody,
            exceptionCtor: ExceptionCtor,
            errorCode
        });
    };
};
exports.withBaseException = withBaseException;
const deserializeMetadata = (output)=>{
    var _a, _b;
    return {
        httpStatusCode: output.statusCode,
        requestId: (_b = (_a = output.headers["x-amzn-requestid"]) !== null && _a !== void 0 ? _a : output.headers["x-amzn-request-id"]) !== null && _b !== void 0 ? _b : output.headers["x-amz-request-id"],
        extendedRequestId: output.headers["x-amz-id-2"],
        cfId: output.headers["x-amz-cf-id"]
    };
};


/***/ }),

/***/ 10800:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.loadConfigsForDefaultMode = void 0;
const loadConfigsForDefaultMode = (mode)=>{
    switch(mode){
        case "standard":
            return {
                retryMode: "standard",
                connectionTimeout: 3100
            };
        case "in-region":
            return {
                retryMode: "standard",
                connectionTimeout: 1100
            };
        case "cross-region":
            return {
                retryMode: "standard",
                connectionTimeout: 3100
            };
        case "mobile":
            return {
                retryMode: "standard",
                connectionTimeout: 30000
            };
        default:
            return {};
    }
};
exports.loadConfigsForDefaultMode = loadConfigsForDefaultMode;


/***/ }),

/***/ 16107:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.emitWarningIfUnsupportedVersion = void 0;
let warningEmitted = false;
const emitWarningIfUnsupportedVersion = (version)=>{
    if (version && !warningEmitted && parseInt(version.substring(1, version.indexOf("."))) < 14) {
        warningEmitted = true;
    }
};
exports.emitWarningIfUnsupportedVersion = emitWarningIfUnsupportedVersion;


/***/ }),

/***/ 69429:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.decorateServiceException = exports.ServiceException = void 0;
class ServiceException extends Error {
    constructor(options){
        super(options.message);
        Object.setPrototypeOf(this, ServiceException.prototype);
        this.name = options.name;
        this.$fault = options.$fault;
        this.$metadata = options.$metadata;
    }
}
exports.ServiceException = ServiceException;
const decorateServiceException = (exception, additions = {})=>{
    Object.entries(additions).filter(([, v])=>v !== undefined).forEach(([k, v])=>{
        if (exception[k] == undefined || exception[k] === "") {
            exception[k] = v;
        }
    });
    const message = exception.message || exception.Message || "UnknownError";
    exception.message = message;
    delete exception.Message;
    return exception;
};
exports.decorateServiceException = decorateServiceException;


/***/ }),

/***/ 29085:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.extendedEncodeURIComponent = void 0;
function extendedEncodeURIComponent(str) {
    return encodeURIComponent(str).replace(/[!'()*]/g, function(c) {
        return "%" + c.charCodeAt(0).toString(16).toUpperCase();
    });
}
exports.extendedEncodeURIComponent = extendedEncodeURIComponent;


/***/ }),

/***/ 79398:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveChecksumRuntimeConfig = exports.getChecksumConfiguration = exports.AlgorithmId = void 0;
const types_1 = __webpack_require__(46754);
Object.defineProperty(exports, "AlgorithmId", ({
    enumerable: true,
    get: function() {
        return types_1.AlgorithmId;
    }
}));
const getChecksumConfiguration = (runtimeConfig)=>{
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: ()=>types_1.AlgorithmId.SHA256,
            checksumConstructor: ()=>runtimeConfig.sha256
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: ()=>types_1.AlgorithmId.MD5,
            checksumConstructor: ()=>runtimeConfig.md5
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm (algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms () {
            return this._checksumAlgorithms;
        }
    };
};
exports.getChecksumConfiguration = getChecksumConfiguration;
const resolveChecksumRuntimeConfig = (clientConfig)=>{
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm)=>{
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};
exports.resolveChecksumRuntimeConfig = resolveChecksumRuntimeConfig;


/***/ }),

/***/ 19706:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveDefaultRuntimeConfig = exports.getDefaultClientConfiguration = exports.getDefaultExtensionConfiguration = void 0;
const checksum_1 = __webpack_require__(79398);
const getDefaultExtensionConfiguration = (runtimeConfig)=>{
    return {
        ...(0, checksum_1.getChecksumConfiguration)(runtimeConfig)
    };
};
exports.getDefaultExtensionConfiguration = getDefaultExtensionConfiguration;
exports.getDefaultClientConfiguration = exports.getDefaultExtensionConfiguration;
const resolveDefaultRuntimeConfig = (config)=>{
    return {
        ...(0, checksum_1.resolveChecksumRuntimeConfig)(config)
    };
};
exports.resolveDefaultRuntimeConfig = resolveDefaultRuntimeConfig;


/***/ }),

/***/ 60717:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(19706), exports);


/***/ }),

/***/ 68132:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getArrayIfSingleItem = void 0;
const getArrayIfSingleItem = (mayBeArray)=>Array.isArray(mayBeArray) ? mayBeArray : [
        mayBeArray
    ];
exports.getArrayIfSingleItem = getArrayIfSingleItem;


/***/ }),

/***/ 51616:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getValueFromTextNode = void 0;
const getValueFromTextNode = (obj)=>{
    const textNodeName = "#text";
    for(const key in obj){
        if (obj.hasOwnProperty(key) && obj[key][textNodeName] !== undefined) {
            obj[key] = obj[key][textNodeName];
        } else if (typeof obj[key] === "object" && obj[key] !== null) {
            obj[key] = (0, exports.getValueFromTextNode)(obj[key]);
        }
    }
    return obj;
};
exports.getValueFromTextNode = getValueFromTextNode;


/***/ }),

/***/ 18851:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(30158), exports);
tslib_1.__exportStar(__webpack_require__(74910), exports);
tslib_1.__exportStar(__webpack_require__(72930), exports);
tslib_1.__exportStar(__webpack_require__(24638), exports);
tslib_1.__exportStar(__webpack_require__(56050), exports);
tslib_1.__exportStar(__webpack_require__(59757), exports);
tslib_1.__exportStar(__webpack_require__(27214), exports);
tslib_1.__exportStar(__webpack_require__(77773), exports);
tslib_1.__exportStar(__webpack_require__(10800), exports);
tslib_1.__exportStar(__webpack_require__(16107), exports);
tslib_1.__exportStar(__webpack_require__(60717), exports);
tslib_1.__exportStar(__webpack_require__(69429), exports);
tslib_1.__exportStar(__webpack_require__(29085), exports);
tslib_1.__exportStar(__webpack_require__(68132), exports);
tslib_1.__exportStar(__webpack_require__(51616), exports);
tslib_1.__exportStar(__webpack_require__(71680), exports);
tslib_1.__exportStar(__webpack_require__(99558), exports);
tslib_1.__exportStar(__webpack_require__(44209), exports);
tslib_1.__exportStar(__webpack_require__(25110), exports);
tslib_1.__exportStar(__webpack_require__(13207), exports);
tslib_1.__exportStar(__webpack_require__(97905), exports);
tslib_1.__exportStar(__webpack_require__(98350), exports);


/***/ }),

/***/ 71680:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.LazyJsonString = exports.StringWrapper = void 0;
const StringWrapper = function() {
    const Class = Object.getPrototypeOf(this).constructor;
    const Constructor = Function.bind.apply(String, [
        null,
        ...arguments
    ]);
    const instance = new Constructor();
    Object.setPrototypeOf(instance, Class.prototype);
    return instance;
};
exports.StringWrapper = StringWrapper;
exports.StringWrapper.prototype = Object.create(String.prototype, {
    constructor: {
        value: exports.StringWrapper,
        enumerable: false,
        writable: true,
        configurable: true
    }
});
Object.setPrototypeOf(exports.StringWrapper, String);
class LazyJsonString extends exports.StringWrapper {
    deserializeJSON() {
        return JSON.parse(super.toString());
    }
    toJSON() {
        return super.toString();
    }
    static fromObject(object) {
        if (object instanceof LazyJsonString) {
            return object;
        } else if (object instanceof String || typeof object === "string") {
            return new LazyJsonString(object);
        }
        return new LazyJsonString(JSON.stringify(object));
    }
}
exports.LazyJsonString = LazyJsonString;


/***/ }),

/***/ 99558:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.take = exports.convertMap = exports.map = void 0;
function map(arg0, arg1, arg2) {
    let target;
    let filter;
    let instructions;
    if (typeof arg1 === "undefined" && typeof arg2 === "undefined") {
        target = {};
        instructions = arg0;
    } else {
        target = arg0;
        if (typeof arg1 === "function") {
            filter = arg1;
            instructions = arg2;
            return mapWithFilter(target, filter, instructions);
        } else {
            instructions = arg1;
        }
    }
    for (const key of Object.keys(instructions)){
        if (!Array.isArray(instructions[key])) {
            target[key] = instructions[key];
            continue;
        }
        applyInstruction(target, null, instructions, key);
    }
    return target;
}
exports.map = map;
const convertMap = (target)=>{
    const output = {};
    for (const [k, v] of Object.entries(target || {})){
        output[k] = [
            ,
            v
        ];
    }
    return output;
};
exports.convertMap = convertMap;
const take = (source, instructions)=>{
    const out = {};
    for(const key in instructions){
        applyInstruction(out, source, instructions, key);
    }
    return out;
};
exports.take = take;
const mapWithFilter = (target, filter, instructions)=>{
    return map(target, Object.entries(instructions).reduce((_instructions, [key, value])=>{
        if (Array.isArray(value)) {
            _instructions[key] = value;
        } else {
            if (typeof value === "function") {
                _instructions[key] = [
                    filter,
                    value()
                ];
            } else {
                _instructions[key] = [
                    filter,
                    value
                ];
            }
        }
        return _instructions;
    }, {}));
};
const applyInstruction = (target, source, instructions, targetKey)=>{
    if (source !== null) {
        let instruction = instructions[targetKey];
        if (typeof instruction === "function") {
            instruction = [
                ,
                instruction
            ];
        }
        const [filter = nonNullish, valueFn = pass, sourceKey = targetKey] = instruction;
        if (typeof filter === "function" && filter(source[sourceKey]) || typeof filter !== "function" && !!filter) {
            target[targetKey] = valueFn(source[sourceKey]);
        }
        return;
    }
    let [filter, value] = instructions[targetKey];
    if (typeof value === "function") {
        let _value;
        const defaultFilterPassed = filter === undefined && (_value = value()) != null;
        const customFilterPassed = typeof filter === "function" && !!filter(void 0) || typeof filter !== "function" && !!filter;
        if (defaultFilterPassed) {
            target[targetKey] = _value;
        } else if (customFilterPassed) {
            target[targetKey] = value();
        }
    } else {
        const defaultFilterPassed = filter === undefined && value != null;
        const customFilterPassed = typeof filter === "function" && !!filter(value) || typeof filter !== "function" && !!filter;
        if (defaultFilterPassed || customFilterPassed) {
            target[targetKey] = value;
        }
    }
};
const nonNullish = (_)=>_ != null;
const pass = (_)=>_;


/***/ }),

/***/ 44209:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.logger = exports.strictParseByte = exports.strictParseShort = exports.strictParseInt32 = exports.strictParseInt = exports.strictParseLong = exports.limitedParseFloat32 = exports.limitedParseFloat = exports.handleFloat = exports.limitedParseDouble = exports.strictParseFloat32 = exports.strictParseFloat = exports.strictParseDouble = exports.expectUnion = exports.expectString = exports.expectObject = exports.expectNonNull = exports.expectByte = exports.expectShort = exports.expectInt32 = exports.expectInt = exports.expectLong = exports.expectFloat32 = exports.expectNumber = exports.expectBoolean = exports.parseBoolean = void 0;
const parseBoolean = (value)=>{
    switch(value){
        case "true":
            return true;
        case "false":
            return false;
        default:
            throw new Error(`Unable to parse boolean value "${value}"`);
    }
};
exports.parseBoolean = parseBoolean;
const expectBoolean = (value)=>{
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "number") {
        if (value === 0 || value === 1) {
            exports.logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (value === 0) {
            return false;
        }
        if (value === 1) {
            return true;
        }
    }
    if (typeof value === "string") {
        const lower = value.toLowerCase();
        if (lower === "false" || lower === "true") {
            exports.logger.warn(stackTraceWarning(`Expected boolean, got ${typeof value}: ${value}`));
        }
        if (lower === "false") {
            return false;
        }
        if (lower === "true") {
            return true;
        }
    }
    if (typeof value === "boolean") {
        return value;
    }
    throw new TypeError(`Expected boolean, got ${typeof value}: ${value}`);
};
exports.expectBoolean = expectBoolean;
const expectNumber = (value)=>{
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        const parsed = parseFloat(value);
        if (!Number.isNaN(parsed)) {
            if (String(parsed) !== String(value)) {
                exports.logger.warn(stackTraceWarning(`Expected number but observed string: ${value}`));
            }
            return parsed;
        }
    }
    if (typeof value === "number") {
        return value;
    }
    throw new TypeError(`Expected number, got ${typeof value}: ${value}`);
};
exports.expectNumber = expectNumber;
const MAX_FLOAT = Math.ceil(2 ** 127 * (2 - 2 ** -23));
const expectFloat32 = (value)=>{
    const expected = (0, exports.expectNumber)(value);
    if (expected !== undefined && !Number.isNaN(expected) && expected !== Infinity && expected !== -Infinity) {
        if (Math.abs(expected) > MAX_FLOAT) {
            throw new TypeError(`Expected 32-bit float, got ${value}`);
        }
    }
    return expected;
};
exports.expectFloat32 = expectFloat32;
const expectLong = (value)=>{
    if (value === null || value === undefined) {
        return undefined;
    }
    if (Number.isInteger(value) && !Number.isNaN(value)) {
        return value;
    }
    throw new TypeError(`Expected integer, got ${typeof value}: ${value}`);
};
exports.expectLong = expectLong;
exports.expectInt = exports.expectLong;
const expectInt32 = (value)=>expectSizedInt(value, 32);
exports.expectInt32 = expectInt32;
const expectShort = (value)=>expectSizedInt(value, 16);
exports.expectShort = expectShort;
const expectByte = (value)=>expectSizedInt(value, 8);
exports.expectByte = expectByte;
const expectSizedInt = (value, size)=>{
    const expected = (0, exports.expectLong)(value);
    if (expected !== undefined && castInt(expected, size) !== expected) {
        throw new TypeError(`Expected ${size}-bit integer, got ${value}`);
    }
    return expected;
};
const castInt = (value, size)=>{
    switch(size){
        case 32:
            return Int32Array.of(value)[0];
        case 16:
            return Int16Array.of(value)[0];
        case 8:
            return Int8Array.of(value)[0];
    }
};
const expectNonNull = (value, location)=>{
    if (value === null || value === undefined) {
        if (location) {
            throw new TypeError(`Expected a non-null value for ${location}`);
        }
        throw new TypeError("Expected a non-null value");
    }
    return value;
};
exports.expectNonNull = expectNonNull;
const expectObject = (value)=>{
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "object" && !Array.isArray(value)) {
        return value;
    }
    const receivedType = Array.isArray(value) ? "array" : typeof value;
    throw new TypeError(`Expected object, got ${receivedType}: ${value}`);
};
exports.expectObject = expectObject;
const expectString = (value)=>{
    if (value === null || value === undefined) {
        return undefined;
    }
    if (typeof value === "string") {
        return value;
    }
    if ([
        "boolean",
        "number",
        "bigint"
    ].includes(typeof value)) {
        exports.logger.warn(stackTraceWarning(`Expected string, got ${typeof value}: ${value}`));
        return String(value);
    }
    throw new TypeError(`Expected string, got ${typeof value}: ${value}`);
};
exports.expectString = expectString;
const expectUnion = (value)=>{
    if (value === null || value === undefined) {
        return undefined;
    }
    const asObject = (0, exports.expectObject)(value);
    const setKeys = Object.entries(asObject).filter(([, v])=>v != null).map(([k])=>k);
    if (setKeys.length === 0) {
        throw new TypeError(`Unions must have exactly one non-null member. None were found.`);
    }
    if (setKeys.length > 1) {
        throw new TypeError(`Unions must have exactly one non-null member. Keys ${setKeys} were not null.`);
    }
    return asObject;
};
exports.expectUnion = expectUnion;
const strictParseDouble = (value)=>{
    if (typeof value == "string") {
        return (0, exports.expectNumber)(parseNumber(value));
    }
    return (0, exports.expectNumber)(value);
};
exports.strictParseDouble = strictParseDouble;
exports.strictParseFloat = exports.strictParseDouble;
const strictParseFloat32 = (value)=>{
    if (typeof value == "string") {
        return (0, exports.expectFloat32)(parseNumber(value));
    }
    return (0, exports.expectFloat32)(value);
};
exports.strictParseFloat32 = strictParseFloat32;
const NUMBER_REGEX = /(-?(?:0|[1-9]\d*)(?:\.\d+)?(?:[eE][+-]?\d+)?)|(-?Infinity)|(NaN)/g;
const parseNumber = (value)=>{
    const matches = value.match(NUMBER_REGEX);
    if (matches === null || matches[0].length !== value.length) {
        throw new TypeError(`Expected real number, got implicit NaN`);
    }
    return parseFloat(value);
};
const limitedParseDouble = (value)=>{
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return (0, exports.expectNumber)(value);
};
exports.limitedParseDouble = limitedParseDouble;
exports.handleFloat = exports.limitedParseDouble;
exports.limitedParseFloat = exports.limitedParseDouble;
const limitedParseFloat32 = (value)=>{
    if (typeof value == "string") {
        return parseFloatString(value);
    }
    return (0, exports.expectFloat32)(value);
};
exports.limitedParseFloat32 = limitedParseFloat32;
const parseFloatString = (value)=>{
    switch(value){
        case "NaN":
            return NaN;
        case "Infinity":
            return Infinity;
        case "-Infinity":
            return -Infinity;
        default:
            throw new Error(`Unable to parse float value: ${value}`);
    }
};
const strictParseLong = (value)=>{
    if (typeof value === "string") {
        return (0, exports.expectLong)(parseNumber(value));
    }
    return (0, exports.expectLong)(value);
};
exports.strictParseLong = strictParseLong;
exports.strictParseInt = exports.strictParseLong;
const strictParseInt32 = (value)=>{
    if (typeof value === "string") {
        return (0, exports.expectInt32)(parseNumber(value));
    }
    return (0, exports.expectInt32)(value);
};
exports.strictParseInt32 = strictParseInt32;
const strictParseShort = (value)=>{
    if (typeof value === "string") {
        return (0, exports.expectShort)(parseNumber(value));
    }
    return (0, exports.expectShort)(value);
};
exports.strictParseShort = strictParseShort;
const strictParseByte = (value)=>{
    if (typeof value === "string") {
        return (0, exports.expectByte)(parseNumber(value));
    }
    return (0, exports.expectByte)(value);
};
exports.strictParseByte = strictParseByte;
const stackTraceWarning = (message)=>{
    return String(new TypeError(message).stack || message).split("\n").slice(0, 5).filter((s)=>!s.includes("stackTraceWarning")).join("\n");
};
exports.logger = {
    warn: console.warn
};


/***/ }),

/***/ 25110:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolvedPath = void 0;
const extended_encode_uri_component_1 = __webpack_require__(29085);
const resolvedPath = (resolvedPath, input, memberName, labelValueProvider, uriLabel, isGreedyLabel)=>{
    if (input != null && input[memberName] !== undefined) {
        const labelValue = labelValueProvider();
        if (labelValue.length <= 0) {
            throw new Error("Empty value provided for input HTTP label: " + memberName + ".");
        }
        resolvedPath = resolvedPath.replace(uriLabel, isGreedyLabel ? labelValue.split("/").map((segment)=>(0, extended_encode_uri_component_1.extendedEncodeURIComponent)(segment)).join("/") : (0, extended_encode_uri_component_1.extendedEncodeURIComponent)(labelValue));
    } else {
        throw new Error("No value provided for input HTTP label: " + memberName + ".");
    }
    return resolvedPath;
};
exports.resolvedPath = resolvedPath;


/***/ }),

/***/ 13207:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.serializeFloat = void 0;
const serializeFloat = (value)=>{
    if (value !== value) {
        return "NaN";
    }
    switch(value){
        case Infinity:
            return "Infinity";
        case -Infinity:
            return "-Infinity";
        default:
            return value;
    }
};
exports.serializeFloat = serializeFloat;


/***/ }),

/***/ 97905:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports._json = void 0;
const _json = (obj)=>{
    if (obj == null) {
        return {};
    }
    if (Array.isArray(obj)) {
        return obj.filter((_)=>_ != null);
    }
    if (typeof obj === "object") {
        const target = {};
        for (const key of Object.keys(obj)){
            if (obj[key] == null) {
                continue;
            }
            target[key] = (0, exports._json)(obj[key]);
        }
        return target;
    }
    return obj;
};
exports._json = _json;


/***/ }),

/***/ 98350:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.splitEvery = void 0;
function splitEvery(value, delimiter, numDelimiters) {
    if (numDelimiters <= 0 || !Number.isInteger(numDelimiters)) {
        throw new Error("Invalid number of delimiters (" + numDelimiters + ") for splitEvery.");
    }
    const segments = value.split(delimiter);
    if (numDelimiters === 1) {
        return segments;
    }
    const compoundSegments = [];
    let currentSegment = "";
    for(let i = 0; i < segments.length; i++){
        if (currentSegment === "") {
            currentSegment = segments[i];
        } else {
            currentSegment += delimiter + segments[i];
        }
        if ((i + 1) % numDelimiters === 0) {
            compoundSegments.push(currentSegment);
            currentSegment = "";
        }
    }
    if (currentSegment !== "") {
        compoundSegments.push(currentSegment);
    }
    return compoundSegments;
}
exports.splitEvery = splitEvery;


/***/ }),

/***/ 76356:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 22221:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.HttpAuthLocation = void 0;
var HttpAuthLocation;
(function(HttpAuthLocation) {
    HttpAuthLocation["HEADER"] = "header";
    HttpAuthLocation["QUERY"] = "query";
})(HttpAuthLocation = exports.HttpAuthLocation || (exports.HttpAuthLocation = {}));


/***/ }),

/***/ 68511:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 90813:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 78734:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 73103:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 14734:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 22220:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(14734), exports);
tslib_1.__exportStar(__webpack_require__(69497), exports);
tslib_1.__exportStar(__webpack_require__(39817), exports);


/***/ }),

/***/ 69497:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 39817:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 99410:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 37692:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 31238:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.EndpointURLScheme = void 0;
var EndpointURLScheme;
(function(EndpointURLScheme) {
    EndpointURLScheme["HTTP"] = "http";
    EndpointURLScheme["HTTPS"] = "https";
})(EndpointURLScheme = exports.EndpointURLScheme || (exports.EndpointURLScheme = {}));


/***/ }),

/***/ 43216:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 60586:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 45015:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 91636:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 46366:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(43216), exports);
tslib_1.__exportStar(__webpack_require__(60586), exports);
tslib_1.__exportStar(__webpack_require__(45015), exports);
tslib_1.__exportStar(__webpack_require__(67166), exports);
tslib_1.__exportStar(__webpack_require__(91636), exports);


/***/ }),

/***/ 67166:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 8427:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 12591:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveChecksumRuntimeConfig = exports.getChecksumConfiguration = exports.AlgorithmId = void 0;
var AlgorithmId;
(function(AlgorithmId) {
    AlgorithmId["MD5"] = "md5";
    AlgorithmId["CRC32"] = "crc32";
    AlgorithmId["CRC32C"] = "crc32c";
    AlgorithmId["SHA1"] = "sha1";
    AlgorithmId["SHA256"] = "sha256";
})(AlgorithmId = exports.AlgorithmId || (exports.AlgorithmId = {}));
const getChecksumConfiguration = (runtimeConfig)=>{
    const checksumAlgorithms = [];
    if (runtimeConfig.sha256 !== undefined) {
        checksumAlgorithms.push({
            algorithmId: ()=>AlgorithmId.SHA256,
            checksumConstructor: ()=>runtimeConfig.sha256
        });
    }
    if (runtimeConfig.md5 != undefined) {
        checksumAlgorithms.push({
            algorithmId: ()=>AlgorithmId.MD5,
            checksumConstructor: ()=>runtimeConfig.md5
        });
    }
    return {
        _checksumAlgorithms: checksumAlgorithms,
        addChecksumAlgorithm (algo) {
            this._checksumAlgorithms.push(algo);
        },
        checksumAlgorithms () {
            return this._checksumAlgorithms;
        }
    };
};
exports.getChecksumConfiguration = getChecksumConfiguration;
const resolveChecksumRuntimeConfig = (clientConfig)=>{
    const runtimeConfig = {};
    clientConfig.checksumAlgorithms().forEach((checksumAlgorithm)=>{
        runtimeConfig[checksumAlgorithm.algorithmId()] = checksumAlgorithm.checksumConstructor();
    });
    return runtimeConfig;
};
exports.resolveChecksumRuntimeConfig = resolveChecksumRuntimeConfig;


/***/ }),

/***/ 94317:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveDefaultRuntimeConfig = exports.getDefaultClientConfiguration = void 0;
const checksum_1 = __webpack_require__(12591);
const getDefaultClientConfiguration = (runtimeConfig)=>{
    return {
        ...(0, checksum_1.getChecksumConfiguration)(runtimeConfig)
    };
};
exports.getDefaultClientConfiguration = getDefaultClientConfiguration;
const resolveDefaultRuntimeConfig = (config)=>{
    return {
        ...(0, checksum_1.resolveChecksumRuntimeConfig)(config)
    };
};
exports.resolveDefaultRuntimeConfig = resolveDefaultRuntimeConfig;


/***/ }),

/***/ 25171:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 67858:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AlgorithmId = void 0;
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(94317), exports);
tslib_1.__exportStar(__webpack_require__(25171), exports);
var checksum_1 = __webpack_require__(12591);
Object.defineProperty(exports, "AlgorithmId", ({
    enumerable: true,
    get: function() {
        return checksum_1.AlgorithmId;
    }
}));


/***/ }),

/***/ 24285:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.FieldPosition = void 0;
var FieldPosition;
(function(FieldPosition) {
    FieldPosition[FieldPosition["HEADER"] = 0] = "HEADER";
    FieldPosition[FieldPosition["TRAILER"] = 1] = "TRAILER";
})(FieldPosition = exports.FieldPosition || (exports.FieldPosition = {}));


/***/ }),

/***/ 66887:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 36446:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 22777:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(66887), exports);
tslib_1.__exportStar(__webpack_require__(36446), exports);


/***/ }),

/***/ 46754:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(76356), exports);
tslib_1.__exportStar(__webpack_require__(22221), exports);
tslib_1.__exportStar(__webpack_require__(68511), exports);
tslib_1.__exportStar(__webpack_require__(90813), exports);
tslib_1.__exportStar(__webpack_require__(78734), exports);
tslib_1.__exportStar(__webpack_require__(73103), exports);
tslib_1.__exportStar(__webpack_require__(22220), exports);
tslib_1.__exportStar(__webpack_require__(99410), exports);
tslib_1.__exportStar(__webpack_require__(37692), exports);
tslib_1.__exportStar(__webpack_require__(31238), exports);
tslib_1.__exportStar(__webpack_require__(46366), exports);
tslib_1.__exportStar(__webpack_require__(8427), exports);
tslib_1.__exportStar(__webpack_require__(67858), exports);
tslib_1.__exportStar(__webpack_require__(24285), exports);
tslib_1.__exportStar(__webpack_require__(22777), exports);
tslib_1.__exportStar(__webpack_require__(37157), exports);
tslib_1.__exportStar(__webpack_require__(14121), exports);
tslib_1.__exportStar(__webpack_require__(2198), exports);
tslib_1.__exportStar(__webpack_require__(57740), exports);
tslib_1.__exportStar(__webpack_require__(32586), exports);
tslib_1.__exportStar(__webpack_require__(39282), exports);
tslib_1.__exportStar(__webpack_require__(74684), exports);
tslib_1.__exportStar(__webpack_require__(85329), exports);
tslib_1.__exportStar(__webpack_require__(50682), exports);
tslib_1.__exportStar(__webpack_require__(74838), exports);
tslib_1.__exportStar(__webpack_require__(21173), exports);
tslib_1.__exportStar(__webpack_require__(2161), exports);
tslib_1.__exportStar(__webpack_require__(4441), exports);
tslib_1.__exportStar(__webpack_require__(25520), exports);
tslib_1.__exportStar(__webpack_require__(40409), exports);
tslib_1.__exportStar(__webpack_require__(45437), exports);
tslib_1.__exportStar(__webpack_require__(52147), exports);
tslib_1.__exportStar(__webpack_require__(22940), exports);
tslib_1.__exportStar(__webpack_require__(56467), exports);


/***/ }),

/***/ 37157:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 14121:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 2198:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 57740:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 32586:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 39282:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 74684:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 85329:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 50682:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 74838:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 21173:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 2161:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 4441:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 25520:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.RequestHandlerProtocol = void 0;
var RequestHandlerProtocol;
(function(RequestHandlerProtocol) {
    RequestHandlerProtocol["HTTP_0_9"] = "http/0.9";
    RequestHandlerProtocol["HTTP_1_0"] = "http/1.0";
    RequestHandlerProtocol["TDS_8_0"] = "tds/8.0";
})(RequestHandlerProtocol = exports.RequestHandlerProtocol || (exports.RequestHandlerProtocol = {}));


/***/ }),

/***/ 40409:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 45437:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 52147:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 22940:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 56467:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 45110:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.parseUrl = void 0;
const querystring_parser_1 = __webpack_require__(66639);
const parseUrl = (url)=>{
    if (typeof url === "string") {
        return (0, exports.parseUrl)(new URL(url));
    }
    const { hostname, pathname, port, protocol, search } = url;
    let query;
    if (search) {
        query = (0, querystring_parser_1.parseQueryString)(search);
    }
    return {
        hostname,
        port: port ? parseInt(port) : undefined,
        protocol,
        path: pathname,
        query
    };
};
exports.parseUrl = parseUrl;


/***/ }),

/***/ 87409:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromBase64 = void 0;
const util_buffer_from_1 = __webpack_require__(72813);
const BASE64_REGEX = /^[A-Za-z0-9+/]*={0,2}$/;
const fromBase64 = (input)=>{
    if (input.length * 3 % 4 !== 0) {
        throw new TypeError(`Incorrect padding on base64 string.`);
    }
    if (!BASE64_REGEX.exec(input)) {
        throw new TypeError(`Invalid base64 string.`);
    }
    const buffer = (0, util_buffer_from_1.fromString)(input, "base64");
    return new Uint8Array(buffer.buffer, buffer.byteOffset, buffer.byteLength);
};
exports.fromBase64 = fromBase64;


/***/ }),

/***/ 53013:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(87409), exports);
tslib_1.__exportStar(__webpack_require__(23266), exports);


/***/ }),

/***/ 23266:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.toBase64 = void 0;
const util_buffer_from_1 = __webpack_require__(72813);
const toBase64 = (input)=>(0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("base64");
exports.toBase64 = toBase64;


/***/ }),

/***/ 10156:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.calculateBodyLength = void 0;
const fs_1 = __webpack_require__(57147);
const calculateBodyLength = (body)=>{
    if (!body) {
        return 0;
    }
    if (typeof body === "string") {
        return Buffer.from(body).length;
    } else if (typeof body.byteLength === "number") {
        return body.byteLength;
    } else if (typeof body.size === "number") {
        return body.size;
    } else if (typeof body.start === "number" && typeof body.end === "number") {
        return body.end + 1 - body.start;
    } else if (typeof body.path === "string" || Buffer.isBuffer(body.path)) {
        return (0, fs_1.lstatSync)(body.path).size;
    } else if (typeof body.fd === "number") {
        return (0, fs_1.fstatSync)(body.fd).size;
    }
    throw new Error(`Body Length computation failed for ${body}`);
};
exports.calculateBodyLength = calculateBodyLength;


/***/ }),

/***/ 2414:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(10156), exports);


/***/ }),

/***/ 72813:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromString = exports.fromArrayBuffer = void 0;
const is_array_buffer_1 = __webpack_require__(63530);
const buffer_1 = __webpack_require__(14300);
const fromArrayBuffer = (input, offset = 0, length = input.byteLength - offset)=>{
    if (!(0, is_array_buffer_1.isArrayBuffer)(input)) {
        throw new TypeError(`The "input" argument must be ArrayBuffer. Received type ${typeof input} (${input})`);
    }
    return buffer_1.Buffer.from(input, offset, length);
};
exports.fromArrayBuffer = fromArrayBuffer;
const fromString = (input, encoding)=>{
    if (typeof input !== "string") {
        throw new TypeError(`The "input" argument must be of type string. Received type ${typeof input} (${input})`);
    }
    return encoding ? buffer_1.Buffer.from(input, encoding) : buffer_1.Buffer.from(input);
};
exports.fromString = fromString;


/***/ }),

/***/ 75797:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.booleanSelector = exports.SelectorType = void 0;
var SelectorType;
(function(SelectorType) {
    SelectorType["ENV"] = "env";
    SelectorType["CONFIG"] = "shared config entry";
})(SelectorType = exports.SelectorType || (exports.SelectorType = {}));
const booleanSelector = (obj, key, type)=>{
    if (!(key in obj)) return undefined;
    if (obj[key] === "true") return true;
    if (obj[key] === "false") return false;
    throw new Error(`Cannot load ${type} "${key}". Expected "true" or "false", got ${obj[key]}.`);
};
exports.booleanSelector = booleanSelector;


/***/ }),

/***/ 71543:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(75797), exports);


/***/ }),

/***/ 21459:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.IMDS_REGION_PATH = exports.DEFAULTS_MODE_OPTIONS = exports.ENV_IMDS_DISABLED = exports.AWS_DEFAULT_REGION_ENV = exports.AWS_REGION_ENV = exports.AWS_EXECUTION_ENV = void 0;
exports.AWS_EXECUTION_ENV = "AWS_EXECUTION_ENV";
exports.AWS_REGION_ENV = "AWS_REGION";
exports.AWS_DEFAULT_REGION_ENV = "AWS_DEFAULT_REGION";
exports.ENV_IMDS_DISABLED = "AWS_EC2_METADATA_DISABLED";
exports.DEFAULTS_MODE_OPTIONS = [
    "in-region",
    "cross-region",
    "mobile",
    "standard",
    "legacy"
];
exports.IMDS_REGION_PATH = "/latest/meta-data/placement/region";


/***/ }),

/***/ 65038:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.NODE_DEFAULTS_MODE_CONFIG_OPTIONS = void 0;
const AWS_DEFAULTS_MODE_ENV = "AWS_DEFAULTS_MODE";
const AWS_DEFAULTS_MODE_CONFIG = "defaults_mode";
exports.NODE_DEFAULTS_MODE_CONFIG_OPTIONS = {
    environmentVariableSelector: (env)=>{
        return env[AWS_DEFAULTS_MODE_ENV];
    },
    configFileSelector: (profile)=>{
        return profile[AWS_DEFAULTS_MODE_CONFIG];
    },
    default: "legacy"
};


/***/ }),

/***/ 87393:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(75197), exports);


/***/ }),

/***/ 75197:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.resolveDefaultsModeConfig = void 0;
const config_resolver_1 = __webpack_require__(25708);
const credential_provider_imds_1 = __webpack_require__(72214);
const node_config_provider_1 = __webpack_require__(15829);
const property_provider_1 = __webpack_require__(29852);
const constants_1 = __webpack_require__(21459);
const defaultsModeConfig_1 = __webpack_require__(65038);
const resolveDefaultsModeConfig = ({ region = (0, node_config_provider_1.loadConfig)(config_resolver_1.NODE_REGION_CONFIG_OPTIONS), defaultsMode = (0, node_config_provider_1.loadConfig)(defaultsModeConfig_1.NODE_DEFAULTS_MODE_CONFIG_OPTIONS) } = {})=>(0, property_provider_1.memoize)(async ()=>{
        const mode = typeof defaultsMode === "function" ? await defaultsMode() : defaultsMode;
        switch(mode === null || mode === void 0 ? void 0 : mode.toLowerCase()){
            case "auto":
                return resolveNodeDefaultsModeAuto(region);
            case "in-region":
            case "cross-region":
            case "mobile":
            case "standard":
            case "legacy":
                return Promise.resolve(mode === null || mode === void 0 ? void 0 : mode.toLocaleLowerCase());
            case undefined:
                return Promise.resolve("legacy");
            default:
                throw new Error(`Invalid parameter for "defaultsMode", expect ${constants_1.DEFAULTS_MODE_OPTIONS.join(", ")}, got ${mode}`);
        }
    });
exports.resolveDefaultsModeConfig = resolveDefaultsModeConfig;
const resolveNodeDefaultsModeAuto = async (clientRegion)=>{
    if (clientRegion) {
        const resolvedRegion = typeof clientRegion === "function" ? await clientRegion() : clientRegion;
        const inferredRegion = await inferPhysicalRegion();
        if (!inferredRegion) {
            return "standard";
        }
        if (resolvedRegion === inferredRegion) {
            return "in-region";
        } else {
            return "cross-region";
        }
    }
    return "standard";
};
const inferPhysicalRegion = async ()=>{
    var _a;
    if (process.env[constants_1.AWS_EXECUTION_ENV] && (process.env[constants_1.AWS_REGION_ENV] || process.env[constants_1.AWS_DEFAULT_REGION_ENV])) {
        return (_a = process.env[constants_1.AWS_REGION_ENV]) !== null && _a !== void 0 ? _a : process.env[constants_1.AWS_DEFAULT_REGION_ENV];
    }
    if (!process.env[constants_1.ENV_IMDS_DISABLED]) {
        try {
            const endpoint = await (0, credential_provider_imds_1.getInstanceMetadataEndpoint)();
            return (await (0, credential_provider_imds_1.httpRequest)({
                ...endpoint,
                path: constants_1.IMDS_REGION_PATH
            })).toString();
        } catch (e) {}
    }
};


/***/ }),

/***/ 7214:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.toHex = exports.fromHex = void 0;
const SHORT_TO_HEX = {};
const HEX_TO_SHORT = {};
for(let i = 0; i < 256; i++){
    let encodedByte = i.toString(16).toLowerCase();
    if (encodedByte.length === 1) {
        encodedByte = `0${encodedByte}`;
    }
    SHORT_TO_HEX[i] = encodedByte;
    HEX_TO_SHORT[encodedByte] = i;
}
function fromHex(encoded) {
    if (encoded.length % 2 !== 0) {
        throw new Error("Hex encoded strings must have an even number length");
    }
    const out = new Uint8Array(encoded.length / 2);
    for(let i = 0; i < encoded.length; i += 2){
        const encodedByte = encoded.slice(i, i + 2).toLowerCase();
        if (encodedByte in HEX_TO_SHORT) {
            out[i / 2] = HEX_TO_SHORT[encodedByte];
        } else {
            throw new Error(`Cannot decode unrecognized sequence ${encodedByte} as hexadecimal`);
        }
    }
    return out;
}
exports.fromHex = fromHex;
function toHex(bytes) {
    let out = "";
    for(let i = 0; i < bytes.byteLength; i++){
        out += SHORT_TO_HEX[bytes[i]];
    }
    return out;
}
exports.toHex = toHex;


/***/ }),

/***/ 5837:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(20378), exports);


/***/ }),

/***/ 20378:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.normalizeProvider = void 0;
const normalizeProvider = (input)=>{
    if (typeof input === "function") return input;
    const promisified = Promise.resolve(input);
    return ()=>promisified;
};
exports.normalizeProvider = normalizeProvider;


/***/ }),

/***/ 2751:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AdaptiveRetryStrategy = void 0;
const config_1 = __webpack_require__(68251);
const DefaultRateLimiter_1 = __webpack_require__(36350);
const StandardRetryStrategy_1 = __webpack_require__(75300);
class AdaptiveRetryStrategy {
    constructor(maxAttemptsProvider, options){
        this.maxAttemptsProvider = maxAttemptsProvider;
        this.mode = config_1.RETRY_MODES.ADAPTIVE;
        const { rateLimiter } = options !== null && options !== void 0 ? options : {};
        this.rateLimiter = rateLimiter !== null && rateLimiter !== void 0 ? rateLimiter : new DefaultRateLimiter_1.DefaultRateLimiter();
        this.standardRetryStrategy = new StandardRetryStrategy_1.StandardRetryStrategy(maxAttemptsProvider);
    }
    async acquireInitialRetryToken(retryTokenScope) {
        await this.rateLimiter.getSendToken();
        return this.standardRetryStrategy.acquireInitialRetryToken(retryTokenScope);
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        this.rateLimiter.updateClientSendingRate(errorInfo);
        return this.standardRetryStrategy.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
    }
    recordSuccess(token) {
        this.rateLimiter.updateClientSendingRate({});
        this.standardRetryStrategy.recordSuccess(token);
    }
}
exports.AdaptiveRetryStrategy = AdaptiveRetryStrategy;


/***/ }),

/***/ 77255:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.ConfiguredRetryStrategy = void 0;
const constants_1 = __webpack_require__(23437);
const StandardRetryStrategy_1 = __webpack_require__(75300);
class ConfiguredRetryStrategy extends StandardRetryStrategy_1.StandardRetryStrategy {
    constructor(maxAttempts, computeNextBackoffDelay = constants_1.DEFAULT_RETRY_DELAY_BASE){
        super(typeof maxAttempts === "function" ? maxAttempts : async ()=>maxAttempts);
        if (typeof computeNextBackoffDelay === "number") {
            this.computeNextBackoffDelay = ()=>computeNextBackoffDelay;
        } else {
            this.computeNextBackoffDelay = computeNextBackoffDelay;
        }
    }
    async refreshRetryTokenForRetry(tokenToRenew, errorInfo) {
        const token = await super.refreshRetryTokenForRetry(tokenToRenew, errorInfo);
        token.getRetryDelay = ()=>this.computeNextBackoffDelay(token.getRetryCount());
        return token;
    }
}
exports.ConfiguredRetryStrategy = ConfiguredRetryStrategy;


/***/ }),

/***/ 36350:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DefaultRateLimiter = void 0;
const service_error_classification_1 = __webpack_require__(69121);
class DefaultRateLimiter {
    constructor(options){
        var _a, _b, _c, _d, _e;
        this.currentCapacity = 0;
        this.enabled = false;
        this.lastMaxRate = 0;
        this.measuredTxRate = 0;
        this.requestCount = 0;
        this.lastTimestamp = 0;
        this.timeWindow = 0;
        this.beta = (_a = options === null || options === void 0 ? void 0 : options.beta) !== null && _a !== void 0 ? _a : 0.7;
        this.minCapacity = (_b = options === null || options === void 0 ? void 0 : options.minCapacity) !== null && _b !== void 0 ? _b : 1;
        this.minFillRate = (_c = options === null || options === void 0 ? void 0 : options.minFillRate) !== null && _c !== void 0 ? _c : 0.5;
        this.scaleConstant = (_d = options === null || options === void 0 ? void 0 : options.scaleConstant) !== null && _d !== void 0 ? _d : 0.4;
        this.smooth = (_e = options === null || options === void 0 ? void 0 : options.smooth) !== null && _e !== void 0 ? _e : 0.8;
        const currentTimeInSeconds = this.getCurrentTimeInSeconds();
        this.lastThrottleTime = currentTimeInSeconds;
        this.lastTxRateBucket = Math.floor(this.getCurrentTimeInSeconds());
        this.fillRate = this.minFillRate;
        this.maxCapacity = this.minCapacity;
    }
    getCurrentTimeInSeconds() {
        return Date.now() / 1000;
    }
    async getSendToken() {
        return this.acquireTokenBucket(1);
    }
    async acquireTokenBucket(amount) {
        if (!this.enabled) {
            return;
        }
        this.refillTokenBucket();
        if (amount > this.currentCapacity) {
            const delay = (amount - this.currentCapacity) / this.fillRate * 1000;
            await new Promise((resolve)=>setTimeout(resolve, delay));
        }
        this.currentCapacity = this.currentCapacity - amount;
    }
    refillTokenBucket() {
        const timestamp = this.getCurrentTimeInSeconds();
        if (!this.lastTimestamp) {
            this.lastTimestamp = timestamp;
            return;
        }
        const fillAmount = (timestamp - this.lastTimestamp) * this.fillRate;
        this.currentCapacity = Math.min(this.maxCapacity, this.currentCapacity + fillAmount);
        this.lastTimestamp = timestamp;
    }
    updateClientSendingRate(response) {
        let calculatedRate;
        this.updateMeasuredRate();
        if ((0, service_error_classification_1.isThrottlingError)(response)) {
            const rateToUse = !this.enabled ? this.measuredTxRate : Math.min(this.measuredTxRate, this.fillRate);
            this.lastMaxRate = rateToUse;
            this.calculateTimeWindow();
            this.lastThrottleTime = this.getCurrentTimeInSeconds();
            calculatedRate = this.cubicThrottle(rateToUse);
            this.enableTokenBucket();
        } else {
            this.calculateTimeWindow();
            calculatedRate = this.cubicSuccess(this.getCurrentTimeInSeconds());
        }
        const newRate = Math.min(calculatedRate, 2 * this.measuredTxRate);
        this.updateTokenBucketRate(newRate);
    }
    calculateTimeWindow() {
        this.timeWindow = this.getPrecise(Math.pow(this.lastMaxRate * (1 - this.beta) / this.scaleConstant, 1 / 3));
    }
    cubicThrottle(rateToUse) {
        return this.getPrecise(rateToUse * this.beta);
    }
    cubicSuccess(timestamp) {
        return this.getPrecise(this.scaleConstant * Math.pow(timestamp - this.lastThrottleTime - this.timeWindow, 3) + this.lastMaxRate);
    }
    enableTokenBucket() {
        this.enabled = true;
    }
    updateTokenBucketRate(newRate) {
        this.refillTokenBucket();
        this.fillRate = Math.max(newRate, this.minFillRate);
        this.maxCapacity = Math.max(newRate, this.minCapacity);
        this.currentCapacity = Math.min(this.currentCapacity, this.maxCapacity);
    }
    updateMeasuredRate() {
        const t = this.getCurrentTimeInSeconds();
        const timeBucket = Math.floor(t * 2) / 2;
        this.requestCount++;
        if (timeBucket > this.lastTxRateBucket) {
            const currentRate = this.requestCount / (timeBucket - this.lastTxRateBucket);
            this.measuredTxRate = this.getPrecise(currentRate * this.smooth + this.measuredTxRate * (1 - this.smooth));
            this.requestCount = 0;
            this.lastTxRateBucket = timeBucket;
        }
    }
    getPrecise(num) {
        return parseFloat(num.toFixed(8));
    }
}
exports.DefaultRateLimiter = DefaultRateLimiter;


/***/ }),

/***/ 75300:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.StandardRetryStrategy = void 0;
const config_1 = __webpack_require__(68251);
const constants_1 = __webpack_require__(23437);
const defaultRetryBackoffStrategy_1 = __webpack_require__(27597);
const defaultRetryToken_1 = __webpack_require__(75428);
class StandardRetryStrategy {
    constructor(maxAttempts){
        this.maxAttempts = maxAttempts;
        this.mode = config_1.RETRY_MODES.STANDARD;
        this.capacity = constants_1.INITIAL_RETRY_TOKENS;
        this.retryBackoffStrategy = (0, defaultRetryBackoffStrategy_1.getDefaultRetryBackoffStrategy)();
        this.maxAttemptsProvider = typeof maxAttempts === "function" ? maxAttempts : async ()=>maxAttempts;
    }
    async acquireInitialRetryToken(retryTokenScope) {
        return (0, defaultRetryToken_1.createDefaultRetryToken)({
            retryDelay: constants_1.DEFAULT_RETRY_DELAY_BASE,
            retryCount: 0
        });
    }
    async refreshRetryTokenForRetry(token, errorInfo) {
        const maxAttempts = await this.getMaxAttempts();
        if (this.shouldRetry(token, errorInfo, maxAttempts)) {
            const errorType = errorInfo.errorType;
            this.retryBackoffStrategy.setDelayBase(errorType === "THROTTLING" ? constants_1.THROTTLING_RETRY_DELAY_BASE : constants_1.DEFAULT_RETRY_DELAY_BASE);
            const delayFromErrorType = this.retryBackoffStrategy.computeNextBackoffDelay(token.getRetryCount());
            const retryDelay = errorInfo.retryAfterHint ? Math.max(errorInfo.retryAfterHint.getTime() - Date.now() || 0, delayFromErrorType) : delayFromErrorType;
            const capacityCost = this.getCapacityCost(errorType);
            this.capacity -= capacityCost;
            return (0, defaultRetryToken_1.createDefaultRetryToken)({
                retryDelay,
                retryCount: token.getRetryCount() + 1,
                retryCost: capacityCost
            });
        }
        throw new Error("No retry token available");
    }
    recordSuccess(token) {
        var _a;
        this.capacity = Math.max(constants_1.INITIAL_RETRY_TOKENS, this.capacity + ((_a = token.getRetryCost()) !== null && _a !== void 0 ? _a : constants_1.NO_RETRY_INCREMENT));
    }
    getCapacity() {
        return this.capacity;
    }
    async getMaxAttempts() {
        try {
            return await this.maxAttemptsProvider();
        } catch (error) {
            console.warn(`Max attempts provider could not resolve. Using default of ${config_1.DEFAULT_MAX_ATTEMPTS}`);
            return config_1.DEFAULT_MAX_ATTEMPTS;
        }
    }
    shouldRetry(tokenToRenew, errorInfo, maxAttempts) {
        const attempts = tokenToRenew.getRetryCount() + 1;
        return attempts < maxAttempts && this.capacity >= this.getCapacityCost(errorInfo.errorType) && this.isRetryableError(errorInfo.errorType);
    }
    getCapacityCost(errorType) {
        return errorType === "TRANSIENT" ? constants_1.TIMEOUT_RETRY_COST : constants_1.RETRY_COST;
    }
    isRetryableError(errorType) {
        return errorType === "THROTTLING" || errorType === "TRANSIENT";
    }
}
exports.StandardRetryStrategy = StandardRetryStrategy;


/***/ }),

/***/ 68251:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.DEFAULT_RETRY_MODE = exports.DEFAULT_MAX_ATTEMPTS = exports.RETRY_MODES = void 0;
var RETRY_MODES;
(function(RETRY_MODES) {
    RETRY_MODES["STANDARD"] = "standard";
    RETRY_MODES["ADAPTIVE"] = "adaptive";
})(RETRY_MODES = exports.RETRY_MODES || (exports.RETRY_MODES = {}));
exports.DEFAULT_MAX_ATTEMPTS = 3;
exports.DEFAULT_RETRY_MODE = RETRY_MODES.STANDARD;


/***/ }),

/***/ 23437:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.REQUEST_HEADER = exports.INVOCATION_ID_HEADER = exports.NO_RETRY_INCREMENT = exports.TIMEOUT_RETRY_COST = exports.RETRY_COST = exports.INITIAL_RETRY_TOKENS = exports.THROTTLING_RETRY_DELAY_BASE = exports.MAXIMUM_RETRY_DELAY = exports.DEFAULT_RETRY_DELAY_BASE = void 0;
exports.DEFAULT_RETRY_DELAY_BASE = 100;
exports.MAXIMUM_RETRY_DELAY = 20 * 1000;
exports.THROTTLING_RETRY_DELAY_BASE = 500;
exports.INITIAL_RETRY_TOKENS = 500;
exports.RETRY_COST = 5;
exports.TIMEOUT_RETRY_COST = 10;
exports.NO_RETRY_INCREMENT = 1;
exports.INVOCATION_ID_HEADER = "amz-sdk-invocation-id";
exports.REQUEST_HEADER = "amz-sdk-request";


/***/ }),

/***/ 27597:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getDefaultRetryBackoffStrategy = void 0;
const constants_1 = __webpack_require__(23437);
const getDefaultRetryBackoffStrategy = ()=>{
    let delayBase = constants_1.DEFAULT_RETRY_DELAY_BASE;
    const computeNextBackoffDelay = (attempts)=>{
        return Math.floor(Math.min(constants_1.MAXIMUM_RETRY_DELAY, Math.random() * 2 ** attempts * delayBase));
    };
    const setDelayBase = (delay)=>{
        delayBase = delay;
    };
    return {
        computeNextBackoffDelay,
        setDelayBase
    };
};
exports.getDefaultRetryBackoffStrategy = getDefaultRetryBackoffStrategy;


/***/ }),

/***/ 75428:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createDefaultRetryToken = void 0;
const constants_1 = __webpack_require__(23437);
const createDefaultRetryToken = ({ retryDelay, retryCount, retryCost })=>{
    const getRetryCount = ()=>retryCount;
    const getRetryDelay = ()=>Math.min(constants_1.MAXIMUM_RETRY_DELAY, retryDelay);
    const getRetryCost = ()=>retryCost;
    return {
        getRetryCount,
        getRetryDelay,
        getRetryCost
    };
};
exports.createDefaultRetryToken = createDefaultRetryToken;


/***/ }),

/***/ 7885:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(2751), exports);
tslib_1.__exportStar(__webpack_require__(77255), exports);
tslib_1.__exportStar(__webpack_require__(36350), exports);
tslib_1.__exportStar(__webpack_require__(75300), exports);
tslib_1.__exportStar(__webpack_require__(68251), exports);
tslib_1.__exportStar(__webpack_require__(23437), exports);
tslib_1.__exportStar(__webpack_require__(39411), exports);


/***/ }),

/***/ 39411:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 3815:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.Uint8ArrayBlobAdapter = void 0;
const transforms_1 = __webpack_require__(1470);
class Uint8ArrayBlobAdapter extends Uint8Array {
    static fromString(source, encoding = "utf-8") {
        switch(typeof source){
            case "string":
                return (0, transforms_1.transformFromString)(source, encoding);
            default:
                throw new Error(`Unsupported conversion from ${typeof source} to Uint8ArrayBlobAdapter.`);
        }
    }
    static mutate(source) {
        Object.setPrototypeOf(source, Uint8ArrayBlobAdapter.prototype);
        return source;
    }
    transformToString(encoding = "utf-8") {
        return (0, transforms_1.transformToString)(this, encoding);
    }
}
exports.Uint8ArrayBlobAdapter = Uint8ArrayBlobAdapter;


/***/ }),

/***/ 1470:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.transformFromString = exports.transformToString = void 0;
const util_base64_1 = __webpack_require__(53013);
const util_utf8_1 = __webpack_require__(66120);
const Uint8ArrayBlobAdapter_1 = __webpack_require__(3815);
function transformToString(payload, encoding = "utf-8") {
    if (encoding === "base64") {
        return (0, util_base64_1.toBase64)(payload);
    }
    return (0, util_utf8_1.toUtf8)(payload);
}
exports.transformToString = transformToString;
function transformFromString(str, encoding) {
    if (encoding === "base64") {
        return Uint8ArrayBlobAdapter_1.Uint8ArrayBlobAdapter.mutate((0, util_base64_1.fromBase64)(str));
    }
    return Uint8ArrayBlobAdapter_1.Uint8ArrayBlobAdapter.mutate((0, util_utf8_1.fromUtf8)(str));
}
exports.transformFromString = transformFromString;


/***/ }),

/***/ 61170:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getAwsChunkedEncodingStream = void 0;
const stream_1 = __webpack_require__(12781);
const getAwsChunkedEncodingStream = (readableStream, options)=>{
    const { base64Encoder, bodyLengthChecker, checksumAlgorithmFn, checksumLocationName, streamHasher } = options;
    const checksumRequired = base64Encoder !== undefined && checksumAlgorithmFn !== undefined && checksumLocationName !== undefined && streamHasher !== undefined;
    const digest = checksumRequired ? streamHasher(checksumAlgorithmFn, readableStream) : undefined;
    const awsChunkedEncodingStream = new stream_1.Readable({
        read: ()=>{}
    });
    readableStream.on("data", (data)=>{
        const length = bodyLengthChecker(data) || 0;
        awsChunkedEncodingStream.push(`${length.toString(16)}\r\n`);
        awsChunkedEncodingStream.push(data);
        awsChunkedEncodingStream.push("\r\n");
    });
    readableStream.on("end", async ()=>{
        awsChunkedEncodingStream.push(`0\r\n`);
        if (checksumRequired) {
            const checksum = base64Encoder(await digest);
            awsChunkedEncodingStream.push(`${checksumLocationName}:${checksum}\r\n`);
            awsChunkedEncodingStream.push(`\r\n`);
        }
        awsChunkedEncodingStream.push(null);
    });
    return awsChunkedEncodingStream;
};
exports.getAwsChunkedEncodingStream = getAwsChunkedEncodingStream;


/***/ }),

/***/ 70260:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(3815), exports);
tslib_1.__exportStar(__webpack_require__(61170), exports);
tslib_1.__exportStar(__webpack_require__(94212), exports);


/***/ }),

/***/ 94212:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.sdkStreamMixin = void 0;
const node_http_handler_1 = __webpack_require__(44025);
const util_buffer_from_1 = __webpack_require__(72813);
const stream_1 = __webpack_require__(12781);
const util_1 = __webpack_require__(73837);
const ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED = "The stream has already been transformed.";
const sdkStreamMixin = (stream)=>{
    var _a, _b;
    if (!(stream instanceof stream_1.Readable)) {
        const name = ((_b = (_a = stream === null || stream === void 0 ? void 0 : stream.__proto__) === null || _a === void 0 ? void 0 : _a.constructor) === null || _b === void 0 ? void 0 : _b.name) || stream;
        throw new Error(`Unexpected stream implementation, expect Stream.Readable instance, got ${name}`);
    }
    let transformed = false;
    const transformToByteArray = async ()=>{
        if (transformed) {
            throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
        }
        transformed = true;
        return await (0, node_http_handler_1.streamCollector)(stream);
    };
    return Object.assign(stream, {
        transformToByteArray,
        transformToString: async (encoding)=>{
            const buf = await transformToByteArray();
            if (encoding === undefined || Buffer.isEncoding(encoding)) {
                return (0, util_buffer_from_1.fromArrayBuffer)(buf.buffer, buf.byteOffset, buf.byteLength).toString(encoding);
            } else {
                const decoder = new util_1.TextDecoder(encoding);
                return decoder.decode(buf);
            }
        },
        transformToWebStream: ()=>{
            if (transformed) {
                throw new Error(ERR_MSG_STREAM_HAS_BEEN_TRANSFORMED);
            }
            if (stream.readableFlowing !== null) {
                throw new Error("The stream has been consumed by other callbacks.");
            }
            if (typeof stream_1.Readable.toWeb !== "function") {
                throw new Error("Readable.toWeb() is not supported. Please make sure you are using Node.js >= 17.0.0, or polyfill is available.");
            }
            transformed = true;
            return stream_1.Readable.toWeb(stream);
        }
    });
};
exports.sdkStreamMixin = sdkStreamMixin;


/***/ }),

/***/ 23490:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.escapeUriPath = void 0;
const escape_uri_1 = __webpack_require__(12447);
const escapeUriPath = (uri)=>uri.split("/").map(escape_uri_1.escapeUri).join("/");
exports.escapeUriPath = escapeUriPath;


/***/ }),

/***/ 12447:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.escapeUri = void 0;
const escapeUri = (uri)=>encodeURIComponent(uri).replace(/[!'()*]/g, hexEncode);
exports.escapeUri = escapeUri;
const hexEncode = (c)=>`%${c.charCodeAt(0).toString(16).toUpperCase()}`;


/***/ }),

/***/ 49731:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(12447), exports);
tslib_1.__exportStar(__webpack_require__(23490), exports);


/***/ }),

/***/ 34209:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.fromUtf8 = void 0;
const util_buffer_from_1 = __webpack_require__(72813);
const fromUtf8 = (input)=>{
    const buf = (0, util_buffer_from_1.fromString)(input, "utf8");
    return new Uint8Array(buf.buffer, buf.byteOffset, buf.byteLength / Uint8Array.BYTES_PER_ELEMENT);
};
exports.fromUtf8 = fromUtf8;


/***/ }),

/***/ 66120:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
const tslib_1 = __webpack_require__(35092);
tslib_1.__exportStar(__webpack_require__(34209), exports);
tslib_1.__exportStar(__webpack_require__(92636), exports);
tslib_1.__exportStar(__webpack_require__(49320), exports);


/***/ }),

/***/ 92636:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.toUint8Array = void 0;
const fromUtf8_1 = __webpack_require__(34209);
const toUint8Array = (data)=>{
    if (typeof data === "string") {
        return (0, fromUtf8_1.fromUtf8)(data);
    }
    if (ArrayBuffer.isView(data)) {
        return new Uint8Array(data.buffer, data.byteOffset, data.byteLength / Uint8Array.BYTES_PER_ELEMENT);
    }
    return new Uint8Array(data);
};
exports.toUint8Array = toUint8Array;


/***/ }),

/***/ 49320:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.toUtf8 = void 0;
const util_buffer_from_1 = __webpack_require__(72813);
const toUtf8 = (input)=>(0, util_buffer_from_1.fromArrayBuffer)(input.buffer, input.byteOffset, input.byteLength).toString("utf8");
exports.toUtf8 = toUtf8;


/***/ }),

/***/ 73078:
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

"use strict";
// ESM COMPAT FLAG
__webpack_require__.r(__webpack_exports__);

// EXPORTS
__webpack_require__.d(__webpack_exports__, {
  NIL: () => (/* reexport */ nil),
  parse: () => (/* reexport */ esm_node_parse),
  stringify: () => (/* reexport */ esm_node_stringify),
  v1: () => (/* reexport */ esm_node_v1),
  v3: () => (/* reexport */ esm_node_v3),
  v4: () => (/* reexport */ esm_node_v4),
  v5: () => (/* reexport */ esm_node_v5),
  validate: () => (/* reexport */ esm_node_validate),
  version: () => (/* reexport */ esm_node_version)
});

// EXTERNAL MODULE: external "crypto"
var external_crypto_ = __webpack_require__(6113);
var external_crypto_default = /*#__PURE__*/__webpack_require__.n(external_crypto_);
;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-cognito-identity-provider/node_modules/uuid/dist/esm-node/rng.js

const rnds8Pool = new Uint8Array(256); // # of random values to pre-allocate
let poolPtr = rnds8Pool.length;
function rng() {
    if (poolPtr > rnds8Pool.length - 16) {
        external_crypto_default().randomFillSync(rnds8Pool);
        poolPtr = 0;
    }
    return rnds8Pool.slice(poolPtr, poolPtr += 16);
}

;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-cognito-identity-provider/node_modules/uuid/dist/esm-node/regex.js
/* harmony default export */ const regex = (/^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i);

;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-cognito-identity-provider/node_modules/uuid/dist/esm-node/validate.js

function validate(uuid) {
    return typeof uuid === "string" && regex.test(uuid);
}
/* harmony default export */ const esm_node_validate = (validate);

;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-cognito-identity-provider/node_modules/uuid/dist/esm-node/stringify.js

/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */ const byteToHex = [];
for(let i = 0; i < 256; ++i){
    byteToHex.push((i + 0x100).toString(16).substr(1));
}
function stringify(arr, offset = 0) {
    // Note: Be careful editing this code!  It's been tuned for performance
    // and works in ways you may not expect. See https://github.com/uuidjs/uuid/pull/434
    const uuid = (byteToHex[arr[offset + 0]] + byteToHex[arr[offset + 1]] + byteToHex[arr[offset + 2]] + byteToHex[arr[offset + 3]] + "-" + byteToHex[arr[offset + 4]] + byteToHex[arr[offset + 5]] + "-" + byteToHex[arr[offset + 6]] + byteToHex[arr[offset + 7]] + "-" + byteToHex[arr[offset + 8]] + byteToHex[arr[offset + 9]] + "-" + byteToHex[arr[offset + 10]] + byteToHex[arr[offset + 11]] + byteToHex[arr[offset + 12]] + byteToHex[arr[offset + 13]] + byteToHex[arr[offset + 14]] + byteToHex[arr[offset + 15]]).toLowerCase(); // Consistency check for valid UUID.  If this throws, it's likely due to one
    // of the following:
    // - One or more input array values don't map to a hex octet (leading to
    // "undefined" in the uuid)
    // - Invalid input values for the RFC `version` or `variant` fields
    if (!esm_node_validate(uuid)) {
        throw TypeError("Stringified UUID is invalid");
    }
    return uuid;
}
/* harmony default export */ const esm_node_stringify = (stringify);

;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-cognito-identity-provider/node_modules/uuid/dist/esm-node/v1.js

 // **`v1()` - Generate time-based UUID**
//
// Inspired by https://github.com/LiosK/UUID.js
// and http://docs.python.org/library/uuid.html
let _nodeId;
let _clockseq; // Previous uuid creation time
let _lastMSecs = 0;
let _lastNSecs = 0; // See https://github.com/uuidjs/uuid for API details
function v1(options, buf, offset) {
    let i = buf && offset || 0;
    const b = buf || new Array(16);
    options = options || {};
    let node = options.node || _nodeId;
    let clockseq = options.clockseq !== undefined ? options.clockseq : _clockseq; // node and clockseq need to be initialized to random values if they're not
    // specified.  We do this lazily to minimize issues related to insufficient
    // system entropy.  See #189
    if (node == null || clockseq == null) {
        const seedBytes = options.random || (options.rng || rng)();
        if (node == null) {
            // Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
            node = _nodeId = [
                seedBytes[0] | 0x01,
                seedBytes[1],
                seedBytes[2],
                seedBytes[3],
                seedBytes[4],
                seedBytes[5]
            ];
        }
        if (clockseq == null) {
            // Per 4.2.2, randomize (14 bit) clockseq
            clockseq = _clockseq = (seedBytes[6] << 8 | seedBytes[7]) & 0x3fff;
        }
    } // UUID timestamps are 100 nano-second units since the Gregorian epoch,
    // (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
    // time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
    // (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
    let msecs = options.msecs !== undefined ? options.msecs : Date.now(); // Per 4.2.1.2, use count of uuid's generated during the current clock
    // cycle to simulate higher resolution clock
    let nsecs = options.nsecs !== undefined ? options.nsecs : _lastNSecs + 1; // Time since last uuid creation (in msecs)
    const dt = msecs - _lastMSecs + (nsecs - _lastNSecs) / 10000; // Per 4.2.1.2, Bump clockseq on clock regression
    if (dt < 0 && options.clockseq === undefined) {
        clockseq = clockseq + 1 & 0x3fff;
    } // Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
    // time interval
    if ((dt < 0 || msecs > _lastMSecs) && options.nsecs === undefined) {
        nsecs = 0;
    } // Per 4.2.1.2 Throw error if too many uuids are requested
    if (nsecs >= 10000) {
        throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");
    }
    _lastMSecs = msecs;
    _lastNSecs = nsecs;
    _clockseq = clockseq; // Per 4.1.4 - Convert from unix epoch to Gregorian epoch
    msecs += 12219292800000; // `time_low`
    const tl = ((msecs & 0xfffffff) * 10000 + nsecs) % 0x100000000;
    b[i++] = tl >>> 24 & 0xff;
    b[i++] = tl >>> 16 & 0xff;
    b[i++] = tl >>> 8 & 0xff;
    b[i++] = tl & 0xff; // `time_mid`
    const tmh = msecs / 0x100000000 * 10000 & 0xfffffff;
    b[i++] = tmh >>> 8 & 0xff;
    b[i++] = tmh & 0xff; // `time_high_and_version`
    b[i++] = tmh >>> 24 & 0xf | 0x10; // include version
    b[i++] = tmh >>> 16 & 0xff; // `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
    b[i++] = clockseq >>> 8 | 0x80; // `clock_seq_low`
    b[i++] = clockseq & 0xff; // `node`
    for(let n = 0; n < 6; ++n){
        b[i + n] = node[n];
    }
    return buf || esm_node_stringify(b);
}
/* harmony default export */ const esm_node_v1 = (v1);

;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-cognito-identity-provider/node_modules/uuid/dist/esm-node/parse.js

function parse(uuid) {
    if (!esm_node_validate(uuid)) {
        throw TypeError("Invalid UUID");
    }
    let v;
    const arr = new Uint8Array(16); // Parse ########-....-....-....-............
    arr[0] = (v = parseInt(uuid.slice(0, 8), 16)) >>> 24;
    arr[1] = v >>> 16 & 0xff;
    arr[2] = v >>> 8 & 0xff;
    arr[3] = v & 0xff; // Parse ........-####-....-....-............
    arr[4] = (v = parseInt(uuid.slice(9, 13), 16)) >>> 8;
    arr[5] = v & 0xff; // Parse ........-....-####-....-............
    arr[6] = (v = parseInt(uuid.slice(14, 18), 16)) >>> 8;
    arr[7] = v & 0xff; // Parse ........-....-....-####-............
    arr[8] = (v = parseInt(uuid.slice(19, 23), 16)) >>> 8;
    arr[9] = v & 0xff; // Parse ........-....-....-....-############
    // (Use "/" to avoid 32-bit truncation when bit-shifting high-order bytes)
    arr[10] = (v = parseInt(uuid.slice(24, 36), 16)) / 0x10000000000 & 0xff;
    arr[11] = v / 0x100000000 & 0xff;
    arr[12] = v >>> 24 & 0xff;
    arr[13] = v >>> 16 & 0xff;
    arr[14] = v >>> 8 & 0xff;
    arr[15] = v & 0xff;
    return arr;
}
/* harmony default export */ const esm_node_parse = (parse);

;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-cognito-identity-provider/node_modules/uuid/dist/esm-node/v35.js


function stringToBytes(str) {
    str = unescape(encodeURIComponent(str)); // UTF8 escape
    const bytes = [];
    for(let i = 0; i < str.length; ++i){
        bytes.push(str.charCodeAt(i));
    }
    return bytes;
}
const DNS = "6ba7b810-9dad-11d1-80b4-00c04fd430c8";
const URL = "6ba7b811-9dad-11d1-80b4-00c04fd430c8";
/* harmony default export */ function v35(name, version, hashfunc) {
    function generateUUID(value, namespace, buf, offset) {
        if (typeof value === "string") {
            value = stringToBytes(value);
        }
        if (typeof namespace === "string") {
            namespace = esm_node_parse(namespace);
        }
        if (namespace.length !== 16) {
            throw TypeError("Namespace must be array-like (16 iterable integer values, 0-255)");
        } // Compute hash of namespace and value, Per 4.3
        // Future: Use spread syntax when supported on all platforms, e.g. `bytes =
        // hashfunc([...namespace, ... value])`
        let bytes = new Uint8Array(16 + value.length);
        bytes.set(namespace);
        bytes.set(value, namespace.length);
        bytes = hashfunc(bytes);
        bytes[6] = bytes[6] & 0x0f | version;
        bytes[8] = bytes[8] & 0x3f | 0x80;
        if (buf) {
            offset = offset || 0;
            for(let i = 0; i < 16; ++i){
                buf[offset + i] = bytes[i];
            }
            return buf;
        }
        return esm_node_stringify(bytes);
    } // Function#name is not settable on some platforms (#270)
    try {
        generateUUID.name = name; // eslint-disable-next-line no-empty
    } catch (err) {} // For CommonJS default export support
    generateUUID.DNS = DNS;
    generateUUID.URL = URL;
    return generateUUID;
}

;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-cognito-identity-provider/node_modules/uuid/dist/esm-node/md5.js

function md5(bytes) {
    if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
    }
    return external_crypto_default().createHash("md5").update(bytes).digest();
}
/* harmony default export */ const esm_node_md5 = (md5);

;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-cognito-identity-provider/node_modules/uuid/dist/esm-node/v3.js


const v3 = v35("v3", 0x30, esm_node_md5);
/* harmony default export */ const esm_node_v3 = (v3);

;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-cognito-identity-provider/node_modules/uuid/dist/esm-node/v4.js


function v4(options, buf, offset) {
    options = options || {};
    const rnds = options.random || (options.rng || rng)(); // Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
    rnds[6] = rnds[6] & 0x0f | 0x40;
    rnds[8] = rnds[8] & 0x3f | 0x80; // Copy bytes to buffer, if provided
    if (buf) {
        offset = offset || 0;
        for(let i = 0; i < 16; ++i){
            buf[offset + i] = rnds[i];
        }
        return buf;
    }
    return esm_node_stringify(rnds);
}
/* harmony default export */ const esm_node_v4 = (v4);

;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-cognito-identity-provider/node_modules/uuid/dist/esm-node/sha1.js

function sha1(bytes) {
    if (Array.isArray(bytes)) {
        bytes = Buffer.from(bytes);
    } else if (typeof bytes === "string") {
        bytes = Buffer.from(bytes, "utf8");
    }
    return external_crypto_default().createHash("sha1").update(bytes).digest();
}
/* harmony default export */ const esm_node_sha1 = (sha1);

;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-cognito-identity-provider/node_modules/uuid/dist/esm-node/v5.js


const v5 = v35("v5", 0x50, esm_node_sha1);
/* harmony default export */ const esm_node_v5 = (v5);

;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-cognito-identity-provider/node_modules/uuid/dist/esm-node/nil.js
/* harmony default export */ const nil = ("00000000-0000-0000-0000-000000000000");

;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-cognito-identity-provider/node_modules/uuid/dist/esm-node/version.js

function version(uuid) {
    if (!esm_node_validate(uuid)) {
        throw TypeError("Invalid UUID");
    }
    return parseInt(uuid.substr(14, 1), 16);
}
/* harmony default export */ const esm_node_version = (version);

;// CONCATENATED MODULE: ../../node_modules/@aws-sdk/client-cognito-identity-provider/node_modules/uuid/dist/esm-node/index.js











/***/ }),

/***/ 46381:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*jshint node:true */ 
var Buffer = (__webpack_require__(14300).Buffer); // browserify
var SlowBuffer = (__webpack_require__(14300).SlowBuffer);
module.exports = bufferEq;
function bufferEq(a, b) {
    // shortcutting on type is necessary for correctness
    if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
        return false;
    }
    // buffer sizes should be well-known information, so despite this
    // shortcutting, it doesn't leak any information about the *contents* of the
    // buffers.
    if (a.length !== b.length) {
        return false;
    }
    var c = 0;
    for(var i = 0; i < a.length; i++){
        /*jshint bitwise:false */ c |= a[i] ^ b[i]; // XOR
    }
    return c === 0;
}
bufferEq.install = function() {
    Buffer.prototype.equal = SlowBuffer.prototype.equal = function equal(that) {
        return bufferEq(this, that);
    };
};
var origBufEqual = Buffer.prototype.equal;
var origSlowBufEqual = SlowBuffer.prototype.equal;
bufferEq.restore = function() {
    Buffer.prototype.equal = origBufEqual;
    SlowBuffer.prototype.equal = origSlowBufEqual;
};


/***/ }),

/***/ 87445:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
/*!
 * cookie
 * Copyright(c) 2012-2014 Roman Shtylman
 * Copyright(c) 2015 Douglas Christopher Wilson
 * MIT Licensed
 */ 
/**
 * Module exports.
 * @public
 */ exports.parse = parse;
exports.serialize = serialize;
/**
 * Module variables.
 * @private
 */ var __toString = Object.prototype.toString;
/**
 * RegExp to match field-content in RFC 7230 sec 3.2
 *
 * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
 * field-vchar   = VCHAR / obs-text
 * obs-text      = %x80-FF
 */ var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;
/**
 * Parse a cookie header.
 *
 * Parse the given cookie header string into an object
 * The object has the various cookies as keys(names) => values
 *
 * @param {string} str
 * @param {object} [options]
 * @return {object}
 * @public
 */ function parse(str, options) {
    if (typeof str !== "string") {
        throw new TypeError("argument str must be a string");
    }
    var obj = {};
    var opt = options || {};
    var dec = opt.decode || decode;
    var index = 0;
    while(index < str.length){
        var eqIdx = str.indexOf("=", index);
        // no more cookie pairs
        if (eqIdx === -1) {
            break;
        }
        var endIdx = str.indexOf(";", index);
        if (endIdx === -1) {
            endIdx = str.length;
        } else if (endIdx < eqIdx) {
            // backtrack on prior semicolon
            index = str.lastIndexOf(";", eqIdx - 1) + 1;
            continue;
        }
        var key = str.slice(index, eqIdx).trim();
        // only assign once
        if (undefined === obj[key]) {
            var val = str.slice(eqIdx + 1, endIdx).trim();
            // quoted values
            if (val.charCodeAt(0) === 0x22) {
                val = val.slice(1, -1);
            }
            obj[key] = tryDecode(val, dec);
        }
        index = endIdx + 1;
    }
    return obj;
}
/**
 * Serialize data into a cookie header.
 *
 * Serialize the a name value pair into a cookie string suitable for
 * http headers. An optional options object specified cookie parameters.
 *
 * serialize('foo', 'bar', { httpOnly: true })
 *   => "foo=bar; httpOnly"
 *
 * @param {string} name
 * @param {string} val
 * @param {object} [options]
 * @return {string}
 * @public
 */ function serialize(name, val, options) {
    var opt = options || {};
    var enc = opt.encode || encode;
    if (typeof enc !== "function") {
        throw new TypeError("option encode is invalid");
    }
    if (!fieldContentRegExp.test(name)) {
        throw new TypeError("argument name is invalid");
    }
    var value = enc(val);
    if (value && !fieldContentRegExp.test(value)) {
        throw new TypeError("argument val is invalid");
    }
    var str = name + "=" + value;
    if (null != opt.maxAge) {
        var maxAge = opt.maxAge - 0;
        if (isNaN(maxAge) || !isFinite(maxAge)) {
            throw new TypeError("option maxAge is invalid");
        }
        str += "; Max-Age=" + Math.floor(maxAge);
    }
    if (opt.domain) {
        if (!fieldContentRegExp.test(opt.domain)) {
            throw new TypeError("option domain is invalid");
        }
        str += "; Domain=" + opt.domain;
    }
    if (opt.path) {
        if (!fieldContentRegExp.test(opt.path)) {
            throw new TypeError("option path is invalid");
        }
        str += "; Path=" + opt.path;
    }
    if (opt.expires) {
        var expires = opt.expires;
        if (!isDate(expires) || isNaN(expires.valueOf())) {
            throw new TypeError("option expires is invalid");
        }
        str += "; Expires=" + expires.toUTCString();
    }
    if (opt.httpOnly) {
        str += "; HttpOnly";
    }
    if (opt.secure) {
        str += "; Secure";
    }
    if (opt.priority) {
        var priority = typeof opt.priority === "string" ? opt.priority.toLowerCase() : opt.priority;
        switch(priority){
            case "low":
                str += "; Priority=Low";
                break;
            case "medium":
                str += "; Priority=Medium";
                break;
            case "high":
                str += "; Priority=High";
                break;
            default:
                throw new TypeError("option priority is invalid");
        }
    }
    if (opt.sameSite) {
        var sameSite = typeof opt.sameSite === "string" ? opt.sameSite.toLowerCase() : opt.sameSite;
        switch(sameSite){
            case true:
                str += "; SameSite=Strict";
                break;
            case "lax":
                str += "; SameSite=Lax";
                break;
            case "strict":
                str += "; SameSite=Strict";
                break;
            case "none":
                str += "; SameSite=None";
                break;
            default:
                throw new TypeError("option sameSite is invalid");
        }
    }
    return str;
}
/**
 * URL-decode string value. Optimized to skip native call when no %.
 *
 * @param {string} str
 * @returns {string}
 */ function decode(str) {
    return str.indexOf("%") !== -1 ? decodeURIComponent(str) : str;
}
/**
 * URL-encode value.
 *
 * @param {string} str
 * @returns {string}
 */ function encode(val) {
    return encodeURIComponent(val);
}
/**
 * Determine if value is a Date.
 *
 * @param {*} val
 * @private
 */ function isDate(val) {
    return __toString.call(val) === "[object Date]" || val instanceof Date;
}
/**
 * Try decoding a string using a decoding function.
 *
 * @param {string} str
 * @param {function} decode
 * @private
 */ function tryDecode(str, decode) {
    try {
        return decode(str);
    } catch (e) {
        return str;
    }
}


/***/ }),

/***/ 20661:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var Buffer = (__webpack_require__(49765).Buffer);
var getParamBytesForAlg = __webpack_require__(86131);
var MAX_OCTET = 0x80, CLASS_UNIVERSAL = 0, PRIMITIVE_BIT = 0x20, TAG_SEQ = 0x10, TAG_INT = 0x02, ENCODED_TAG_SEQ = TAG_SEQ | PRIMITIVE_BIT | CLASS_UNIVERSAL << 6, ENCODED_TAG_INT = TAG_INT | CLASS_UNIVERSAL << 6;
function base64Url(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function signatureAsBuffer(signature) {
    if (Buffer.isBuffer(signature)) {
        return signature;
    } else if ("string" === typeof signature) {
        return Buffer.from(signature, "base64");
    }
    throw new TypeError("ECDSA signature must be a Base64 string or a Buffer");
}
function derToJose(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    // the DER encoded param should at most be the param size, plus a padding
    // zero, since due to being a signed integer
    var maxEncodedParamLength = paramBytes + 1;
    var inputLength = signature.length;
    var offset = 0;
    if (signature[offset++] !== ENCODED_TAG_SEQ) {
        throw new Error('Could not find expected "seq"');
    }
    var seqLength = signature[offset++];
    if (seqLength === (MAX_OCTET | 1)) {
        seqLength = signature[offset++];
    }
    if (inputLength - offset < seqLength) {
        throw new Error('"seq" specified length of "' + seqLength + '", only "' + (inputLength - offset) + '" remaining');
    }
    if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "r"');
    }
    var rLength = signature[offset++];
    if (inputLength - offset - 2 < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", only "' + (inputLength - offset - 2) + '" available');
    }
    if (maxEncodedParamLength < rLength) {
        throw new Error('"r" specified length of "' + rLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var rOffset = offset;
    offset += rLength;
    if (signature[offset++] !== ENCODED_TAG_INT) {
        throw new Error('Could not find expected "int" for "s"');
    }
    var sLength = signature[offset++];
    if (inputLength - offset !== sLength) {
        throw new Error('"s" specified length of "' + sLength + '", expected "' + (inputLength - offset) + '"');
    }
    if (maxEncodedParamLength < sLength) {
        throw new Error('"s" specified length of "' + sLength + '", max of "' + maxEncodedParamLength + '" is acceptable');
    }
    var sOffset = offset;
    offset += sLength;
    if (offset !== inputLength) {
        throw new Error('Expected to consume entire buffer, but "' + (inputLength - offset) + '" bytes remain');
    }
    var rPadding = paramBytes - rLength, sPadding = paramBytes - sLength;
    var dst = Buffer.allocUnsafe(rPadding + rLength + sPadding + sLength);
    for(offset = 0; offset < rPadding; ++offset){
        dst[offset] = 0;
    }
    signature.copy(dst, offset, rOffset + Math.max(-rPadding, 0), rOffset + rLength);
    offset = paramBytes;
    for(var o = offset; offset < o + sPadding; ++offset){
        dst[offset] = 0;
    }
    signature.copy(dst, offset, sOffset + Math.max(-sPadding, 0), sOffset + sLength);
    dst = dst.toString("base64");
    dst = base64Url(dst);
    return dst;
}
function countPadding(buf, start, stop) {
    var padding = 0;
    while(start + padding < stop && buf[start + padding] === 0){
        ++padding;
    }
    var needsSign = buf[start + padding] >= MAX_OCTET;
    if (needsSign) {
        --padding;
    }
    return padding;
}
function joseToDer(signature, alg) {
    signature = signatureAsBuffer(signature);
    var paramBytes = getParamBytesForAlg(alg);
    var signatureBytes = signature.length;
    if (signatureBytes !== paramBytes * 2) {
        throw new TypeError('"' + alg + '" signatures must be "' + paramBytes * 2 + '" bytes, saw "' + signatureBytes + '"');
    }
    var rPadding = countPadding(signature, 0, paramBytes);
    var sPadding = countPadding(signature, paramBytes, signature.length);
    var rLength = paramBytes - rPadding;
    var sLength = paramBytes - sPadding;
    var rsBytes = 1 + 1 + rLength + 1 + 1 + sLength;
    var shortLength = rsBytes < MAX_OCTET;
    var dst = Buffer.allocUnsafe((shortLength ? 2 : 3) + rsBytes);
    var offset = 0;
    dst[offset++] = ENCODED_TAG_SEQ;
    if (shortLength) {
        // Bit 8 has value "0"
        // bits 7-1 give the length.
        dst[offset++] = rsBytes;
    } else {
        // Bit 8 of first octet has value "1"
        // bits 7-1 give the number of additional length octets.
        dst[offset++] = MAX_OCTET | 1;
        // length, base 256
        dst[offset++] = rsBytes & 0xff;
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = rLength;
    if (rPadding < 0) {
        dst[offset++] = 0;
        offset += signature.copy(dst, offset, 0, paramBytes);
    } else {
        offset += signature.copy(dst, offset, rPadding, paramBytes);
    }
    dst[offset++] = ENCODED_TAG_INT;
    dst[offset++] = sLength;
    if (sPadding < 0) {
        dst[offset++] = 0;
        signature.copy(dst, offset, paramBytes);
    } else {
        signature.copy(dst, offset, paramBytes + sPadding);
    }
    return dst;
}
module.exports = {
    derToJose: derToJose,
    joseToDer: joseToDer
};


/***/ }),

/***/ 86131:
/***/ ((module) => {

"use strict";

function getParamSize(keySize) {
    var result = (keySize / 8 | 0) + (keySize % 8 === 0 ? 0 : 1);
    return result;
}
var paramBytesForAlg = {
    ES256: getParamSize(256),
    ES384: getParamSize(384),
    ES512: getParamSize(521)
};
function getParamBytesForAlg(alg) {
    var paramBytes = paramBytesForAlg[alg];
    if (paramBytes) {
        return paramBytes;
    }
    throw new Error('Unknown algorithm "' + alg + '"');
}
module.exports = getParamBytesForAlg;


/***/ }),

/***/ 44985:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var jws = __webpack_require__(91750);
module.exports = function(jwt, options) {
    options = options || {};
    var decoded = jws.decode(jwt, options);
    if (!decoded) {
        return null;
    }
    var payload = decoded.payload;
    //try parse the payload
    if (typeof payload === "string") {
        try {
            var obj = JSON.parse(payload);
            if (obj !== null && typeof obj === "object") {
                payload = obj;
            }
        } catch (e) {}
    }
    //return header if `complete` option is enabled.  header includes claims
    //such as `kid` and `alg` used to select the key within a JWKS needed to
    //verify the signature
    if (options.complete === true) {
        return {
            header: decoded.header,
            payload: payload,
            signature: decoded.signature
        };
    }
    return payload;
};


/***/ }),

/***/ 78010:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = {
    decode: __webpack_require__(44985),
    verify: __webpack_require__(70496),
    sign: __webpack_require__(88855),
    JsonWebTokenError: __webpack_require__(40297),
    NotBeforeError: __webpack_require__(83008),
    TokenExpiredError: __webpack_require__(19000)
};


/***/ }),

/***/ 40297:
/***/ ((module) => {

"use strict";

var JsonWebTokenError = function(message, error) {
    Error.call(this, message);
    if (Error.captureStackTrace) {
        Error.captureStackTrace(this, this.constructor);
    }
    this.name = "JsonWebTokenError";
    this.message = message;
    if (error) this.inner = error;
};
JsonWebTokenError.prototype = Object.create(Error.prototype);
JsonWebTokenError.prototype.constructor = JsonWebTokenError;
module.exports = JsonWebTokenError;


/***/ }),

/***/ 83008:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var JsonWebTokenError = __webpack_require__(40297);
var NotBeforeError = function(message, date) {
    JsonWebTokenError.call(this, message);
    this.name = "NotBeforeError";
    this.date = date;
};
NotBeforeError.prototype = Object.create(JsonWebTokenError.prototype);
NotBeforeError.prototype.constructor = NotBeforeError;
module.exports = NotBeforeError;


/***/ }),

/***/ 19000:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var JsonWebTokenError = __webpack_require__(40297);
var TokenExpiredError = function(message, expiredAt) {
    JsonWebTokenError.call(this, message);
    this.name = "TokenExpiredError";
    this.expiredAt = expiredAt;
};
TokenExpiredError.prototype = Object.create(JsonWebTokenError.prototype);
TokenExpiredError.prototype.constructor = TokenExpiredError;
module.exports = TokenExpiredError;


/***/ }),

/***/ 53459:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const semver = __webpack_require__(7045);
module.exports = semver.satisfies(process.version, ">=15.7.0");


/***/ }),

/***/ 65906:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var semver = __webpack_require__(7045);
module.exports = semver.satisfies(process.version, "^6.12.0 || >=8.0.0");


/***/ }),

/***/ 85236:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const semver = __webpack_require__(7045);
module.exports = semver.satisfies(process.version, ">=16.9.0");


/***/ }),

/***/ 60130:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var ms = __webpack_require__(95063);
module.exports = function(time, iat) {
    var timestamp = iat || Math.floor(Date.now() / 1000);
    if (typeof time === "string") {
        var milliseconds = ms(time);
        if (typeof milliseconds === "undefined") {
            return;
        }
        return Math.floor(timestamp + milliseconds / 1000);
    } else if (typeof time === "number") {
        return timestamp + time;
    } else {
        return;
    }
};


/***/ }),

/***/ 19740:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ASYMMETRIC_KEY_DETAILS_SUPPORTED = __webpack_require__(53459);
const RSA_PSS_KEY_DETAILS_SUPPORTED = __webpack_require__(85236);
const allowedAlgorithmsForKeys = {
    "ec": [
        "ES256",
        "ES384",
        "ES512"
    ],
    "rsa": [
        "RS256",
        "PS256",
        "RS384",
        "PS384",
        "RS512",
        "PS512"
    ],
    "rsa-pss": [
        "PS256",
        "PS384",
        "PS512"
    ]
};
const allowedCurves = {
    ES256: "prime256v1",
    ES384: "secp384r1",
    ES512: "secp521r1"
};
module.exports = function(algorithm, key) {
    if (!algorithm || !key) return;
    const keyType = key.asymmetricKeyType;
    if (!keyType) return;
    const allowedAlgorithms = allowedAlgorithmsForKeys[keyType];
    if (!allowedAlgorithms) {
        throw new Error(`Unknown key type "${keyType}".`);
    }
    if (!allowedAlgorithms.includes(algorithm)) {
        throw new Error(`"alg" parameter for "${keyType}" key type must be one of: ${allowedAlgorithms.join(", ")}.`);
    }
    /*
   * Ignore the next block from test coverage because it gets executed
   * conditionally depending on the Node version. Not ignoring it would
   * prevent us from reaching the target % of coverage for versions of
   * Node under 15.7.0.
   */ /* istanbul ignore next */ if (ASYMMETRIC_KEY_DETAILS_SUPPORTED) {
        switch(keyType){
            case "ec":
                const keyCurve = key.asymmetricKeyDetails.namedCurve;
                const allowedCurve = allowedCurves[algorithm];
                if (keyCurve !== allowedCurve) {
                    throw new Error(`"alg" parameter "${algorithm}" requires curve "${allowedCurve}".`);
                }
                break;
            case "rsa-pss":
                if (RSA_PSS_KEY_DETAILS_SUPPORTED) {
                    const length = parseInt(algorithm.slice(-3), 10);
                    const { hashAlgorithm, mgf1HashAlgorithm, saltLength } = key.asymmetricKeyDetails;
                    if (hashAlgorithm !== `sha${length}` || mgf1HashAlgorithm !== hashAlgorithm) {
                        throw new Error(`Invalid key for this operation, its RSA-PSS parameters do not meet the requirements of "alg" ${algorithm}.`);
                    }
                    if (saltLength !== undefined && saltLength > length >> 3) {
                        throw new Error(`Invalid key for this operation, its RSA-PSS parameter saltLength does not meet the requirements of "alg" ${algorithm}.`);
                    }
                }
                break;
        }
    }
};


/***/ }),

/***/ 56699:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// A linked list to keep track of recently-used-ness
const Yallist = __webpack_require__(5882);
const MAX = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = ()=>1;
// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
    constructor(options){
        if (typeof options === "number") options = {
            max: options
        };
        if (!options) options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0)) throw new TypeError("max must be a non-negative number");
        // Kind of weird to have a default max of Infinity, but oh well.
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number") throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
    }
    // resize the cache when the max changes.
    set max(mL) {
        if (typeof mL !== "number" || mL < 0) throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
    }
    get max() {
        return this[MAX];
    }
    set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
        return this[ALLOW_STALE];
    }
    set maxAge(mA) {
        if (typeof mA !== "number") throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
    }
    get maxAge() {
        return this[MAX_AGE];
    }
    // resize the cache when the lengthCalculator changes.
    set lengthCalculator(lC) {
        if (typeof lC !== "function") lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
            this[LENGTH_CALCULATOR] = lC;
            this[LENGTH] = 0;
            this[LRU_LIST].forEach((hit)=>{
                hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
                this[LENGTH] += hit.length;
            });
        }
        trim(this);
    }
    get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
    }
    get length() {
        return this[LENGTH];
    }
    get itemCount() {
        return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
        thisp = thisp || this;
        for(let walker = this[LRU_LIST].tail; walker !== null;){
            const prev = walker.prev;
            forEachStep(this, fn, walker, thisp);
            walker = prev;
        }
    }
    forEach(fn, thisp) {
        thisp = thisp || this;
        for(let walker = this[LRU_LIST].head; walker !== null;){
            const next = walker.next;
            forEachStep(this, fn, walker, thisp);
            walker = next;
        }
    }
    keys() {
        return this[LRU_LIST].toArray().map((k)=>k.key);
    }
    values() {
        return this[LRU_LIST].toArray().map((k)=>k.value);
    }
    reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
            this[LRU_LIST].forEach((hit)=>this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = new Map() // hash of items by key
        ;
        this[LRU_LIST] = new Yallist() // list of items in order of use recency
        ;
        this[LENGTH] = 0 // length of items in the list
        ;
    }
    dump() {
        return this[LRU_LIST].map((hit)=>isStale(this, hit) ? false : {
                k: hit.key,
                v: hit.value,
                e: hit.now + (hit.maxAge || 0)
            }).toArray().filter((h)=>h);
    }
    dumpLru() {
        return this[LRU_LIST];
    }
    set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number") throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
            if (len > this[MAX]) {
                del(this, this[CACHE].get(key));
                return false;
            }
            const node = this[CACHE].get(key);
            const item = node.value;
            // dispose of the old one before overwriting
            // split out into 2 ifs for better coverage tracking
            if (this[DISPOSE]) {
                if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
            }
            item.now = now;
            item.maxAge = maxAge;
            item.value = value;
            this[LENGTH] += len - item.length;
            item.length = len;
            this.get(key);
            trim(this);
            return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        // oversized objects fall out of cache automatically.
        if (hit.length > this[MAX]) {
            if (this[DISPOSE]) this[DISPOSE](key, value);
            return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
    }
    has(key) {
        if (!this[CACHE].has(key)) return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
    }
    get(key) {
        return get(this, key, true);
    }
    peek(key) {
        return get(this, key, false);
    }
    pop() {
        const node = this[LRU_LIST].tail;
        if (!node) return null;
        del(this, node);
        return node.value;
    }
    del(key) {
        del(this, this[CACHE].get(key));
    }
    load(arr) {
        // reset the cache
        this.reset();
        const now = Date.now();
        // A previous serialized cache has the most recent items first
        for(let l = arr.length - 1; l >= 0; l--){
            const hit = arr[l];
            const expiresAt = hit.e || 0;
            if (expiresAt === 0) // the item was created without expiration in a non aged cache
            this.set(hit.k, hit.v);
            else {
                const maxAge = expiresAt - now;
                // dont add already expired items
                if (maxAge > 0) {
                    this.set(hit.k, hit.v, maxAge);
                }
            }
        }
    }
    prune() {
        this[CACHE].forEach((value, key)=>get(this, key, false));
    }
}
const get = (self, key, doUse)=>{
    const node = self[CACHE].get(key);
    if (node) {
        const hit = node.value;
        if (isStale(self, hit)) {
            del(self, node);
            if (!self[ALLOW_STALE]) return undefined;
        } else {
            if (doUse) {
                if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
                self[LRU_LIST].unshiftNode(node);
            }
        }
        return hit.value;
    }
};
const isStale = (self, hit)=>{
    if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};
const trim = (self)=>{
    if (self[LENGTH] > self[MAX]) {
        for(let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;){
            // We know that we're about to delete this one, and also
            // what the next least recently used key will be, so just
            // go ahead and set it now.
            const prev = walker.prev;
            del(self, walker);
            walker = prev;
        }
    }
};
const del = (self, node)=>{
    if (node) {
        const hit = node.value;
        if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
        self[LENGTH] -= hit.length;
        self[CACHE].delete(hit.key);
        self[LRU_LIST].removeNode(node);
    }
};
class Entry {
    constructor(key, value, length, now, maxAge){
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
    }
}
const forEachStep = (self, fn, node, thisp)=>{
    let hit = node.value;
    if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE]) hit = undefined;
    }
    if (hit) fn.call(thisp, hit.value, hit.key, self);
};
module.exports = LRUCache;


/***/ }),

/***/ 93153:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const ANY = Symbol("SemVer ANY");
// hoisted class for cyclic dependency
class Comparator {
    static get ANY() {
        return ANY;
    }
    constructor(comp, options){
        options = parseOptions(options);
        if (comp instanceof Comparator) {
            if (comp.loose === !!options.loose) {
                return comp;
            } else {
                comp = comp.value;
            }
        }
        comp = comp.trim().split(/\s+/).join(" ");
        debug("comparator", comp, options);
        this.options = options;
        this.loose = !!options.loose;
        this.parse(comp);
        if (this.semver === ANY) {
            this.value = "";
        } else {
            this.value = this.operator + this.semver.version;
        }
        debug("comp", this);
    }
    parse(comp) {
        const r = this.options.loose ? re[t.COMPARATORLOOSE] : re[t.COMPARATOR];
        const m = comp.match(r);
        if (!m) {
            throw new TypeError(`Invalid comparator: ${comp}`);
        }
        this.operator = m[1] !== undefined ? m[1] : "";
        if (this.operator === "=") {
            this.operator = "";
        }
        // if it literally is just '>' or '' then allow anything.
        if (!m[2]) {
            this.semver = ANY;
        } else {
            this.semver = new SemVer(m[2], this.options.loose);
        }
    }
    toString() {
        return this.value;
    }
    test(version) {
        debug("Comparator.test", version, this.options.loose);
        if (this.semver === ANY || version === ANY) {
            return true;
        }
        if (typeof version === "string") {
            try {
                version = new SemVer(version, this.options);
            } catch (er) {
                return false;
            }
        }
        return cmp(version, this.operator, this.semver, this.options);
    }
    intersects(comp, options) {
        if (!(comp instanceof Comparator)) {
            throw new TypeError("a Comparator is required");
        }
        if (this.operator === "") {
            if (this.value === "") {
                return true;
            }
            return new Range(comp.value, options).test(this.value);
        } else if (comp.operator === "") {
            if (comp.value === "") {
                return true;
            }
            return new Range(this.value, options).test(comp.semver);
        }
        options = parseOptions(options);
        // Special cases where nothing can possibly be lower
        if (options.includePrerelease && (this.value === "<0.0.0-0" || comp.value === "<0.0.0-0")) {
            return false;
        }
        if (!options.includePrerelease && (this.value.startsWith("<0.0.0") || comp.value.startsWith("<0.0.0"))) {
            return false;
        }
        // Same direction increasing (> or >=)
        if (this.operator.startsWith(">") && comp.operator.startsWith(">")) {
            return true;
        }
        // Same direction decreasing (< or <=)
        if (this.operator.startsWith("<") && comp.operator.startsWith("<")) {
            return true;
        }
        // same SemVer and both sides are inclusive (<= or >=)
        if (this.semver.version === comp.semver.version && this.operator.includes("=") && comp.operator.includes("=")) {
            return true;
        }
        // opposite directions less than
        if (cmp(this.semver, "<", comp.semver, options) && this.operator.startsWith(">") && comp.operator.startsWith("<")) {
            return true;
        }
        // opposite directions greater than
        if (cmp(this.semver, ">", comp.semver, options) && this.operator.startsWith("<") && comp.operator.startsWith(">")) {
            return true;
        }
        return false;
    }
}
module.exports = Comparator;
const parseOptions = __webpack_require__(35734);
const { safeRe: re, t } = __webpack_require__(46814);
const cmp = __webpack_require__(67288);
const debug = __webpack_require__(61654);
const SemVer = __webpack_require__(63938);
const Range = __webpack_require__(41265);


/***/ }),

/***/ 41265:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// hoisted class for cyclic dependency

class Range {
    constructor(range, options){
        options = parseOptions(options);
        if (range instanceof Range) {
            if (range.loose === !!options.loose && range.includePrerelease === !!options.includePrerelease) {
                return range;
            } else {
                return new Range(range.raw, options);
            }
        }
        if (range instanceof Comparator) {
            // just put it in the set and return
            this.raw = range.value;
            this.set = [
                [
                    range
                ]
            ];
            this.format();
            return this;
        }
        this.options = options;
        this.loose = !!options.loose;
        this.includePrerelease = !!options.includePrerelease;
        // First reduce all whitespace as much as possible so we do not have to rely
        // on potentially slow regexes like \s*. This is then stored and used for
        // future error messages as well.
        this.raw = range.trim().split(/\s+/).join(" ");
        // First, split on ||
        this.set = this.raw.split("||")// map the range to a 2d array of comparators
        .map((r)=>this.parseRange(r.trim()))// throw out any comparator lists that are empty
        // this generally means that it was not a valid range, which is allowed
        // in loose mode, but will still throw if the WHOLE range is invalid.
        .filter((c)=>c.length);
        if (!this.set.length) {
            throw new TypeError(`Invalid SemVer Range: ${this.raw}`);
        }
        // if we have any that are not the null set, throw out null sets.
        if (this.set.length > 1) {
            // keep the first one, in case they're all null sets
            const first = this.set[0];
            this.set = this.set.filter((c)=>!isNullSet(c[0]));
            if (this.set.length === 0) {
                this.set = [
                    first
                ];
            } else if (this.set.length > 1) {
                // if we have any that are *, then the range is just *
                for (const c of this.set){
                    if (c.length === 1 && isAny(c[0])) {
                        this.set = [
                            c
                        ];
                        break;
                    }
                }
            }
        }
        this.format();
    }
    format() {
        this.range = this.set.map((comps)=>comps.join(" ").trim()).join("||").trim();
        return this.range;
    }
    toString() {
        return this.range;
    }
    parseRange(range) {
        // memoize range parsing for performance.
        // this is a very hot path, and fully deterministic.
        const memoOpts = (this.options.includePrerelease && FLAG_INCLUDE_PRERELEASE) | (this.options.loose && FLAG_LOOSE);
        const memoKey = memoOpts + ":" + range;
        const cached = cache.get(memoKey);
        if (cached) {
            return cached;
        }
        const loose = this.options.loose;
        // `1.2.3 - 1.2.4` => `>=1.2.3 <=1.2.4`
        const hr = loose ? re[t.HYPHENRANGELOOSE] : re[t.HYPHENRANGE];
        range = range.replace(hr, hyphenReplace(this.options.includePrerelease));
        debug("hyphen replace", range);
        // `> 1.2.3 < 1.2.5` => `>1.2.3 <1.2.5`
        range = range.replace(re[t.COMPARATORTRIM], comparatorTrimReplace);
        debug("comparator trim", range);
        // `~ 1.2.3` => `~1.2.3`
        range = range.replace(re[t.TILDETRIM], tildeTrimReplace);
        debug("tilde trim", range);
        // `^ 1.2.3` => `^1.2.3`
        range = range.replace(re[t.CARETTRIM], caretTrimReplace);
        debug("caret trim", range);
        // At this point, the range is completely trimmed and
        // ready to be split into comparators.
        let rangeList = range.split(" ").map((comp)=>parseComparator(comp, this.options)).join(" ").split(/\s+/)// >=0.0.0 is equivalent to *
        .map((comp)=>replaceGTE0(comp, this.options));
        if (loose) {
            // in loose mode, throw out any that are not valid comparators
            rangeList = rangeList.filter((comp)=>{
                debug("loose invalid filter", comp, this.options);
                return !!comp.match(re[t.COMPARATORLOOSE]);
            });
        }
        debug("range list", rangeList);
        // if any comparators are the null set, then replace with JUST null set
        // if more than one comparator, remove any * comparators
        // also, don't include the same comparator more than once
        const rangeMap = new Map();
        const comparators = rangeList.map((comp)=>new Comparator(comp, this.options));
        for (const comp of comparators){
            if (isNullSet(comp)) {
                return [
                    comp
                ];
            }
            rangeMap.set(comp.value, comp);
        }
        if (rangeMap.size > 1 && rangeMap.has("")) {
            rangeMap.delete("");
        }
        const result = [
            ...rangeMap.values()
        ];
        cache.set(memoKey, result);
        return result;
    }
    intersects(range, options) {
        if (!(range instanceof Range)) {
            throw new TypeError("a Range is required");
        }
        return this.set.some((thisComparators)=>{
            return isSatisfiable(thisComparators, options) && range.set.some((rangeComparators)=>{
                return isSatisfiable(rangeComparators, options) && thisComparators.every((thisComparator)=>{
                    return rangeComparators.every((rangeComparator)=>{
                        return thisComparator.intersects(rangeComparator, options);
                    });
                });
            });
        });
    }
    // if ANY of the sets match ALL of its comparators, then pass
    test(version) {
        if (!version) {
            return false;
        }
        if (typeof version === "string") {
            try {
                version = new SemVer(version, this.options);
            } catch (er) {
                return false;
            }
        }
        for(let i = 0; i < this.set.length; i++){
            if (testSet(this.set[i], version, this.options)) {
                return true;
            }
        }
        return false;
    }
}
module.exports = Range;
const LRU = __webpack_require__(56699);
const cache = new LRU({
    max: 1000
});
const parseOptions = __webpack_require__(35734);
const Comparator = __webpack_require__(93153);
const debug = __webpack_require__(61654);
const SemVer = __webpack_require__(63938);
const { safeRe: re, t, comparatorTrimReplace, tildeTrimReplace, caretTrimReplace } = __webpack_require__(46814);
const { FLAG_INCLUDE_PRERELEASE, FLAG_LOOSE } = __webpack_require__(70985);
const isNullSet = (c)=>c.value === "<0.0.0-0";
const isAny = (c)=>c.value === "";
// take a set of comparators and determine whether there
// exists a version which can satisfy it
const isSatisfiable = (comparators, options)=>{
    let result = true;
    const remainingComparators = comparators.slice();
    let testComparator = remainingComparators.pop();
    while(result && remainingComparators.length){
        result = remainingComparators.every((otherComparator)=>{
            return testComparator.intersects(otherComparator, options);
        });
        testComparator = remainingComparators.pop();
    }
    return result;
};
// comprised of xranges, tildes, stars, and gtlt's at this point.
// already replaced the hyphen ranges
// turn into a set of JUST comparators.
const parseComparator = (comp, options)=>{
    debug("comp", comp, options);
    comp = replaceCarets(comp, options);
    debug("caret", comp);
    comp = replaceTildes(comp, options);
    debug("tildes", comp);
    comp = replaceXRanges(comp, options);
    debug("xrange", comp);
    comp = replaceStars(comp, options);
    debug("stars", comp);
    return comp;
};
const isX = (id)=>!id || id.toLowerCase() === "x" || id === "*";
// ~, ~> --> * (any, kinda silly)
// ~2, ~2.x, ~2.x.x, ~>2, ~>2.x ~>2.x.x --> >=2.0.0 <3.0.0-0
// ~2.0, ~2.0.x, ~>2.0, ~>2.0.x --> >=2.0.0 <2.1.0-0
// ~1.2, ~1.2.x, ~>1.2, ~>1.2.x --> >=1.2.0 <1.3.0-0
// ~1.2.3, ~>1.2.3 --> >=1.2.3 <1.3.0-0
// ~1.2.0, ~>1.2.0 --> >=1.2.0 <1.3.0-0
// ~0.0.1 --> >=0.0.1 <0.1.0-0
const replaceTildes = (comp, options)=>{
    return comp.trim().split(/\s+/).map((c)=>replaceTilde(c, options)).join(" ");
};
const replaceTilde = (comp, options)=>{
    const r = options.loose ? re[t.TILDELOOSE] : re[t.TILDE];
    return comp.replace(r, (_, M, m, p, pr)=>{
        debug("tilde", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
            ret = "";
        } else if (isX(m)) {
            ret = `>=${M}.0.0 <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
            // ~1.2 == >=1.2.0 <1.3.0-0
            ret = `>=${M}.${m}.0 <${M}.${+m + 1}.0-0`;
        } else if (pr) {
            debug("replaceTilde pr", pr);
            ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
        } else {
            // ~1.2.3 == >=1.2.3 <1.3.0-0
            ret = `>=${M}.${m}.${p} <${M}.${+m + 1}.0-0`;
        }
        debug("tilde return", ret);
        return ret;
    });
};
// ^ --> * (any, kinda silly)
// ^2, ^2.x, ^2.x.x --> >=2.0.0 <3.0.0-0
// ^2.0, ^2.0.x --> >=2.0.0 <3.0.0-0
// ^1.2, ^1.2.x --> >=1.2.0 <2.0.0-0
// ^1.2.3 --> >=1.2.3 <2.0.0-0
// ^1.2.0 --> >=1.2.0 <2.0.0-0
// ^0.0.1 --> >=0.0.1 <0.0.2-0
// ^0.1.0 --> >=0.1.0 <0.2.0-0
const replaceCarets = (comp, options)=>{
    return comp.trim().split(/\s+/).map((c)=>replaceCaret(c, options)).join(" ");
};
const replaceCaret = (comp, options)=>{
    debug("caret", comp, options);
    const r = options.loose ? re[t.CARETLOOSE] : re[t.CARET];
    const z = options.includePrerelease ? "-0" : "";
    return comp.replace(r, (_, M, m, p, pr)=>{
        debug("caret", comp, _, M, m, p, pr);
        let ret;
        if (isX(M)) {
            ret = "";
        } else if (isX(m)) {
            ret = `>=${M}.0.0${z} <${+M + 1}.0.0-0`;
        } else if (isX(p)) {
            if (M === "0") {
                ret = `>=${M}.${m}.0${z} <${M}.${+m + 1}.0-0`;
            } else {
                ret = `>=${M}.${m}.0${z} <${+M + 1}.0.0-0`;
            }
        } else if (pr) {
            debug("replaceCaret pr", pr);
            if (M === "0") {
                if (m === "0") {
                    ret = `>=${M}.${m}.${p}-${pr} <${M}.${m}.${+p + 1}-0`;
                } else {
                    ret = `>=${M}.${m}.${p}-${pr} <${M}.${+m + 1}.0-0`;
                }
            } else {
                ret = `>=${M}.${m}.${p}-${pr} <${+M + 1}.0.0-0`;
            }
        } else {
            debug("no pr");
            if (M === "0") {
                if (m === "0") {
                    ret = `>=${M}.${m}.${p}${z} <${M}.${m}.${+p + 1}-0`;
                } else {
                    ret = `>=${M}.${m}.${p}${z} <${M}.${+m + 1}.0-0`;
                }
            } else {
                ret = `>=${M}.${m}.${p} <${+M + 1}.0.0-0`;
            }
        }
        debug("caret return", ret);
        return ret;
    });
};
const replaceXRanges = (comp, options)=>{
    debug("replaceXRanges", comp, options);
    return comp.split(/\s+/).map((c)=>replaceXRange(c, options)).join(" ");
};
const replaceXRange = (comp, options)=>{
    comp = comp.trim();
    const r = options.loose ? re[t.XRANGELOOSE] : re[t.XRANGE];
    return comp.replace(r, (ret, gtlt, M, m, p, pr)=>{
        debug("xRange", comp, ret, gtlt, M, m, p, pr);
        const xM = isX(M);
        const xm = xM || isX(m);
        const xp = xm || isX(p);
        const anyX = xp;
        if (gtlt === "=" && anyX) {
            gtlt = "";
        }
        // if we're including prereleases in the match, then we need
        // to fix this to -0, the lowest possible prerelease value
        pr = options.includePrerelease ? "-0" : "";
        if (xM) {
            if (gtlt === ">" || gtlt === "<") {
                // nothing is allowed
                ret = "<0.0.0-0";
            } else {
                // nothing is forbidden
                ret = "*";
            }
        } else if (gtlt && anyX) {
            // we know patch is an x, because we have any x at all.
            // replace X with 0
            if (xm) {
                m = 0;
            }
            p = 0;
            if (gtlt === ">") {
                // >1 => >=2.0.0
                // >1.2 => >=1.3.0
                gtlt = ">=";
                if (xm) {
                    M = +M + 1;
                    m = 0;
                    p = 0;
                } else {
                    m = +m + 1;
                    p = 0;
                }
            } else if (gtlt === "<=") {
                // <=0.7.x is actually <0.8.0, since any 0.7.x should
                // pass.  Similarly, <=7.x is actually <8.0.0, etc.
                gtlt = "<";
                if (xm) {
                    M = +M + 1;
                } else {
                    m = +m + 1;
                }
            }
            if (gtlt === "<") {
                pr = "-0";
            }
            ret = `${gtlt + M}.${m}.${p}${pr}`;
        } else if (xm) {
            ret = `>=${M}.0.0${pr} <${+M + 1}.0.0-0`;
        } else if (xp) {
            ret = `>=${M}.${m}.0${pr} <${M}.${+m + 1}.0-0`;
        }
        debug("xRange return", ret);
        return ret;
    });
};
// Because * is AND-ed with everything else in the comparator,
// and '' means "any version", just remove the *s entirely.
const replaceStars = (comp, options)=>{
    debug("replaceStars", comp, options);
    // Looseness is ignored here.  star is always as loose as it gets!
    return comp.trim().replace(re[t.STAR], "");
};
const replaceGTE0 = (comp, options)=>{
    debug("replaceGTE0", comp, options);
    return comp.trim().replace(re[options.includePrerelease ? t.GTE0PRE : t.GTE0], "");
};
// This function is passed to string.replace(re[t.HYPHENRANGE])
// M, m, patch, prerelease, build
// 1.2 - 3.4.5 => >=1.2.0 <=3.4.5
// 1.2.3 - 3.4 => >=1.2.0 <3.5.0-0 Any 3.4.x will do
// 1.2 - 3.4 => >=1.2.0 <3.5.0-0
const hyphenReplace = (incPr)=>($0, from, fM, fm, fp, fpr, fb, to, tM, tm, tp, tpr, tb)=>{
        if (isX(fM)) {
            from = "";
        } else if (isX(fm)) {
            from = `>=${fM}.0.0${incPr ? "-0" : ""}`;
        } else if (isX(fp)) {
            from = `>=${fM}.${fm}.0${incPr ? "-0" : ""}`;
        } else if (fpr) {
            from = `>=${from}`;
        } else {
            from = `>=${from}${incPr ? "-0" : ""}`;
        }
        if (isX(tM)) {
            to = "";
        } else if (isX(tm)) {
            to = `<${+tM + 1}.0.0-0`;
        } else if (isX(tp)) {
            to = `<${tM}.${+tm + 1}.0-0`;
        } else if (tpr) {
            to = `<=${tM}.${tm}.${tp}-${tpr}`;
        } else if (incPr) {
            to = `<${tM}.${tm}.${+tp + 1}-0`;
        } else {
            to = `<=${to}`;
        }
        return `${from} ${to}`.trim();
    };
const testSet = (set, version, options)=>{
    for(let i = 0; i < set.length; i++){
        if (!set[i].test(version)) {
            return false;
        }
    }
    if (version.prerelease.length && !options.includePrerelease) {
        // Find the set of versions that are allowed to have prereleases
        // For example, ^1.2.3-pr.1 desugars to >=1.2.3-pr.1 <2.0.0
        // That should allow `1.2.3-pr.2` to pass.
        // However, `1.2.4-alpha.notready` should NOT be allowed,
        // even though it's within the range set by the comparators.
        for(let i = 0; i < set.length; i++){
            debug(set[i].semver);
            if (set[i].semver === Comparator.ANY) {
                continue;
            }
            if (set[i].semver.prerelease.length > 0) {
                const allowed = set[i].semver;
                if (allowed.major === version.major && allowed.minor === version.minor && allowed.patch === version.patch) {
                    return true;
                }
            }
        }
        // Version has a -pre, but it's not one of the ones we like.
        return false;
    }
    return true;
};


/***/ }),

/***/ 63938:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const debug = __webpack_require__(61654);
const { MAX_LENGTH, MAX_SAFE_INTEGER } = __webpack_require__(70985);
const { safeRe: re, t } = __webpack_require__(46814);
const parseOptions = __webpack_require__(35734);
const { compareIdentifiers } = __webpack_require__(59836);
class SemVer {
    constructor(version, options){
        options = parseOptions(options);
        if (version instanceof SemVer) {
            if (version.loose === !!options.loose && version.includePrerelease === !!options.includePrerelease) {
                return version;
            } else {
                version = version.version;
            }
        } else if (typeof version !== "string") {
            throw new TypeError(`Invalid version. Must be a string. Got type "${typeof version}".`);
        }
        if (version.length > MAX_LENGTH) {
            throw new TypeError(`version is longer than ${MAX_LENGTH} characters`);
        }
        debug("SemVer", version, options);
        this.options = options;
        this.loose = !!options.loose;
        // this isn't actually relevant for versions, but keep it so that we
        // don't run into trouble passing this.options around.
        this.includePrerelease = !!options.includePrerelease;
        const m = version.trim().match(options.loose ? re[t.LOOSE] : re[t.FULL]);
        if (!m) {
            throw new TypeError(`Invalid Version: ${version}`);
        }
        this.raw = version;
        // these are actually numbers
        this.major = +m[1];
        this.minor = +m[2];
        this.patch = +m[3];
        if (this.major > MAX_SAFE_INTEGER || this.major < 0) {
            throw new TypeError("Invalid major version");
        }
        if (this.minor > MAX_SAFE_INTEGER || this.minor < 0) {
            throw new TypeError("Invalid minor version");
        }
        if (this.patch > MAX_SAFE_INTEGER || this.patch < 0) {
            throw new TypeError("Invalid patch version");
        }
        // numberify any prerelease numeric ids
        if (!m[4]) {
            this.prerelease = [];
        } else {
            this.prerelease = m[4].split(".").map((id)=>{
                if (/^[0-9]+$/.test(id)) {
                    const num = +id;
                    if (num >= 0 && num < MAX_SAFE_INTEGER) {
                        return num;
                    }
                }
                return id;
            });
        }
        this.build = m[5] ? m[5].split(".") : [];
        this.format();
    }
    format() {
        this.version = `${this.major}.${this.minor}.${this.patch}`;
        if (this.prerelease.length) {
            this.version += `-${this.prerelease.join(".")}`;
        }
        return this.version;
    }
    toString() {
        return this.version;
    }
    compare(other) {
        debug("SemVer.compare", this.version, this.options, other);
        if (!(other instanceof SemVer)) {
            if (typeof other === "string" && other === this.version) {
                return 0;
            }
            other = new SemVer(other, this.options);
        }
        if (other.version === this.version) {
            return 0;
        }
        return this.compareMain(other) || this.comparePre(other);
    }
    compareMain(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        return compareIdentifiers(this.major, other.major) || compareIdentifiers(this.minor, other.minor) || compareIdentifiers(this.patch, other.patch);
    }
    comparePre(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        // NOT having a prerelease is > having one
        if (this.prerelease.length && !other.prerelease.length) {
            return -1;
        } else if (!this.prerelease.length && other.prerelease.length) {
            return 1;
        } else if (!this.prerelease.length && !other.prerelease.length) {
            return 0;
        }
        let i = 0;
        do {
            const a = this.prerelease[i];
            const b = other.prerelease[i];
            debug("prerelease compare", i, a, b);
            if (a === undefined && b === undefined) {
                return 0;
            } else if (b === undefined) {
                return 1;
            } else if (a === undefined) {
                return -1;
            } else if (a === b) {
                continue;
            } else {
                return compareIdentifiers(a, b);
            }
        }while (++i);
    }
    compareBuild(other) {
        if (!(other instanceof SemVer)) {
            other = new SemVer(other, this.options);
        }
        let i = 0;
        do {
            const a = this.build[i];
            const b = other.build[i];
            debug("prerelease compare", i, a, b);
            if (a === undefined && b === undefined) {
                return 0;
            } else if (b === undefined) {
                return 1;
            } else if (a === undefined) {
                return -1;
            } else if (a === b) {
                continue;
            } else {
                return compareIdentifiers(a, b);
            }
        }while (++i);
    }
    // preminor will bump the version up to the next minor release, and immediately
    // down to pre-release. premajor and prepatch work the same way.
    inc(release, identifier, identifierBase) {
        switch(release){
            case "premajor":
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor = 0;
                this.major++;
                this.inc("pre", identifier, identifierBase);
                break;
            case "preminor":
                this.prerelease.length = 0;
                this.patch = 0;
                this.minor++;
                this.inc("pre", identifier, identifierBase);
                break;
            case "prepatch":
                // If this is already a prerelease, it will bump to the next version
                // drop any prereleases that might already exist, since they are not
                // relevant at this point.
                this.prerelease.length = 0;
                this.inc("patch", identifier, identifierBase);
                this.inc("pre", identifier, identifierBase);
                break;
            // If the input is a non-prerelease version, this acts the same as
            // prepatch.
            case "prerelease":
                if (this.prerelease.length === 0) {
                    this.inc("patch", identifier, identifierBase);
                }
                this.inc("pre", identifier, identifierBase);
                break;
            case "major":
                // If this is a pre-major version, bump up to the same major version.
                // Otherwise increment major.
                // 1.0.0-5 bumps to 1.0.0
                // 1.1.0 bumps to 2.0.0
                if (this.minor !== 0 || this.patch !== 0 || this.prerelease.length === 0) {
                    this.major++;
                }
                this.minor = 0;
                this.patch = 0;
                this.prerelease = [];
                break;
            case "minor":
                // If this is a pre-minor version, bump up to the same minor version.
                // Otherwise increment minor.
                // 1.2.0-5 bumps to 1.2.0
                // 1.2.1 bumps to 1.3.0
                if (this.patch !== 0 || this.prerelease.length === 0) {
                    this.minor++;
                }
                this.patch = 0;
                this.prerelease = [];
                break;
            case "patch":
                // If this is not a pre-release version, it will increment the patch.
                // If it is a pre-release it will bump up to the same patch version.
                // 1.2.0-5 patches to 1.2.0
                // 1.2.0 patches to 1.2.1
                if (this.prerelease.length === 0) {
                    this.patch++;
                }
                this.prerelease = [];
                break;
            // This probably shouldn't be used publicly.
            // 1.0.0 'pre' would become 1.0.0-0 which is the wrong direction.
            case "pre":
                {
                    const base = Number(identifierBase) ? 1 : 0;
                    if (!identifier && identifierBase === false) {
                        throw new Error("invalid increment argument: identifier is empty");
                    }
                    if (this.prerelease.length === 0) {
                        this.prerelease = [
                            base
                        ];
                    } else {
                        let i = this.prerelease.length;
                        while(--i >= 0){
                            if (typeof this.prerelease[i] === "number") {
                                this.prerelease[i]++;
                                i = -2;
                            }
                        }
                        if (i === -1) {
                            // didn't increment anything
                            if (identifier === this.prerelease.join(".") && identifierBase === false) {
                                throw new Error("invalid increment argument: identifier already exists");
                            }
                            this.prerelease.push(base);
                        }
                    }
                    if (identifier) {
                        // 1.2.0-beta.1 bumps to 1.2.0-beta.2,
                        // 1.2.0-beta.fooblz or 1.2.0-beta bumps to 1.2.0-beta.0
                        let prerelease = [
                            identifier,
                            base
                        ];
                        if (identifierBase === false) {
                            prerelease = [
                                identifier
                            ];
                        }
                        if (compareIdentifiers(this.prerelease[0], identifier) === 0) {
                            if (isNaN(this.prerelease[1])) {
                                this.prerelease = prerelease;
                            }
                        } else {
                            this.prerelease = prerelease;
                        }
                    }
                    break;
                }
            default:
                throw new Error(`invalid increment argument: ${release}`);
        }
        this.raw = this.format();
        if (this.build.length) {
            this.raw += `+${this.build.join(".")}`;
        }
        return this;
    }
}
module.exports = SemVer;


/***/ }),

/***/ 87760:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const parse = __webpack_require__(35129);
const clean = (version, options)=>{
    const s = parse(version.trim().replace(/^[=v]+/, ""), options);
    return s ? s.version : null;
};
module.exports = clean;


/***/ }),

/***/ 67288:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const eq = __webpack_require__(62460);
const neq = __webpack_require__(67404);
const gt = __webpack_require__(96009);
const gte = __webpack_require__(89468);
const lt = __webpack_require__(19759);
const lte = __webpack_require__(17056);
const cmp = (a, op, b, loose)=>{
    switch(op){
        case "===":
            if (typeof a === "object") {
                a = a.version;
            }
            if (typeof b === "object") {
                b = b.version;
            }
            return a === b;
        case "!==":
            if (typeof a === "object") {
                a = a.version;
            }
            if (typeof b === "object") {
                b = b.version;
            }
            return a !== b;
        case "":
        case "=":
        case "==":
            return eq(a, b, loose);
        case "!=":
            return neq(a, b, loose);
        case ">":
            return gt(a, b, loose);
        case ">=":
            return gte(a, b, loose);
        case "<":
            return lt(a, b, loose);
        case "<=":
            return lte(a, b, loose);
        default:
            throw new TypeError(`Invalid operator: ${op}`);
    }
};
module.exports = cmp;


/***/ }),

/***/ 29061:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SemVer = __webpack_require__(63938);
const parse = __webpack_require__(35129);
const { safeRe: re, t } = __webpack_require__(46814);
const coerce = (version, options)=>{
    if (version instanceof SemVer) {
        return version;
    }
    if (typeof version === "number") {
        version = String(version);
    }
    if (typeof version !== "string") {
        return null;
    }
    options = options || {};
    let match = null;
    if (!options.rtl) {
        match = version.match(re[t.COERCE]);
    } else {
        // Find the right-most coercible string that does not share
        // a terminus with a more left-ward coercible string.
        // Eg, '1.2.3.4' wants to coerce '2.3.4', not '3.4' or '4'
        //
        // Walk through the string checking with a /g regexp
        // Manually set the index so as to pick up overlapping matches.
        // Stop when we get a match that ends at the string end, since no
        // coercible string can be more right-ward without the same terminus.
        let next;
        while((next = re[t.COERCERTL].exec(version)) && (!match || match.index + match[0].length !== version.length)){
            if (!match || next.index + next[0].length !== match.index + match[0].length) {
                match = next;
            }
            re[t.COERCERTL].lastIndex = next.index + next[1].length + next[2].length;
        }
        // leave it in a clean state
        re[t.COERCERTL].lastIndex = -1;
    }
    if (match === null) {
        return null;
    }
    return parse(`${match[2]}.${match[3] || "0"}.${match[4] || "0"}`, options);
};
module.exports = coerce;


/***/ }),

/***/ 74738:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SemVer = __webpack_require__(63938);
const compareBuild = (a, b, loose)=>{
    const versionA = new SemVer(a, loose);
    const versionB = new SemVer(b, loose);
    return versionA.compare(versionB) || versionA.compareBuild(versionB);
};
module.exports = compareBuild;


/***/ }),

/***/ 22761:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const compare = __webpack_require__(84497);
const compareLoose = (a, b)=>compare(a, b, true);
module.exports = compareLoose;


/***/ }),

/***/ 84497:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SemVer = __webpack_require__(63938);
const compare = (a, b, loose)=>new SemVer(a, loose).compare(new SemVer(b, loose));
module.exports = compare;


/***/ }),

/***/ 83388:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const parse = __webpack_require__(35129);
const diff = (version1, version2)=>{
    const v1 = parse(version1, null, true);
    const v2 = parse(version2, null, true);
    const comparison = v1.compare(v2);
    if (comparison === 0) {
        return null;
    }
    const v1Higher = comparison > 0;
    const highVersion = v1Higher ? v1 : v2;
    const lowVersion = v1Higher ? v2 : v1;
    const highHasPre = !!highVersion.prerelease.length;
    const lowHasPre = !!lowVersion.prerelease.length;
    if (lowHasPre && !highHasPre) {
        // Going from prerelease -> no prerelease requires some special casing
        // If the low version has only a major, then it will always be a major
        // Some examples:
        // 1.0.0-1 -> 1.0.0
        // 1.0.0-1 -> 1.1.1
        // 1.0.0-1 -> 2.0.0
        if (!lowVersion.patch && !lowVersion.minor) {
            return "major";
        }
        // Otherwise it can be determined by checking the high version
        if (highVersion.patch) {
            // anything higher than a patch bump would result in the wrong version
            return "patch";
        }
        if (highVersion.minor) {
            // anything higher than a minor bump would result in the wrong version
            return "minor";
        }
        // bumping major/minor/patch all have same result
        return "major";
    }
    // add the `pre` prefix if we are going to a prerelease version
    const prefix = highHasPre ? "pre" : "";
    if (v1.major !== v2.major) {
        return prefix + "major";
    }
    if (v1.minor !== v2.minor) {
        return prefix + "minor";
    }
    if (v1.patch !== v2.patch) {
        return prefix + "patch";
    }
    // high and low are preleases
    return "prerelease";
};
module.exports = diff;


/***/ }),

/***/ 62460:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const compare = __webpack_require__(84497);
const eq = (a, b, loose)=>compare(a, b, loose) === 0;
module.exports = eq;


/***/ }),

/***/ 96009:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const compare = __webpack_require__(84497);
const gt = (a, b, loose)=>compare(a, b, loose) > 0;
module.exports = gt;


/***/ }),

/***/ 89468:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const compare = __webpack_require__(84497);
const gte = (a, b, loose)=>compare(a, b, loose) >= 0;
module.exports = gte;


/***/ }),

/***/ 47756:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SemVer = __webpack_require__(63938);
const inc = (version, release, options, identifier, identifierBase)=>{
    if (typeof options === "string") {
        identifierBase = identifier;
        identifier = options;
        options = undefined;
    }
    try {
        return new SemVer(version instanceof SemVer ? version.version : version, options).inc(release, identifier, identifierBase).version;
    } catch (er) {
        return null;
    }
};
module.exports = inc;


/***/ }),

/***/ 19759:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const compare = __webpack_require__(84497);
const lt = (a, b, loose)=>compare(a, b, loose) < 0;
module.exports = lt;


/***/ }),

/***/ 17056:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const compare = __webpack_require__(84497);
const lte = (a, b, loose)=>compare(a, b, loose) <= 0;
module.exports = lte;


/***/ }),

/***/ 12054:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SemVer = __webpack_require__(63938);
const major = (a, loose)=>new SemVer(a, loose).major;
module.exports = major;


/***/ }),

/***/ 41824:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SemVer = __webpack_require__(63938);
const minor = (a, loose)=>new SemVer(a, loose).minor;
module.exports = minor;


/***/ }),

/***/ 67404:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const compare = __webpack_require__(84497);
const neq = (a, b, loose)=>compare(a, b, loose) !== 0;
module.exports = neq;


/***/ }),

/***/ 35129:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SemVer = __webpack_require__(63938);
const parse = (version, options, throwErrors = false)=>{
    if (version instanceof SemVer) {
        return version;
    }
    try {
        return new SemVer(version, options);
    } catch (er) {
        if (!throwErrors) {
            return null;
        }
        throw er;
    }
};
module.exports = parse;


/***/ }),

/***/ 51339:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SemVer = __webpack_require__(63938);
const patch = (a, loose)=>new SemVer(a, loose).patch;
module.exports = patch;


/***/ }),

/***/ 99103:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const parse = __webpack_require__(35129);
const prerelease = (version, options)=>{
    const parsed = parse(version, options);
    return parsed && parsed.prerelease.length ? parsed.prerelease : null;
};
module.exports = prerelease;


/***/ }),

/***/ 50669:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const compare = __webpack_require__(84497);
const rcompare = (a, b, loose)=>compare(b, a, loose);
module.exports = rcompare;


/***/ }),

/***/ 58199:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const compareBuild = __webpack_require__(74738);
const rsort = (list, loose)=>list.sort((a, b)=>compareBuild(b, a, loose));
module.exports = rsort;


/***/ }),

/***/ 84580:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Range = __webpack_require__(41265);
const satisfies = (version, range, options)=>{
    try {
        range = new Range(range, options);
    } catch (er) {
        return false;
    }
    return range.test(version);
};
module.exports = satisfies;


/***/ }),

/***/ 24578:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const compareBuild = __webpack_require__(74738);
const sort = (list, loose)=>list.sort((a, b)=>compareBuild(a, b, loose));
module.exports = sort;


/***/ }),

/***/ 4734:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const parse = __webpack_require__(35129);
const valid = (version, options)=>{
    const v = parse(version, options);
    return v ? v.version : null;
};
module.exports = valid;


/***/ }),

/***/ 7045:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// just pre-load all the stuff that index.js lazily exports

const internalRe = __webpack_require__(46814);
const constants = __webpack_require__(70985);
const SemVer = __webpack_require__(63938);
const identifiers = __webpack_require__(59836);
const parse = __webpack_require__(35129);
const valid = __webpack_require__(4734);
const clean = __webpack_require__(87760);
const inc = __webpack_require__(47756);
const diff = __webpack_require__(83388);
const major = __webpack_require__(12054);
const minor = __webpack_require__(41824);
const patch = __webpack_require__(51339);
const prerelease = __webpack_require__(99103);
const compare = __webpack_require__(84497);
const rcompare = __webpack_require__(50669);
const compareLoose = __webpack_require__(22761);
const compareBuild = __webpack_require__(74738);
const sort = __webpack_require__(24578);
const rsort = __webpack_require__(58199);
const gt = __webpack_require__(96009);
const lt = __webpack_require__(19759);
const eq = __webpack_require__(62460);
const neq = __webpack_require__(67404);
const gte = __webpack_require__(89468);
const lte = __webpack_require__(17056);
const cmp = __webpack_require__(67288);
const coerce = __webpack_require__(29061);
const Comparator = __webpack_require__(93153);
const Range = __webpack_require__(41265);
const satisfies = __webpack_require__(84580);
const toComparators = __webpack_require__(71974);
const maxSatisfying = __webpack_require__(32157);
const minSatisfying = __webpack_require__(60297);
const minVersion = __webpack_require__(59013);
const validRange = __webpack_require__(27312);
const outside = __webpack_require__(2766);
const gtr = __webpack_require__(68599);
const ltr = __webpack_require__(66631);
const intersects = __webpack_require__(51943);
const simplifyRange = __webpack_require__(90166);
const subset = __webpack_require__(11991);
module.exports = {
    parse,
    valid,
    clean,
    inc,
    diff,
    major,
    minor,
    patch,
    prerelease,
    compare,
    rcompare,
    compareLoose,
    compareBuild,
    sort,
    rsort,
    gt,
    lt,
    eq,
    neq,
    gte,
    lte,
    cmp,
    coerce,
    Comparator,
    Range,
    satisfies,
    toComparators,
    maxSatisfying,
    minSatisfying,
    minVersion,
    validRange,
    outside,
    gtr,
    ltr,
    intersects,
    simplifyRange,
    subset,
    SemVer,
    re: internalRe.re,
    src: internalRe.src,
    tokens: internalRe.t,
    SEMVER_SPEC_VERSION: constants.SEMVER_SPEC_VERSION,
    RELEASE_TYPES: constants.RELEASE_TYPES,
    compareIdentifiers: identifiers.compareIdentifiers,
    rcompareIdentifiers: identifiers.rcompareIdentifiers
};


/***/ }),

/***/ 70985:
/***/ ((module) => {

"use strict";
// Note: this is the semver.org version of the spec that it implements
// Not necessarily the package version of this code.

const SEMVER_SPEC_VERSION = "2.0.0";
const MAX_LENGTH = 256;
const MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || /* istanbul ignore next */ 9007199254740991;
// Max safe segment length for coercion.
const MAX_SAFE_COMPONENT_LENGTH = 16;
// Max safe length for a build identifier. The max length minus 6 characters for
// the shortest version with a build 0.0.0+BUILD.
const MAX_SAFE_BUILD_LENGTH = MAX_LENGTH - 6;
const RELEASE_TYPES = [
    "major",
    "premajor",
    "minor",
    "preminor",
    "patch",
    "prepatch",
    "prerelease"
];
module.exports = {
    MAX_LENGTH,
    MAX_SAFE_COMPONENT_LENGTH,
    MAX_SAFE_BUILD_LENGTH,
    MAX_SAFE_INTEGER,
    RELEASE_TYPES,
    SEMVER_SPEC_VERSION,
    FLAG_INCLUDE_PRERELEASE: 1,
    FLAG_LOOSE: 2
};


/***/ }),

/***/ 61654:
/***/ ((module) => {

"use strict";

const debug = typeof process === "object" && process.env && process.env.NODE_DEBUG && /\bsemver\b/i.test(process.env.NODE_DEBUG) ? (...args)=>console.error("SEMVER", ...args) : ()=>{};
module.exports = debug;


/***/ }),

/***/ 59836:
/***/ ((module) => {

"use strict";

const numeric = /^[0-9]+$/;
const compareIdentifiers = (a, b)=>{
    const anum = numeric.test(a);
    const bnum = numeric.test(b);
    if (anum && bnum) {
        a = +a;
        b = +b;
    }
    return a === b ? 0 : anum && !bnum ? -1 : bnum && !anum ? 1 : a < b ? -1 : 1;
};
const rcompareIdentifiers = (a, b)=>compareIdentifiers(b, a);
module.exports = {
    compareIdentifiers,
    rcompareIdentifiers
};


/***/ }),

/***/ 35734:
/***/ ((module) => {

"use strict";
// parse out just the options we care about

const looseOption = Object.freeze({
    loose: true
});
const emptyOpts = Object.freeze({});
const parseOptions = (options)=>{
    if (!options) {
        return emptyOpts;
    }
    if (typeof options !== "object") {
        return looseOption;
    }
    return options;
};
module.exports = parseOptions;


/***/ }),

/***/ 46814:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

const { MAX_SAFE_COMPONENT_LENGTH, MAX_SAFE_BUILD_LENGTH, MAX_LENGTH } = __webpack_require__(70985);
const debug = __webpack_require__(61654);
exports = module.exports = {};
// The actual regexps go on exports.re
const re = exports.re = [];
const safeRe = exports.safeRe = [];
const src = exports.src = [];
const t = exports.t = {};
let R = 0;
const LETTERDASHNUMBER = "[a-zA-Z0-9-]";
// Replace some greedy regex tokens to prevent regex dos issues. These regex are
// used internally via the safeRe object since all inputs in this library get
// normalized first to trim and collapse all extra whitespace. The original
// regexes are exported for userland consumption and lower level usage. A
// future breaking change could export the safer regex only with a note that
// all input should have extra whitespace removed.
const safeRegexReplacements = [
    [
        "\\s",
        1
    ],
    [
        "\\d",
        MAX_LENGTH
    ],
    [
        LETTERDASHNUMBER,
        MAX_SAFE_BUILD_LENGTH
    ]
];
const makeSafeRegex = (value)=>{
    for (const [token, max] of safeRegexReplacements){
        value = value.split(`${token}*`).join(`${token}{0,${max}}`).split(`${token}+`).join(`${token}{1,${max}}`);
    }
    return value;
};
const createToken = (name, value, isGlobal)=>{
    const safe = makeSafeRegex(value);
    const index = R++;
    debug(name, index, value);
    t[name] = index;
    src[index] = value;
    re[index] = new RegExp(value, isGlobal ? "g" : undefined);
    safeRe[index] = new RegExp(safe, isGlobal ? "g" : undefined);
};
// The following Regular Expressions can be used for tokenizing,
// validating, and parsing SemVer version strings.
// ## Numeric Identifier
// A single `0`, or a non-zero digit followed by zero or more digits.
createToken("NUMERICIDENTIFIER", "0|[1-9]\\d*");
createToken("NUMERICIDENTIFIERLOOSE", "\\d+");
// ## Non-numeric Identifier
// Zero or more digits, followed by a letter or hyphen, and then zero or
// more letters, digits, or hyphens.
createToken("NONNUMERICIDENTIFIER", `\\d*[a-zA-Z-]${LETTERDASHNUMBER}*`);
// ## Main Version
// Three dot-separated numeric identifiers.
createToken("MAINVERSION", `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})\\.` + `(${src[t.NUMERICIDENTIFIER]})`);
createToken("MAINVERSIONLOOSE", `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})\\.` + `(${src[t.NUMERICIDENTIFIERLOOSE]})`);
// ## Pre-release Version Identifier
// A numeric identifier, or a non-numeric identifier.
createToken("PRERELEASEIDENTIFIER", `(?:${src[t.NUMERICIDENTIFIER]}|${src[t.NONNUMERICIDENTIFIER]})`);
createToken("PRERELEASEIDENTIFIERLOOSE", `(?:${src[t.NUMERICIDENTIFIERLOOSE]}|${src[t.NONNUMERICIDENTIFIER]})`);
// ## Pre-release Version
// Hyphen, followed by one or more dot-separated pre-release version
// identifiers.
createToken("PRERELEASE", `(?:-(${src[t.PRERELEASEIDENTIFIER]}(?:\\.${src[t.PRERELEASEIDENTIFIER]})*))`);
createToken("PRERELEASELOOSE", `(?:-?(${src[t.PRERELEASEIDENTIFIERLOOSE]}(?:\\.${src[t.PRERELEASEIDENTIFIERLOOSE]})*))`);
// ## Build Metadata Identifier
// Any combination of digits, letters, or hyphens.
createToken("BUILDIDENTIFIER", `${LETTERDASHNUMBER}+`);
// ## Build Metadata
// Plus sign, followed by one or more period-separated build metadata
// identifiers.
createToken("BUILD", `(?:\\+(${src[t.BUILDIDENTIFIER]}(?:\\.${src[t.BUILDIDENTIFIER]})*))`);
// ## Full Version String
// A main version, followed optionally by a pre-release version and
// build metadata.
// Note that the only major, minor, patch, and pre-release sections of
// the version string are capturing groups.  The build metadata is not a
// capturing group, because it should not ever be used in version
// comparison.
createToken("FULLPLAIN", `v?${src[t.MAINVERSION]}${src[t.PRERELEASE]}?${src[t.BUILD]}?`);
createToken("FULL", `^${src[t.FULLPLAIN]}$`);
// like full, but allows v1.2.3 and =1.2.3, which people do sometimes.
// also, 1.0.0alpha1 (prerelease without the hyphen) which is pretty
// common in the npm registry.
createToken("LOOSEPLAIN", `[v=\\s]*${src[t.MAINVERSIONLOOSE]}${src[t.PRERELEASELOOSE]}?${src[t.BUILD]}?`);
createToken("LOOSE", `^${src[t.LOOSEPLAIN]}$`);
createToken("GTLT", "((?:<|>)?=?)");
// Something like "2.*" or "1.2.x".
// Note that "x.x" is a valid xRange identifer, meaning "any version"
// Only the first item is strictly required.
createToken("XRANGEIDENTIFIERLOOSE", `${src[t.NUMERICIDENTIFIERLOOSE]}|x|X|\\*`);
createToken("XRANGEIDENTIFIER", `${src[t.NUMERICIDENTIFIER]}|x|X|\\*`);
createToken("XRANGEPLAIN", `[v=\\s]*(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:\\.(${src[t.XRANGEIDENTIFIER]})` + `(?:${src[t.PRERELEASE]})?${src[t.BUILD]}?` + `)?)?`);
createToken("XRANGEPLAINLOOSE", `[v=\\s]*(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:\\.(${src[t.XRANGEIDENTIFIERLOOSE]})` + `(?:${src[t.PRERELEASELOOSE]})?${src[t.BUILD]}?` + `)?)?`);
createToken("XRANGE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAIN]}$`);
createToken("XRANGELOOSE", `^${src[t.GTLT]}\\s*${src[t.XRANGEPLAINLOOSE]}$`);
// Coercion.
// Extract anything that could conceivably be a part of a valid semver
createToken("COERCE", `${"(^|[^\\d])" + "(\\d{1,"}${MAX_SAFE_COMPONENT_LENGTH}})` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:\\.(\\d{1,${MAX_SAFE_COMPONENT_LENGTH}}))?` + `(?:$|[^\\d])`);
createToken("COERCERTL", src[t.COERCE], true);
// Tilde ranges.
// Meaning is "reasonably at or greater than"
createToken("LONETILDE", "(?:~>?)");
createToken("TILDETRIM", `(\\s*)${src[t.LONETILDE]}\\s+`, true);
exports.tildeTrimReplace = "$1~";
createToken("TILDE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAIN]}$`);
createToken("TILDELOOSE", `^${src[t.LONETILDE]}${src[t.XRANGEPLAINLOOSE]}$`);
// Caret ranges.
// Meaning is "at least and backwards compatible with"
createToken("LONECARET", "(?:\\^)");
createToken("CARETTRIM", `(\\s*)${src[t.LONECARET]}\\s+`, true);
exports.caretTrimReplace = "$1^";
createToken("CARET", `^${src[t.LONECARET]}${src[t.XRANGEPLAIN]}$`);
createToken("CARETLOOSE", `^${src[t.LONECARET]}${src[t.XRANGEPLAINLOOSE]}$`);
// A simple gt/lt/eq thing, or just "" to indicate "any version"
createToken("COMPARATORLOOSE", `^${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]})$|^$`);
createToken("COMPARATOR", `^${src[t.GTLT]}\\s*(${src[t.FULLPLAIN]})$|^$`);
// An expression to strip any whitespace between the gtlt and the thing
// it modifies, so that `> 1.2.3` ==> `>1.2.3`
createToken("COMPARATORTRIM", `(\\s*)${src[t.GTLT]}\\s*(${src[t.LOOSEPLAIN]}|${src[t.XRANGEPLAIN]})`, true);
exports.comparatorTrimReplace = "$1$2$3";
// Something like `1.2.3 - 1.2.4`
// Note that these all use the loose form, because they'll be
// checked against either the strict or loose comparator form
// later.
createToken("HYPHENRANGE", `^\\s*(${src[t.XRANGEPLAIN]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAIN]})` + `\\s*$`);
createToken("HYPHENRANGELOOSE", `^\\s*(${src[t.XRANGEPLAINLOOSE]})` + `\\s+-\\s+` + `(${src[t.XRANGEPLAINLOOSE]})` + `\\s*$`);
// Star ranges basically just allow anything at all.
createToken("STAR", "(<|>)?=?\\s*\\*");
// >=0.0.0 is like a star
createToken("GTE0", "^\\s*>=\\s*0\\.0\\.0\\s*$");
createToken("GTE0PRE", "^\\s*>=\\s*0\\.0\\.0-0\\s*$");


/***/ }),

/***/ 68599:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// Determine if version is greater than all the versions possible in the range.

const outside = __webpack_require__(2766);
const gtr = (version, range, options)=>outside(version, range, ">", options);
module.exports = gtr;


/***/ }),

/***/ 51943:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Range = __webpack_require__(41265);
const intersects = (r1, r2, options)=>{
    r1 = new Range(r1, options);
    r2 = new Range(r2, options);
    return r1.intersects(r2, options);
};
module.exports = intersects;


/***/ }),

/***/ 66631:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const outside = __webpack_require__(2766);
// Determine if version is less than all the versions possible in the range
const ltr = (version, range, options)=>outside(version, range, "<", options);
module.exports = ltr;


/***/ }),

/***/ 32157:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SemVer = __webpack_require__(63938);
const Range = __webpack_require__(41265);
const maxSatisfying = (versions, range, options)=>{
    let max = null;
    let maxSV = null;
    let rangeObj = null;
    try {
        rangeObj = new Range(range, options);
    } catch (er) {
        return null;
    }
    versions.forEach((v)=>{
        if (rangeObj.test(v)) {
            // satisfies(v, range, options)
            if (!max || maxSV.compare(v) === -1) {
                // compare(max, v, true)
                max = v;
                maxSV = new SemVer(max, options);
            }
        }
    });
    return max;
};
module.exports = maxSatisfying;


/***/ }),

/***/ 60297:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SemVer = __webpack_require__(63938);
const Range = __webpack_require__(41265);
const minSatisfying = (versions, range, options)=>{
    let min = null;
    let minSV = null;
    let rangeObj = null;
    try {
        rangeObj = new Range(range, options);
    } catch (er) {
        return null;
    }
    versions.forEach((v)=>{
        if (rangeObj.test(v)) {
            // satisfies(v, range, options)
            if (!min || minSV.compare(v) === 1) {
                // compare(min, v, true)
                min = v;
                minSV = new SemVer(min, options);
            }
        }
    });
    return min;
};
module.exports = minSatisfying;


/***/ }),

/***/ 59013:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SemVer = __webpack_require__(63938);
const Range = __webpack_require__(41265);
const gt = __webpack_require__(96009);
const minVersion = (range, loose)=>{
    range = new Range(range, loose);
    let minver = new SemVer("0.0.0");
    if (range.test(minver)) {
        return minver;
    }
    minver = new SemVer("0.0.0-0");
    if (range.test(minver)) {
        return minver;
    }
    minver = null;
    for(let i = 0; i < range.set.length; ++i){
        const comparators = range.set[i];
        let setMin = null;
        comparators.forEach((comparator)=>{
            // Clone to avoid manipulating the comparator's semver object.
            const compver = new SemVer(comparator.semver.version);
            switch(comparator.operator){
                case ">":
                    if (compver.prerelease.length === 0) {
                        compver.patch++;
                    } else {
                        compver.prerelease.push(0);
                    }
                    compver.raw = compver.format();
                /* fallthrough */ case "":
                case ">=":
                    if (!setMin || gt(compver, setMin)) {
                        setMin = compver;
                    }
                    break;
                case "<":
                case "<=":
                    break;
                /* istanbul ignore next */ default:
                    throw new Error(`Unexpected operation: ${comparator.operator}`);
            }
        });
        if (setMin && (!minver || gt(minver, setMin))) {
            minver = setMin;
        }
    }
    if (minver && range.test(minver)) {
        return minver;
    }
    return null;
};
module.exports = minVersion;


/***/ }),

/***/ 2766:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const SemVer = __webpack_require__(63938);
const Comparator = __webpack_require__(93153);
const { ANY } = Comparator;
const Range = __webpack_require__(41265);
const satisfies = __webpack_require__(84580);
const gt = __webpack_require__(96009);
const lt = __webpack_require__(19759);
const lte = __webpack_require__(17056);
const gte = __webpack_require__(89468);
const outside = (version, range, hilo, options)=>{
    version = new SemVer(version, options);
    range = new Range(range, options);
    let gtfn, ltefn, ltfn, comp, ecomp;
    switch(hilo){
        case ">":
            gtfn = gt;
            ltefn = lte;
            ltfn = lt;
            comp = ">";
            ecomp = ">=";
            break;
        case "<":
            gtfn = lt;
            ltefn = gte;
            ltfn = gt;
            comp = "<";
            ecomp = "<=";
            break;
        default:
            throw new TypeError('Must provide a hilo val of "<" or ">"');
    }
    // If it satisfies the range it is not outside
    if (satisfies(version, range, options)) {
        return false;
    }
    // From now on, variable terms are as if we're in "gtr" mode.
    // but note that everything is flipped for the "ltr" function.
    for(let i = 0; i < range.set.length; ++i){
        const comparators = range.set[i];
        let high = null;
        let low = null;
        comparators.forEach((comparator)=>{
            if (comparator.semver === ANY) {
                comparator = new Comparator(">=0.0.0");
            }
            high = high || comparator;
            low = low || comparator;
            if (gtfn(comparator.semver, high.semver, options)) {
                high = comparator;
            } else if (ltfn(comparator.semver, low.semver, options)) {
                low = comparator;
            }
        });
        // If the edge version comparator has a operator then our version
        // isn't outside it
        if (high.operator === comp || high.operator === ecomp) {
            return false;
        }
        // If the lowest version comparator has an operator and our version
        // is less than it then it isn't higher than the range
        if ((!low.operator || low.operator === comp) && ltefn(version, low.semver)) {
            return false;
        } else if (low.operator === ecomp && ltfn(version, low.semver)) {
            return false;
        }
    }
    return true;
};
module.exports = outside;


/***/ }),

/***/ 90166:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// given a set of versions and a range, create a "simplified" range
// that includes the same versions that the original range does
// If the original range is shorter than the simplified one, return that.

const satisfies = __webpack_require__(84580);
const compare = __webpack_require__(84497);
module.exports = (versions, range, options)=>{
    const set = [];
    let first = null;
    let prev = null;
    const v = versions.sort((a, b)=>compare(a, b, options));
    for (const version of v){
        const included = satisfies(version, range, options);
        if (included) {
            prev = version;
            if (!first) {
                first = version;
            }
        } else {
            if (prev) {
                set.push([
                    first,
                    prev
                ]);
            }
            prev = null;
            first = null;
        }
    }
    if (first) {
        set.push([
            first,
            null
        ]);
    }
    const ranges = [];
    for (const [min, max] of set){
        if (min === max) {
            ranges.push(min);
        } else if (!max && min === v[0]) {
            ranges.push("*");
        } else if (!max) {
            ranges.push(`>=${min}`);
        } else if (min === v[0]) {
            ranges.push(`<=${max}`);
        } else {
            ranges.push(`${min} - ${max}`);
        }
    }
    const simplified = ranges.join(" || ");
    const original = typeof range.raw === "string" ? range.raw : String(range);
    return simplified.length < original.length ? simplified : range;
};


/***/ }),

/***/ 11991:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Range = __webpack_require__(41265);
const Comparator = __webpack_require__(93153);
const { ANY } = Comparator;
const satisfies = __webpack_require__(84580);
const compare = __webpack_require__(84497);
// Complex range `r1 || r2 || ...` is a subset of `R1 || R2 || ...` iff:
// - Every simple range `r1, r2, ...` is a null set, OR
// - Every simple range `r1, r2, ...` which is not a null set is a subset of
//   some `R1, R2, ...`
//
// Simple range `c1 c2 ...` is a subset of simple range `C1 C2 ...` iff:
// - If c is only the ANY comparator
//   - If C is only the ANY comparator, return true
//   - Else if in prerelease mode, return false
//   - else replace c with `[>=0.0.0]`
// - If C is only the ANY comparator
//   - if in prerelease mode, return true
//   - else replace C with `[>=0.0.0]`
// - Let EQ be the set of = comparators in c
// - If EQ is more than one, return true (null set)
// - Let GT be the highest > or >= comparator in c
// - Let LT be the lowest < or <= comparator in c
// - If GT and LT, and GT.semver > LT.semver, return true (null set)
// - If any C is a = range, and GT or LT are set, return false
// - If EQ
//   - If GT, and EQ does not satisfy GT, return true (null set)
//   - If LT, and EQ does not satisfy LT, return true (null set)
//   - If EQ satisfies every C, return true
//   - Else return false
// - If GT
//   - If GT.semver is lower than any > or >= comp in C, return false
//   - If GT is >=, and GT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the GT.semver tuple, return false
// - If LT
//   - If LT.semver is greater than any < or <= comp in C, return false
//   - If LT is <=, and LT.semver does not satisfy every C, return false
//   - If GT.semver has a prerelease, and not in prerelease mode
//     - If no C has a prerelease and the LT.semver tuple, return false
// - Else return true
const subset = (sub, dom, options = {})=>{
    if (sub === dom) {
        return true;
    }
    sub = new Range(sub, options);
    dom = new Range(dom, options);
    let sawNonNull = false;
    OUTER: for (const simpleSub of sub.set){
        for (const simpleDom of dom.set){
            const isSub = simpleSubset(simpleSub, simpleDom, options);
            sawNonNull = sawNonNull || isSub !== null;
            if (isSub) {
                continue OUTER;
            }
        }
        // the null set is a subset of everything, but null simple ranges in
        // a complex range should be ignored.  so if we saw a non-null range,
        // then we know this isn't a subset, but if EVERY simple range was null,
        // then it is a subset.
        if (sawNonNull) {
            return false;
        }
    }
    return true;
};
const minimumVersionWithPreRelease = [
    new Comparator(">=0.0.0-0")
];
const minimumVersion = [
    new Comparator(">=0.0.0")
];
const simpleSubset = (sub, dom, options)=>{
    if (sub === dom) {
        return true;
    }
    if (sub.length === 1 && sub[0].semver === ANY) {
        if (dom.length === 1 && dom[0].semver === ANY) {
            return true;
        } else if (options.includePrerelease) {
            sub = minimumVersionWithPreRelease;
        } else {
            sub = minimumVersion;
        }
    }
    if (dom.length === 1 && dom[0].semver === ANY) {
        if (options.includePrerelease) {
            return true;
        } else {
            dom = minimumVersion;
        }
    }
    const eqSet = new Set();
    let gt, lt;
    for (const c of sub){
        if (c.operator === ">" || c.operator === ">=") {
            gt = higherGT(gt, c, options);
        } else if (c.operator === "<" || c.operator === "<=") {
            lt = lowerLT(lt, c, options);
        } else {
            eqSet.add(c.semver);
        }
    }
    if (eqSet.size > 1) {
        return null;
    }
    let gtltComp;
    if (gt && lt) {
        gtltComp = compare(gt.semver, lt.semver, options);
        if (gtltComp > 0) {
            return null;
        } else if (gtltComp === 0 && (gt.operator !== ">=" || lt.operator !== "<=")) {
            return null;
        }
    }
    // will iterate one or zero times
    for (const eq of eqSet){
        if (gt && !satisfies(eq, String(gt), options)) {
            return null;
        }
        if (lt && !satisfies(eq, String(lt), options)) {
            return null;
        }
        for (const c of dom){
            if (!satisfies(eq, String(c), options)) {
                return false;
            }
        }
        return true;
    }
    let higher, lower;
    let hasDomLT, hasDomGT;
    // if the subset has a prerelease, we need a comparator in the superset
    // with the same tuple and a prerelease, or it's not a subset
    let needDomLTPre = lt && !options.includePrerelease && lt.semver.prerelease.length ? lt.semver : false;
    let needDomGTPre = gt && !options.includePrerelease && gt.semver.prerelease.length ? gt.semver : false;
    // exception: <1.2.3-0 is the same as <1.2.3
    if (needDomLTPre && needDomLTPre.prerelease.length === 1 && lt.operator === "<" && needDomLTPre.prerelease[0] === 0) {
        needDomLTPre = false;
    }
    for (const c of dom){
        hasDomGT = hasDomGT || c.operator === ">" || c.operator === ">=";
        hasDomLT = hasDomLT || c.operator === "<" || c.operator === "<=";
        if (gt) {
            if (needDomGTPre) {
                if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomGTPre.major && c.semver.minor === needDomGTPre.minor && c.semver.patch === needDomGTPre.patch) {
                    needDomGTPre = false;
                }
            }
            if (c.operator === ">" || c.operator === ">=") {
                higher = higherGT(gt, c, options);
                if (higher === c && higher !== gt) {
                    return false;
                }
            } else if (gt.operator === ">=" && !satisfies(gt.semver, String(c), options)) {
                return false;
            }
        }
        if (lt) {
            if (needDomLTPre) {
                if (c.semver.prerelease && c.semver.prerelease.length && c.semver.major === needDomLTPre.major && c.semver.minor === needDomLTPre.minor && c.semver.patch === needDomLTPre.patch) {
                    needDomLTPre = false;
                }
            }
            if (c.operator === "<" || c.operator === "<=") {
                lower = lowerLT(lt, c, options);
                if (lower === c && lower !== lt) {
                    return false;
                }
            } else if (lt.operator === "<=" && !satisfies(lt.semver, String(c), options)) {
                return false;
            }
        }
        if (!c.operator && (lt || gt) && gtltComp !== 0) {
            return false;
        }
    }
    // if there was a < or >, and nothing in the dom, then must be false
    // UNLESS it was limited by another range in the other direction.
    // Eg, >1.0.0 <1.0.1 is still a subset of <2.0.0
    if (gt && hasDomLT && !lt && gtltComp !== 0) {
        return false;
    }
    if (lt && hasDomGT && !gt && gtltComp !== 0) {
        return false;
    }
    // we needed a prerelease range in a specific tuple, but didn't get one
    // then this isn't a subset.  eg >=1.2.3-pre is not a subset of >=1.0.0,
    // because it includes prereleases in the 1.2.3 tuple
    if (needDomGTPre || needDomLTPre) {
        return false;
    }
    return true;
};
// >=1.2.3 is lower than >1.2.3
const higherGT = (a, b, options)=>{
    if (!a) {
        return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp > 0 ? a : comp < 0 ? b : b.operator === ">" && a.operator === ">=" ? b : a;
};
// <=1.2.3 is higher than <1.2.3
const lowerLT = (a, b, options)=>{
    if (!a) {
        return b;
    }
    const comp = compare(a.semver, b.semver, options);
    return comp < 0 ? a : comp > 0 ? b : b.operator === "<" && a.operator === "<=" ? b : a;
};
module.exports = subset;


/***/ }),

/***/ 71974:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Range = __webpack_require__(41265);
// Mostly just for testing and legacy API reasons
const toComparators = (range, options)=>new Range(range, options).set.map((comp)=>comp.map((c)=>c.value).join(" ").trim().split(" "));
module.exports = toComparators;


/***/ }),

/***/ 27312:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Range = __webpack_require__(41265);
const validRange = (range, options)=>{
    try {
        // Return '*' instead of '' so that truthiness works.
        // This will throw if it's invalid anyway
        return new Range(range, options).range || "*";
    } catch (er) {
        return null;
    }
};
module.exports = validRange;


/***/ }),

/***/ 97105:
/***/ ((module) => {

"use strict";

module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function*() {
        for(let walker = this.head; walker; walker = walker.next){
            yield walker.value;
        }
    };
};


/***/ }),

/***/ 5882:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Yallist;
Yallist.Node = Node;
Yallist.create = Yallist;
function Yallist(list) {
    var self = this;
    if (!(self instanceof Yallist)) {
        self = new Yallist();
    }
    self.tail = null;
    self.head = null;
    self.length = 0;
    if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
            self.push(item);
        });
    } else if (arguments.length > 0) {
        for(var i = 0, l = arguments.length; i < l; i++){
            self.push(arguments[i]);
        }
    }
    return self;
}
Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
        next.prev = prev;
    }
    if (prev) {
        prev.next = next;
    }
    if (node === this.head) {
        this.head = next;
    }
    if (node === this.tail) {
        this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
};
Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
        return;
    }
    if (node.list) {
        node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
        head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
        this.tail = node;
    }
    this.length++;
};
Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
        return;
    }
    if (node.list) {
        node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
        tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
        this.head = node;
    }
    this.length++;
};
Yallist.prototype.push = function() {
    for(var i = 0, l = arguments.length; i < l; i++){
        push(this, arguments[i]);
    }
    return this.length;
};
Yallist.prototype.unshift = function() {
    for(var i = 0, l = arguments.length; i < l; i++){
        unshift(this, arguments[i]);
    }
    return this.length;
};
Yallist.prototype.pop = function() {
    if (!this.tail) {
        return undefined;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
        this.tail.next = null;
    } else {
        this.head = null;
    }
    this.length--;
    return res;
};
Yallist.prototype.shift = function() {
    if (!this.head) {
        return undefined;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
        this.head.prev = null;
    } else {
        this.tail = null;
    }
    this.length--;
    return res;
};
Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for(var walker = this.head, i = 0; walker !== null; i++){
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
    }
};
Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for(var walker = this.tail, i = this.length - 1; walker !== null; i--){
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
    }
};
Yallist.prototype.get = function(n) {
    for(var i = 0, walker = this.head; walker !== null && i < n; i++){
        // abort out of the list early if we hit a cycle
        walker = walker.next;
    }
    if (i === n && walker !== null) {
        return walker.value;
    }
};
Yallist.prototype.getReverse = function(n) {
    for(var i = 0, walker = this.tail; walker !== null && i < n; i++){
        // abort out of the list early if we hit a cycle
        walker = walker.prev;
    }
    if (i === n && walker !== null) {
        return walker.value;
    }
};
Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for(var walker = this.head; walker !== null;){
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
    }
    return res;
};
Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for(var walker = this.tail; walker !== null;){
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
    }
    return res;
};
Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
        acc = initial;
    } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
    } else {
        throw new TypeError("Reduce of empty list with no initial value");
    }
    for(var i = 0; walker !== null; i++){
        acc = fn(acc, walker.value, i);
        walker = walker.next;
    }
    return acc;
};
Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
        acc = initial;
    } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
    } else {
        throw new TypeError("Reduce of empty list with no initial value");
    }
    for(var i = this.length - 1; walker !== null; i--){
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
    }
    return acc;
};
Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for(var i = 0, walker = this.head; walker !== null; i++){
        arr[i] = walker.value;
        walker = walker.next;
    }
    return arr;
};
Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for(var i = 0, walker = this.tail; walker !== null; i++){
        arr[i] = walker.value;
        walker = walker.prev;
    }
    return arr;
};
Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
        to += this.length;
    }
    from = from || 0;
    if (from < 0) {
        from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
        return ret;
    }
    if (from < 0) {
        from = 0;
    }
    if (to > this.length) {
        to = this.length;
    }
    for(var i = 0, walker = this.head; walker !== null && i < from; i++){
        walker = walker.next;
    }
    for(; walker !== null && i < to; i++, walker = walker.next){
        ret.push(walker.value);
    }
    return ret;
};
Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
        to += this.length;
    }
    from = from || 0;
    if (from < 0) {
        from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
        return ret;
    }
    if (from < 0) {
        from = 0;
    }
    if (to > this.length) {
        to = this.length;
    }
    for(var i = this.length, walker = this.tail; walker !== null && i > to; i--){
        walker = walker.prev;
    }
    for(; walker !== null && i > from; i--, walker = walker.prev){
        ret.push(walker.value);
    }
    return ret;
};
Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
        start = this.length - 1;
    }
    if (start < 0) {
        start = this.length + start;
    }
    for(var i = 0, walker = this.head; walker !== null && i < start; i++){
        walker = walker.next;
    }
    var ret = [];
    for(var i = 0; walker && i < deleteCount; i++){
        ret.push(walker.value);
        walker = this.removeNode(walker);
    }
    if (walker === null) {
        walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
    }
    for(var i = 0; i < nodes.length; i++){
        walker = insert(this, walker, nodes[i]);
    }
    return ret;
};
Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for(var walker = head; walker !== null; walker = walker.prev){
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
};
function insert(self, node, value) {
    var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
    if (inserted.next === null) {
        self.tail = inserted;
    }
    if (inserted.prev === null) {
        self.head = inserted;
    }
    self.length++;
    return inserted;
}
function push(self, item) {
    self.tail = new Node(item, self.tail, null, self);
    if (!self.head) {
        self.head = self.tail;
    }
    self.length++;
}
function unshift(self, item) {
    self.head = new Node(item, null, self.head, self);
    if (!self.tail) {
        self.tail = self.head;
    }
    self.length++;
}
function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
        prev.next = this;
        this.prev = prev;
    } else {
        this.prev = null;
    }
    if (next) {
        next.prev = this;
        this.next = next;
    } else {
        this.next = null;
    }
}
try {
    // add if support for Symbol.iterator is present
    __webpack_require__(97105)(Yallist);
} catch (er) {}


/***/ }),

/***/ 88855:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const timespan = __webpack_require__(60130);
const PS_SUPPORTED = __webpack_require__(65906);
const validateAsymmetricKey = __webpack_require__(19740);
const jws = __webpack_require__(91750);
const includes = __webpack_require__(58174);
const isBoolean = __webpack_require__(14647);
const isInteger = __webpack_require__(61811);
const isNumber = __webpack_require__(11631);
const isPlainObject = __webpack_require__(59135);
const isString = __webpack_require__(12304);
const once = __webpack_require__(571);
const { KeyObject, createSecretKey, createPrivateKey } = __webpack_require__(6113);
const SUPPORTED_ALGS = [
    "RS256",
    "RS384",
    "RS512",
    "ES256",
    "ES384",
    "ES512",
    "HS256",
    "HS384",
    "HS512",
    "none"
];
if (PS_SUPPORTED) {
    SUPPORTED_ALGS.splice(3, 0, "PS256", "PS384", "PS512");
}
const sign_options_schema = {
    expiresIn: {
        isValid: function(value) {
            return isInteger(value) || isString(value) && value;
        },
        message: '"expiresIn" should be a number of seconds or string representing a timespan'
    },
    notBefore: {
        isValid: function(value) {
            return isInteger(value) || isString(value) && value;
        },
        message: '"notBefore" should be a number of seconds or string representing a timespan'
    },
    audience: {
        isValid: function(value) {
            return isString(value) || Array.isArray(value);
        },
        message: '"audience" must be a string or array'
    },
    algorithm: {
        isValid: includes.bind(null, SUPPORTED_ALGS),
        message: '"algorithm" must be a valid string enum value'
    },
    header: {
        isValid: isPlainObject,
        message: '"header" must be an object'
    },
    encoding: {
        isValid: isString,
        message: '"encoding" must be a string'
    },
    issuer: {
        isValid: isString,
        message: '"issuer" must be a string'
    },
    subject: {
        isValid: isString,
        message: '"subject" must be a string'
    },
    jwtid: {
        isValid: isString,
        message: '"jwtid" must be a string'
    },
    noTimestamp: {
        isValid: isBoolean,
        message: '"noTimestamp" must be a boolean'
    },
    keyid: {
        isValid: isString,
        message: '"keyid" must be a string'
    },
    mutatePayload: {
        isValid: isBoolean,
        message: '"mutatePayload" must be a boolean'
    },
    allowInsecureKeySizes: {
        isValid: isBoolean,
        message: '"allowInsecureKeySizes" must be a boolean'
    },
    allowInvalidAsymmetricKeyTypes: {
        isValid: isBoolean,
        message: '"allowInvalidAsymmetricKeyTypes" must be a boolean'
    }
};
const registered_claims_schema = {
    iat: {
        isValid: isNumber,
        message: '"iat" should be a number of seconds'
    },
    exp: {
        isValid: isNumber,
        message: '"exp" should be a number of seconds'
    },
    nbf: {
        isValid: isNumber,
        message: '"nbf" should be a number of seconds'
    }
};
function validate(schema, allowUnknown, object, parameterName) {
    if (!isPlainObject(object)) {
        throw new Error('Expected "' + parameterName + '" to be a plain object.');
    }
    Object.keys(object).forEach(function(key) {
        const validator = schema[key];
        if (!validator) {
            if (!allowUnknown) {
                throw new Error('"' + key + '" is not allowed in "' + parameterName + '"');
            }
            return;
        }
        if (!validator.isValid(object[key])) {
            throw new Error(validator.message);
        }
    });
}
function validateOptions(options) {
    return validate(sign_options_schema, false, options, "options");
}
function validatePayload(payload) {
    return validate(registered_claims_schema, true, payload, "payload");
}
const options_to_payload = {
    "audience": "aud",
    "issuer": "iss",
    "subject": "sub",
    "jwtid": "jti"
};
const options_for_objects = [
    "expiresIn",
    "notBefore",
    "noTimestamp",
    "audience",
    "issuer",
    "subject",
    "jwtid"
];
module.exports = function(payload, secretOrPrivateKey, options, callback) {
    if (typeof options === "function") {
        callback = options;
        options = {};
    } else {
        options = options || {};
    }
    const isObjectPayload = typeof payload === "object" && !Buffer.isBuffer(payload);
    const header = Object.assign({
        alg: options.algorithm || "HS256",
        typ: isObjectPayload ? "JWT" : undefined,
        kid: options.keyid
    }, options.header);
    function failure(err) {
        if (callback) {
            return callback(err);
        }
        throw err;
    }
    if (!secretOrPrivateKey && options.algorithm !== "none") {
        return failure(new Error("secretOrPrivateKey must have a value"));
    }
    if (secretOrPrivateKey != null && !(secretOrPrivateKey instanceof KeyObject)) {
        try {
            secretOrPrivateKey = createPrivateKey(secretOrPrivateKey);
        } catch (_) {
            try {
                secretOrPrivateKey = createSecretKey(typeof secretOrPrivateKey === "string" ? Buffer.from(secretOrPrivateKey) : secretOrPrivateKey);
            } catch (_) {
                return failure(new Error("secretOrPrivateKey is not valid key material"));
            }
        }
    }
    if (header.alg.startsWith("HS") && secretOrPrivateKey.type !== "secret") {
        return failure(new Error(`secretOrPrivateKey must be a symmetric key when using ${header.alg}`));
    } else if (/^(?:RS|PS|ES)/.test(header.alg)) {
        if (secretOrPrivateKey.type !== "private") {
            return failure(new Error(`secretOrPrivateKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInsecureKeySizes && !header.alg.startsWith("ES") && secretOrPrivateKey.asymmetricKeyDetails !== undefined && //KeyObject.asymmetricKeyDetails is supported in Node 15+
        secretOrPrivateKey.asymmetricKeyDetails.modulusLength < 2048) {
            return failure(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
        }
    }
    if (typeof payload === "undefined") {
        return failure(new Error("payload is required"));
    } else if (isObjectPayload) {
        try {
            validatePayload(payload);
        } catch (error) {
            return failure(error);
        }
        if (!options.mutatePayload) {
            payload = Object.assign({}, payload);
        }
    } else {
        const invalid_options = options_for_objects.filter(function(opt) {
            return typeof options[opt] !== "undefined";
        });
        if (invalid_options.length > 0) {
            return failure(new Error("invalid " + invalid_options.join(",") + " option for " + typeof payload + " payload"));
        }
    }
    if (typeof payload.exp !== "undefined" && typeof options.expiresIn !== "undefined") {
        return failure(new Error('Bad "options.expiresIn" option the payload already has an "exp" property.'));
    }
    if (typeof payload.nbf !== "undefined" && typeof options.notBefore !== "undefined") {
        return failure(new Error('Bad "options.notBefore" option the payload already has an "nbf" property.'));
    }
    try {
        validateOptions(options);
    } catch (error) {
        return failure(error);
    }
    if (!options.allowInvalidAsymmetricKeyTypes) {
        try {
            validateAsymmetricKey(header.alg, secretOrPrivateKey);
        } catch (error) {
            return failure(error);
        }
    }
    const timestamp = payload.iat || Math.floor(Date.now() / 1000);
    if (options.noTimestamp) {
        delete payload.iat;
    } else if (isObjectPayload) {
        payload.iat = timestamp;
    }
    if (typeof options.notBefore !== "undefined") {
        try {
            payload.nbf = timespan(options.notBefore, timestamp);
        } catch (err) {
            return failure(err);
        }
        if (typeof payload.nbf === "undefined") {
            return failure(new Error('"notBefore" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
    }
    if (typeof options.expiresIn !== "undefined" && typeof payload === "object") {
        try {
            payload.exp = timespan(options.expiresIn, timestamp);
        } catch (err) {
            return failure(err);
        }
        if (typeof payload.exp === "undefined") {
            return failure(new Error('"expiresIn" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
        }
    }
    Object.keys(options_to_payload).forEach(function(key) {
        const claim = options_to_payload[key];
        if (typeof options[key] !== "undefined") {
            if (typeof payload[claim] !== "undefined") {
                return failure(new Error('Bad "options.' + key + '" option. The payload already has an "' + claim + '" property.'));
            }
            payload[claim] = options[key];
        }
    });
    const encoding = options.encoding || "utf8";
    if (typeof callback === "function") {
        callback = callback && once(callback);
        jws.createSign({
            header: header,
            privateKey: secretOrPrivateKey,
            payload: payload,
            encoding: encoding
        }).once("error", callback).once("done", function(signature) {
            // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version
            if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
                return callback(new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`));
            }
            callback(null, signature);
        });
    } else {
        let signature = jws.sign({
            header: header,
            payload: payload,
            secret: secretOrPrivateKey,
            encoding: encoding
        });
        // TODO: Remove in favor of the modulus length check before signing once node 15+ is the minimum supported version
        if (!options.allowInsecureKeySizes && /^(?:RS|PS)/.test(header.alg) && signature.length < 256) {
            throw new Error(`secretOrPrivateKey has a minimum key size of 2048 bits for ${header.alg}`);
        }
        return signature;
    }
};


/***/ }),

/***/ 70496:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const JsonWebTokenError = __webpack_require__(40297);
const NotBeforeError = __webpack_require__(83008);
const TokenExpiredError = __webpack_require__(19000);
const decode = __webpack_require__(44985);
const timespan = __webpack_require__(60130);
const validateAsymmetricKey = __webpack_require__(19740);
const PS_SUPPORTED = __webpack_require__(65906);
const jws = __webpack_require__(91750);
const { KeyObject, createSecretKey, createPublicKey } = __webpack_require__(6113);
const PUB_KEY_ALGS = [
    "RS256",
    "RS384",
    "RS512"
];
const EC_KEY_ALGS = [
    "ES256",
    "ES384",
    "ES512"
];
const RSA_KEY_ALGS = [
    "RS256",
    "RS384",
    "RS512"
];
const HS_ALGS = [
    "HS256",
    "HS384",
    "HS512"
];
if (PS_SUPPORTED) {
    PUB_KEY_ALGS.splice(PUB_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
    RSA_KEY_ALGS.splice(RSA_KEY_ALGS.length, 0, "PS256", "PS384", "PS512");
}
module.exports = function(jwtString, secretOrPublicKey, options, callback) {
    if (typeof options === "function" && !callback) {
        callback = options;
        options = {};
    }
    if (!options) {
        options = {};
    }
    //clone this object since we are going to mutate it.
    options = Object.assign({}, options);
    let done;
    if (callback) {
        done = callback;
    } else {
        done = function(err, data) {
            if (err) throw err;
            return data;
        };
    }
    if (options.clockTimestamp && typeof options.clockTimestamp !== "number") {
        return done(new JsonWebTokenError("clockTimestamp must be a number"));
    }
    if (options.nonce !== undefined && (typeof options.nonce !== "string" || options.nonce.trim() === "")) {
        return done(new JsonWebTokenError("nonce must be a non-empty string"));
    }
    if (options.allowInvalidAsymmetricKeyTypes !== undefined && typeof options.allowInvalidAsymmetricKeyTypes !== "boolean") {
        return done(new JsonWebTokenError("allowInvalidAsymmetricKeyTypes must be a boolean"));
    }
    const clockTimestamp = options.clockTimestamp || Math.floor(Date.now() / 1000);
    if (!jwtString) {
        return done(new JsonWebTokenError("jwt must be provided"));
    }
    if (typeof jwtString !== "string") {
        return done(new JsonWebTokenError("jwt must be a string"));
    }
    const parts = jwtString.split(".");
    if (parts.length !== 3) {
        return done(new JsonWebTokenError("jwt malformed"));
    }
    let decodedToken;
    try {
        decodedToken = decode(jwtString, {
            complete: true
        });
    } catch (err) {
        return done(err);
    }
    if (!decodedToken) {
        return done(new JsonWebTokenError("invalid token"));
    }
    const header = decodedToken.header;
    let getSecret;
    if (typeof secretOrPublicKey === "function") {
        if (!callback) {
            return done(new JsonWebTokenError("verify must be called asynchronous if secret or public key is provided as a callback"));
        }
        getSecret = secretOrPublicKey;
    } else {
        getSecret = function(header, secretCallback) {
            return secretCallback(null, secretOrPublicKey);
        };
    }
    return getSecret(header, function(err, secretOrPublicKey) {
        if (err) {
            return done(new JsonWebTokenError("error in secret or public key callback: " + err.message));
        }
        const hasSignature = parts[2].trim() !== "";
        if (!hasSignature && secretOrPublicKey) {
            return done(new JsonWebTokenError("jwt signature is required"));
        }
        if (hasSignature && !secretOrPublicKey) {
            return done(new JsonWebTokenError("secret or public key must be provided"));
        }
        if (!hasSignature && !options.algorithms) {
            return done(new JsonWebTokenError('please specify "none" in "algorithms" to verify unsigned tokens'));
        }
        if (secretOrPublicKey != null && !(secretOrPublicKey instanceof KeyObject)) {
            try {
                secretOrPublicKey = createPublicKey(secretOrPublicKey);
            } catch (_) {
                try {
                    secretOrPublicKey = createSecretKey(typeof secretOrPublicKey === "string" ? Buffer.from(secretOrPublicKey) : secretOrPublicKey);
                } catch (_) {
                    return done(new JsonWebTokenError("secretOrPublicKey is not valid key material"));
                }
            }
        }
        if (!options.algorithms) {
            if (secretOrPublicKey.type === "secret") {
                options.algorithms = HS_ALGS;
            } else if ([
                "rsa",
                "rsa-pss"
            ].includes(secretOrPublicKey.asymmetricKeyType)) {
                options.algorithms = RSA_KEY_ALGS;
            } else if (secretOrPublicKey.asymmetricKeyType === "ec") {
                options.algorithms = EC_KEY_ALGS;
            } else {
                options.algorithms = PUB_KEY_ALGS;
            }
        }
        if (options.algorithms.indexOf(decodedToken.header.alg) === -1) {
            return done(new JsonWebTokenError("invalid algorithm"));
        }
        if (header.alg.startsWith("HS") && secretOrPublicKey.type !== "secret") {
            return done(new JsonWebTokenError(`secretOrPublicKey must be a symmetric key when using ${header.alg}`));
        } else if (/^(?:RS|PS|ES)/.test(header.alg) && secretOrPublicKey.type !== "public") {
            return done(new JsonWebTokenError(`secretOrPublicKey must be an asymmetric key when using ${header.alg}`));
        }
        if (!options.allowInvalidAsymmetricKeyTypes) {
            try {
                validateAsymmetricKey(header.alg, secretOrPublicKey);
            } catch (e) {
                return done(e);
            }
        }
        let valid;
        try {
            valid = jws.verify(jwtString, decodedToken.header.alg, secretOrPublicKey);
        } catch (e) {
            return done(e);
        }
        if (!valid) {
            return done(new JsonWebTokenError("invalid signature"));
        }
        const payload = decodedToken.payload;
        if (typeof payload.nbf !== "undefined" && !options.ignoreNotBefore) {
            if (typeof payload.nbf !== "number") {
                return done(new JsonWebTokenError("invalid nbf value"));
            }
            if (payload.nbf > clockTimestamp + (options.clockTolerance || 0)) {
                return done(new NotBeforeError("jwt not active", new Date(payload.nbf * 1000)));
            }
        }
        if (typeof payload.exp !== "undefined" && !options.ignoreExpiration) {
            if (typeof payload.exp !== "number") {
                return done(new JsonWebTokenError("invalid exp value"));
            }
            if (clockTimestamp >= payload.exp + (options.clockTolerance || 0)) {
                return done(new TokenExpiredError("jwt expired", new Date(payload.exp * 1000)));
            }
        }
        if (options.audience) {
            const audiences = Array.isArray(options.audience) ? options.audience : [
                options.audience
            ];
            const target = Array.isArray(payload.aud) ? payload.aud : [
                payload.aud
            ];
            const match = target.some(function(targetAudience) {
                return audiences.some(function(audience) {
                    return audience instanceof RegExp ? audience.test(targetAudience) : audience === targetAudience;
                });
            });
            if (!match) {
                return done(new JsonWebTokenError("jwt audience invalid. expected: " + audiences.join(" or ")));
            }
        }
        if (options.issuer) {
            const invalid_issuer = typeof options.issuer === "string" && payload.iss !== options.issuer || Array.isArray(options.issuer) && options.issuer.indexOf(payload.iss) === -1;
            if (invalid_issuer) {
                return done(new JsonWebTokenError("jwt issuer invalid. expected: " + options.issuer));
            }
        }
        if (options.subject) {
            if (payload.sub !== options.subject) {
                return done(new JsonWebTokenError("jwt subject invalid. expected: " + options.subject));
            }
        }
        if (options.jwtid) {
            if (payload.jti !== options.jwtid) {
                return done(new JsonWebTokenError("jwt jwtid invalid. expected: " + options.jwtid));
            }
        }
        if (options.nonce) {
            if (payload.nonce !== options.nonce) {
                return done(new JsonWebTokenError("jwt nonce invalid. expected: " + options.nonce));
            }
        }
        if (options.maxAge) {
            if (typeof payload.iat !== "number") {
                return done(new JsonWebTokenError("iat required when maxAge is specified"));
            }
            const maxAgeTimestamp = timespan(options.maxAge, payload.iat);
            if (typeof maxAgeTimestamp === "undefined") {
                return done(new JsonWebTokenError('"maxAge" should be a number of seconds or string representing a timespan eg: "1d", "20h", 60'));
            }
            if (clockTimestamp >= maxAgeTimestamp + (options.clockTolerance || 0)) {
                return done(new TokenExpiredError("maxAge exceeded", new Date(maxAgeTimestamp * 1000)));
            }
        }
        if (options.complete === true) {
            const signature = decodedToken.signature;
            return done(null, {
                header: header,
                payload: payload,
                signature: signature
            });
        }
        return done(null, payload);
    });
};


/***/ }),

/***/ 43341:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var bufferEqual = __webpack_require__(46381);
var Buffer = (__webpack_require__(49765).Buffer);
var crypto = __webpack_require__(6113);
var formatEcdsa = __webpack_require__(20661);
var util = __webpack_require__(73837);
var MSG_INVALID_ALGORITHM = '"%s" is not a valid algorithm.\n  Supported algorithms are:\n  "HS256", "HS384", "HS512", "RS256", "RS384", "RS512", "PS256", "PS384", "PS512", "ES256", "ES384", "ES512" and "none".';
var MSG_INVALID_SECRET = "secret must be a string or buffer";
var MSG_INVALID_VERIFIER_KEY = "key must be a string or a buffer";
var MSG_INVALID_SIGNER_KEY = "key must be a string, a buffer or an object";
var supportsKeyObjects = typeof crypto.createPublicKey === "function";
if (supportsKeyObjects) {
    MSG_INVALID_VERIFIER_KEY += " or a KeyObject";
    MSG_INVALID_SECRET += "or a KeyObject";
}
function checkIsPublicKey(key) {
    if (Buffer.isBuffer(key)) {
        return;
    }
    if (typeof key === "string") {
        return;
    }
    if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key !== "object") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.type !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.asymmetricKeyType !== "string") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
    if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_VERIFIER_KEY);
    }
}
;
function checkIsPrivateKey(key) {
    if (Buffer.isBuffer(key)) {
        return;
    }
    if (typeof key === "string") {
        return;
    }
    if (typeof key === "object") {
        return;
    }
    throw typeError(MSG_INVALID_SIGNER_KEY);
}
;
function checkIsSecretKey(key) {
    if (Buffer.isBuffer(key)) {
        return;
    }
    if (typeof key === "string") {
        return key;
    }
    if (!supportsKeyObjects) {
        throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key !== "object") {
        throw typeError(MSG_INVALID_SECRET);
    }
    if (key.type !== "secret") {
        throw typeError(MSG_INVALID_SECRET);
    }
    if (typeof key.export !== "function") {
        throw typeError(MSG_INVALID_SECRET);
    }
}
function fromBase64(base64) {
    return base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function toBase64(base64url) {
    base64url = base64url.toString();
    var padding = 4 - base64url.length % 4;
    if (padding !== 4) {
        for(var i = 0; i < padding; ++i){
            base64url += "=";
        }
    }
    return base64url.replace(/\-/g, "+").replace(/_/g, "/");
}
function typeError(template) {
    var args = [].slice.call(arguments, 1);
    var errMsg = util.format.bind(util, template).apply(null, args);
    return new TypeError(errMsg);
}
function bufferOrString(obj) {
    return Buffer.isBuffer(obj) || typeof obj === "string";
}
function normalizeInput(thing) {
    if (!bufferOrString(thing)) thing = JSON.stringify(thing);
    return thing;
}
function createHmacSigner(bits) {
    return function sign(thing, secret) {
        checkIsSecretKey(secret);
        thing = normalizeInput(thing);
        var hmac = crypto.createHmac("sha" + bits, secret);
        var sig = (hmac.update(thing), hmac.digest("base64"));
        return fromBase64(sig);
    };
}
function createHmacVerifier(bits) {
    return function verify(thing, signature, secret) {
        var computedSig = createHmacSigner(bits)(thing, secret);
        return bufferEqual(Buffer.from(signature), Buffer.from(computedSig));
    };
}
function createKeySigner(bits) {
    return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        // Even though we are specifying "RSA" here, this works with ECDSA
        // keys as well.
        var signer = crypto.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign(privateKey, "base64"));
        return fromBase64(sig);
    };
}
function createKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify(publicKey, signature, "base64");
    };
}
function createPSSKeySigner(bits) {
    return function sign(thing, privateKey) {
        checkIsPrivateKey(privateKey);
        thing = normalizeInput(thing);
        var signer = crypto.createSign("RSA-SHA" + bits);
        var sig = (signer.update(thing), signer.sign({
            key: privateKey,
            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, "base64"));
        return fromBase64(sig);
    };
}
function createPSSKeyVerifier(bits) {
    return function verify(thing, signature, publicKey) {
        checkIsPublicKey(publicKey);
        thing = normalizeInput(thing);
        signature = toBase64(signature);
        var verifier = crypto.createVerify("RSA-SHA" + bits);
        verifier.update(thing);
        return verifier.verify({
            key: publicKey,
            padding: crypto.constants.RSA_PKCS1_PSS_PADDING,
            saltLength: crypto.constants.RSA_PSS_SALTLEN_DIGEST
        }, signature, "base64");
    };
}
function createECDSASigner(bits) {
    var inner = createKeySigner(bits);
    return function sign() {
        var signature = inner.apply(null, arguments);
        signature = formatEcdsa.derToJose(signature, "ES" + bits);
        return signature;
    };
}
function createECDSAVerifer(bits) {
    var inner = createKeyVerifier(bits);
    return function verify(thing, signature, publicKey) {
        signature = formatEcdsa.joseToDer(signature, "ES" + bits).toString("base64");
        var result = inner(thing, signature, publicKey);
        return result;
    };
}
function createNoneSigner() {
    return function sign() {
        return "";
    };
}
function createNoneVerifier() {
    return function verify(thing, signature) {
        return signature === "";
    };
}
module.exports = function jwa(algorithm) {
    var signerFactories = {
        hs: createHmacSigner,
        rs: createKeySigner,
        ps: createPSSKeySigner,
        es: createECDSASigner,
        none: createNoneSigner
    };
    var verifierFactories = {
        hs: createHmacVerifier,
        rs: createKeyVerifier,
        ps: createPSSKeyVerifier,
        es: createECDSAVerifer,
        none: createNoneVerifier
    };
    var match = algorithm.match(/^(RS|PS|ES|HS)(256|384|512)$|^(none)$/i);
    if (!match) throw typeError(MSG_INVALID_ALGORITHM, algorithm);
    var algo = (match[1] || match[3]).toLowerCase();
    var bits = match[2];
    return {
        sign: signerFactories[algo](bits),
        verify: verifierFactories[algo](bits)
    };
};


/***/ }),

/***/ 91750:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

/*global exports*/ var SignStream = __webpack_require__(37520);
var VerifyStream = __webpack_require__(88345);
var ALGORITHMS = [
    "HS256",
    "HS384",
    "HS512",
    "RS256",
    "RS384",
    "RS512",
    "PS256",
    "PS384",
    "PS512",
    "ES256",
    "ES384",
    "ES512"
];
exports.ALGORITHMS = ALGORITHMS;
exports.sign = SignStream.sign;
exports.verify = VerifyStream.verify;
exports.decode = VerifyStream.decode;
exports.isValid = VerifyStream.isValid;
exports.createSign = function createSign(opts) {
    return new SignStream(opts);
};
exports.createVerify = function createVerify(opts) {
    return new VerifyStream(opts);
};


/***/ }),

/***/ 92445:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*global module, process*/ 
var Buffer = (__webpack_require__(49765).Buffer);
var Stream = __webpack_require__(12781);
var util = __webpack_require__(73837);
function DataStream(data) {
    this.buffer = null;
    this.writable = true;
    this.readable = true;
    // No input
    if (!data) {
        this.buffer = Buffer.alloc(0);
        return this;
    }
    // Stream
    if (typeof data.pipe === "function") {
        this.buffer = Buffer.alloc(0);
        data.pipe(this);
        return this;
    }
    // Buffer or String
    // or Object (assumedly a passworded key)
    if (data.length || typeof data === "object") {
        this.buffer = data;
        this.writable = false;
        process.nextTick((function() {
            this.emit("end", data);
            this.readable = false;
            this.emit("close");
        }).bind(this));
        return this;
    }
    throw new TypeError("Unexpected data type (" + typeof data + ")");
}
util.inherits(DataStream, Stream);
DataStream.prototype.write = function write(data) {
    this.buffer = Buffer.concat([
        this.buffer,
        Buffer.from(data)
    ]);
    this.emit("data", data);
};
DataStream.prototype.end = function end(data) {
    if (data) this.write(data);
    this.emit("end", data);
    this.emit("close");
    this.writable = false;
    this.readable = false;
};
module.exports = DataStream;


/***/ }),

/***/ 37520:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*global module*/ 
var Buffer = (__webpack_require__(49765).Buffer);
var DataStream = __webpack_require__(92445);
var jwa = __webpack_require__(43341);
var Stream = __webpack_require__(12781);
var toString = __webpack_require__(90272);
var util = __webpack_require__(73837);
function base64url(string, encoding) {
    return Buffer.from(string, encoding).toString("base64").replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
}
function jwsSecuredInput(header, payload, encoding) {
    encoding = encoding || "utf8";
    var encodedHeader = base64url(toString(header), "binary");
    var encodedPayload = base64url(toString(payload), encoding);
    return util.format("%s.%s", encodedHeader, encodedPayload);
}
function jwsSign(opts) {
    var header = opts.header;
    var payload = opts.payload;
    var secretOrKey = opts.secret || opts.privateKey;
    var encoding = opts.encoding;
    var algo = jwa(header.alg);
    var securedInput = jwsSecuredInput(header, payload, encoding);
    var signature = algo.sign(securedInput, secretOrKey);
    return util.format("%s.%s", securedInput, signature);
}
function SignStream(opts) {
    var secret = opts.secret || opts.privateKey || opts.key;
    var secretStream = new DataStream(secret);
    this.readable = true;
    this.header = opts.header;
    this.encoding = opts.encoding;
    this.secret = this.privateKey = this.key = secretStream;
    this.payload = new DataStream(opts.payload);
    this.secret.once("close", (function() {
        if (!this.payload.writable && this.readable) this.sign();
    }).bind(this));
    this.payload.once("close", (function() {
        if (!this.secret.writable && this.readable) this.sign();
    }).bind(this));
}
util.inherits(SignStream, Stream);
SignStream.prototype.sign = function sign() {
    try {
        var signature = jwsSign({
            header: this.header,
            payload: this.payload.buffer,
            secret: this.secret.buffer,
            encoding: this.encoding
        });
        this.emit("done", signature);
        this.emit("data", signature);
        this.emit("end");
        this.readable = false;
        return signature;
    } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
    }
};
SignStream.sign = jwsSign;
module.exports = SignStream;


/***/ }),

/***/ 90272:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*global module*/ 
var Buffer = (__webpack_require__(14300).Buffer);
module.exports = function toString(obj) {
    if (typeof obj === "string") return obj;
    if (typeof obj === "number" || Buffer.isBuffer(obj)) return obj.toString();
    return JSON.stringify(obj);
};


/***/ }),

/***/ 88345:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
/*global module*/ 
var Buffer = (__webpack_require__(49765).Buffer);
var DataStream = __webpack_require__(92445);
var jwa = __webpack_require__(43341);
var Stream = __webpack_require__(12781);
var toString = __webpack_require__(90272);
var util = __webpack_require__(73837);
var JWS_REGEX = /^[a-zA-Z0-9\-_]+?\.[a-zA-Z0-9\-_]+?\.([a-zA-Z0-9\-_]+)?$/;
function isObject(thing) {
    return Object.prototype.toString.call(thing) === "[object Object]";
}
function safeJsonParse(thing) {
    if (isObject(thing)) return thing;
    try {
        return JSON.parse(thing);
    } catch (e) {
        return undefined;
    }
}
function headerFromJWS(jwsSig) {
    var encodedHeader = jwsSig.split(".", 1)[0];
    return safeJsonParse(Buffer.from(encodedHeader, "base64").toString("binary"));
}
function securedInputFromJWS(jwsSig) {
    return jwsSig.split(".", 2).join(".");
}
function signatureFromJWS(jwsSig) {
    return jwsSig.split(".")[2];
}
function payloadFromJWS(jwsSig, encoding) {
    encoding = encoding || "utf8";
    var payload = jwsSig.split(".")[1];
    return Buffer.from(payload, "base64").toString(encoding);
}
function isValidJws(string) {
    return JWS_REGEX.test(string) && !!headerFromJWS(string);
}
function jwsVerify(jwsSig, algorithm, secretOrKey) {
    if (!algorithm) {
        var err = new Error("Missing algorithm parameter for jws.verify");
        err.code = "MISSING_ALGORITHM";
        throw err;
    }
    jwsSig = toString(jwsSig);
    var signature = signatureFromJWS(jwsSig);
    var securedInput = securedInputFromJWS(jwsSig);
    var algo = jwa(algorithm);
    return algo.verify(securedInput, signature, secretOrKey);
}
function jwsDecode(jwsSig, opts) {
    opts = opts || {};
    jwsSig = toString(jwsSig);
    if (!isValidJws(jwsSig)) return null;
    var header = headerFromJWS(jwsSig);
    if (!header) return null;
    var payload = payloadFromJWS(jwsSig);
    if (header.typ === "JWT" || opts.json) payload = JSON.parse(payload, opts.encoding);
    return {
        header: header,
        payload: payload,
        signature: signatureFromJWS(jwsSig)
    };
}
function VerifyStream(opts) {
    opts = opts || {};
    var secretOrKey = opts.secret || opts.publicKey || opts.key;
    var secretStream = new DataStream(secretOrKey);
    this.readable = true;
    this.algorithm = opts.algorithm;
    this.encoding = opts.encoding;
    this.secret = this.publicKey = this.key = secretStream;
    this.signature = new DataStream(opts.signature);
    this.secret.once("close", (function() {
        if (!this.signature.writable && this.readable) this.verify();
    }).bind(this));
    this.signature.once("close", (function() {
        if (!this.secret.writable && this.readable) this.verify();
    }).bind(this));
}
util.inherits(VerifyStream, Stream);
VerifyStream.prototype.verify = function verify() {
    try {
        var valid = jwsVerify(this.signature.buffer, this.algorithm, this.key.buffer);
        var obj = jwsDecode(this.signature.buffer, this.encoding);
        this.emit("done", valid, obj);
        this.emit("data", valid);
        this.emit("end");
        this.readable = false;
        return valid;
    } catch (e) {
        this.readable = false;
        this.emit("error", e);
        this.emit("close");
    }
};
VerifyStream.decode = jwsDecode;
VerifyStream.isValid = isValidJws;
VerifyStream.verify = jwsVerify;
module.exports = VerifyStream;


/***/ }),

/***/ 58174:
/***/ ((module) => {

"use strict";
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as references for various `Number` constants. */ 
var INFINITY = 1 / 0, MAX_SAFE_INTEGER = 9007199254740991, MAX_INTEGER = 1.7976931348623157e+308, NAN = 0 / 0;
/** `Object#toString` result references. */ var argsTag = "[object Arguments]", funcTag = "[object Function]", genTag = "[object GeneratorFunction]", stringTag = "[object String]", symbolTag = "[object Symbol]";
/** Used to match leading and trailing whitespace. */ var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;
/** Used to detect unsigned integer values. */ var reIsUint = /^(?:0|[1-9]\d*)$/;
/** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;
/**
 * A specialized version of `_.map` for arrays without support for iteratee
 * shorthands.
 *
 * @private
 * @param {Array} [array] The array to iterate over.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the new mapped array.
 */ function arrayMap(array, iteratee) {
    var index = -1, length = array ? array.length : 0, result = Array(length);
    while(++index < length){
        result[index] = iteratee(array[index], index, array);
    }
    return result;
}
/**
 * The base implementation of `_.findIndex` and `_.findLastIndex` without
 * support for iteratee shorthands.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {Function} predicate The function invoked per iteration.
 * @param {number} fromIndex The index to search from.
 * @param {boolean} [fromRight] Specify iterating from right to left.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseFindIndex(array, predicate, fromIndex, fromRight) {
    var length = array.length, index = fromIndex + (fromRight ? 1 : -1);
    while(fromRight ? index-- : ++index < length){
        if (predicate(array[index], index, array)) {
            return index;
        }
    }
    return -1;
}
/**
 * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
 *
 * @private
 * @param {Array} array The array to inspect.
 * @param {*} value The value to search for.
 * @param {number} fromIndex The index to search from.
 * @returns {number} Returns the index of the matched value, else `-1`.
 */ function baseIndexOf(array, value, fromIndex) {
    if (value !== value) {
        return baseFindIndex(array, baseIsNaN, fromIndex);
    }
    var index = fromIndex - 1, length = array.length;
    while(++index < length){
        if (array[index] === value) {
            return index;
        }
    }
    return -1;
}
/**
 * The base implementation of `_.isNaN` without support for number objects.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
 */ function baseIsNaN(value) {
    return value !== value;
}
/**
 * The base implementation of `_.times` without support for iteratee shorthands
 * or max array length checks.
 *
 * @private
 * @param {number} n The number of times to invoke `iteratee`.
 * @param {Function} iteratee The function invoked per iteration.
 * @returns {Array} Returns the array of results.
 */ function baseTimes(n, iteratee) {
    var index = -1, result = Array(n);
    while(++index < n){
        result[index] = iteratee(index);
    }
    return result;
}
/**
 * The base implementation of `_.values` and `_.valuesIn` which creates an
 * array of `object` property values corresponding to the property names
 * of `props`.
 *
 * @private
 * @param {Object} object The object to query.
 * @param {Array} props The property names to get values for.
 * @returns {Object} Returns the array of property values.
 */ function baseValues(object, props) {
    return arrayMap(props, function(key) {
        return object[key];
    });
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
/** Used for built-in method references. */ var objectProto = Object.prototype;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Built-in value references. */ var propertyIsEnumerable = objectProto.propertyIsEnumerable;
/* Built-in method references for those with the same name as other `lodash` methods. */ var nativeKeys = overArg(Object.keys, Object), nativeMax = Math.max;
/**
 * Creates an array of the enumerable property names of the array-like `value`.
 *
 * @private
 * @param {*} value The value to query.
 * @param {boolean} inherited Specify returning inherited property names.
 * @returns {Array} Returns the array of property names.
 */ function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = isArray(value) || isArguments(value) ? baseTimes(value.length, String) : [];
    var length = result.length, skipIndexes = !!length;
    for(var key in value){
        if ((inherited || hasOwnProperty.call(value, key)) && !(skipIndexes && (key == "length" || isIndex(key, length)))) {
            result.push(key);
        }
    }
    return result;
}
/**
 * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
 *
 * @private
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 */ function baseKeys(object) {
    if (!isPrototype(object)) {
        return nativeKeys(object);
    }
    var result = [];
    for(var key in Object(object)){
        if (hasOwnProperty.call(object, key) && key != "constructor") {
            result.push(key);
        }
    }
    return result;
}
/**
 * Checks if `value` is a valid array-like index.
 *
 * @private
 * @param {*} value The value to check.
 * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
 * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
 */ function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length && (typeof value == "number" || reIsUint.test(value)) && value > -1 && value % 1 == 0 && value < length;
}
/**
 * Checks if `value` is likely a prototype object.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
 */ function isPrototype(value) {
    var Ctor = value && value.constructor, proto = typeof Ctor == "function" && Ctor.prototype || objectProto;
    return value === proto;
}
/**
 * Checks if `value` is in `collection`. If `collection` is a string, it's
 * checked for a substring of `value`, otherwise
 * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
 * is used for equality comparisons. If `fromIndex` is negative, it's used as
 * the offset from the end of `collection`.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Collection
 * @param {Array|Object|string} collection The collection to inspect.
 * @param {*} value The value to search for.
 * @param {number} [fromIndex=0] The index to search from.
 * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
 * @returns {boolean} Returns `true` if `value` is found, else `false`.
 * @example
 *
 * _.includes([1, 2, 3], 1);
 * // => true
 *
 * _.includes([1, 2, 3], 1, 2);
 * // => false
 *
 * _.includes({ 'a': 1, 'b': 2 }, 1);
 * // => true
 *
 * _.includes('abcd', 'bc');
 * // => true
 */ function includes(collection, value, fromIndex, guard) {
    collection = isArrayLike(collection) ? collection : values(collection);
    fromIndex = fromIndex && !guard ? toInteger(fromIndex) : 0;
    var length = collection.length;
    if (fromIndex < 0) {
        fromIndex = nativeMax(length + fromIndex, 0);
    }
    return isString(collection) ? fromIndex <= length && collection.indexOf(value, fromIndex) > -1 : !!length && baseIndexOf(collection, value, fromIndex) > -1;
}
/**
 * Checks if `value` is likely an `arguments` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an `arguments` object,
 *  else `false`.
 * @example
 *
 * _.isArguments(function() { return arguments; }());
 * // => true
 *
 * _.isArguments([1, 2, 3]);
 * // => false
 */ function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, "callee") && (!propertyIsEnumerable.call(value, "callee") || objectToString.call(value) == argsTag);
}
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is array-like. A value is considered array-like if it's
 * not a function and has a `value.length` that's an integer greater than or
 * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
 * @example
 *
 * _.isArrayLike([1, 2, 3]);
 * // => true
 *
 * _.isArrayLike(document.body.children);
 * // => true
 *
 * _.isArrayLike('abc');
 * // => true
 *
 * _.isArrayLike(_.noop);
 * // => false
 */ function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction(value);
}
/**
 * This method is like `_.isArrayLike` except that it also checks if `value`
 * is an object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an array-like object,
 *  else `false`.
 * @example
 *
 * _.isArrayLikeObject([1, 2, 3]);
 * // => true
 *
 * _.isArrayLikeObject(document.body.children);
 * // => true
 *
 * _.isArrayLikeObject('abc');
 * // => false
 *
 * _.isArrayLikeObject(_.noop);
 * // => false
 */ function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
}
/**
 * Checks if `value` is classified as a `Function` object.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a function, else `false`.
 * @example
 *
 * _.isFunction(_);
 * // => true
 *
 * _.isFunction(/abc/);
 * // => false
 */ function isFunction(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject(value) ? objectToString.call(value) : "";
    return tag == funcTag || tag == genTag;
}
/**
 * Checks if `value` is a valid array-like length.
 *
 * **Note:** This method is loosely based on
 * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
 * @example
 *
 * _.isLength(3);
 * // => true
 *
 * _.isLength(Number.MIN_VALUE);
 * // => false
 *
 * _.isLength(Infinity);
 * // => false
 *
 * _.isLength('3');
 * // => false
 */ function isLength(value) {
    return typeof value == "number" && value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a string, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */ function isString(value) {
    return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */ function toFinite(value) {
    if (!value) {
        return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
}
/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */ function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */ function toNumber(value) {
    if (typeof value == "number") {
        return value;
    }
    if (isSymbol(value)) {
        return NAN;
    }
    if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
        return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
/**
 * Creates an array of the own enumerable property names of `object`.
 *
 * **Note:** Non-object values are coerced to objects. See the
 * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
 * for more details.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property names.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.keys(new Foo);
 * // => ['a', 'b'] (iteration order is not guaranteed)
 *
 * _.keys('hi');
 * // => ['0', '1']
 */ function keys(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
}
/**
 * Creates an array of the own enumerable string keyed property values of `object`.
 *
 * **Note:** Non-object values are coerced to objects.
 *
 * @static
 * @since 0.1.0
 * @memberOf _
 * @category Object
 * @param {Object} object The object to query.
 * @returns {Array} Returns the array of property values.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 *   this.b = 2;
 * }
 *
 * Foo.prototype.c = 3;
 *
 * _.values(new Foo);
 * // => [1, 2] (iteration order is not guaranteed)
 *
 * _.values('hi');
 * // => ['h', 'i']
 */ function values(object) {
    return object ? baseValues(object, keys(object)) : [];
}
module.exports = includes;


/***/ }),

/***/ 14647:
/***/ ((module) => {

"use strict";
/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */ /** `Object#toString` result references. */ 
var boolTag = "[object Boolean]";
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/**
 * Checks if `value` is classified as a boolean primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isBoolean(false);
 * // => true
 *
 * _.isBoolean(null);
 * // => false
 */ function isBoolean(value) {
    return value === true || value === false || isObjectLike(value) && objectToString.call(value) == boolTag;
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
module.exports = isBoolean;


/***/ }),

/***/ 61811:
/***/ ((module) => {

"use strict";
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as references for various `Number` constants. */ 
var INFINITY = 1 / 0, MAX_INTEGER = 1.7976931348623157e+308, NAN = 0 / 0;
/** `Object#toString` result references. */ var symbolTag = "[object Symbol]";
/** Used to match leading and trailing whitespace. */ var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/**
 * Checks if `value` is an integer.
 *
 * **Note:** This method is based on
 * [`Number.isInteger`](https://mdn.io/Number/isInteger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
 * @example
 *
 * _.isInteger(3);
 * // => true
 *
 * _.isInteger(Number.MIN_VALUE);
 * // => false
 *
 * _.isInteger(Infinity);
 * // => false
 *
 * _.isInteger('3');
 * // => false
 */ function isInteger(value) {
    return typeof value == "number" && value == toInteger(value);
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */ function toFinite(value) {
    if (!value) {
        return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
}
/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */ function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */ function toNumber(value) {
    if (typeof value == "number") {
        return value;
    }
    if (isSymbol(value)) {
        return NAN;
    }
    if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
        return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
module.exports = isInteger;


/***/ }),

/***/ 11631:
/***/ ((module) => {

"use strict";
/**
 * lodash 3.0.3 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */ /** `Object#toString` result references. */ 
var numberTag = "[object Number]";
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
/**
 * Checks if `value` is classified as a `Number` primitive or object.
 *
 * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are classified
 * as numbers, use the `_.isFinite` method.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isNumber(3);
 * // => true
 *
 * _.isNumber(Number.MIN_VALUE);
 * // => true
 *
 * _.isNumber(Infinity);
 * // => true
 *
 * _.isNumber('3');
 * // => false
 */ function isNumber(value) {
    return typeof value == "number" || isObjectLike(value) && objectToString.call(value) == numberTag;
}
module.exports = isNumber;


/***/ }),

/***/ 59135:
/***/ ((module) => {

"use strict";
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** `Object#toString` result references. */ 
var objectTag = "[object Object]";
/**
 * Checks if `value` is a host object in IE < 9.
 *
 * @private
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
 */ function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != "function") {
        try {
            result = !!(value + "");
        } catch (e) {}
    }
    return result;
}
/**
 * Creates a unary function that invokes `func` with its argument transformed.
 *
 * @private
 * @param {Function} func The function to wrap.
 * @param {Function} transform The argument transform.
 * @returns {Function} Returns the new function.
 */ function overArg(func, transform) {
    return function(arg) {
        return func(transform(arg));
    };
}
/** Used for built-in method references. */ var funcProto = Function.prototype, objectProto = Object.prototype;
/** Used to resolve the decompiled source of functions. */ var funcToString = funcProto.toString;
/** Used to check objects for own properties. */ var hasOwnProperty = objectProto.hasOwnProperty;
/** Used to infer the `Object` constructor. */ var objectCtorString = funcToString.call(Object);
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/** Built-in value references. */ var getPrototype = overArg(Object.getPrototypeOf, Object);
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
/**
 * Checks if `value` is a plain object, that is, an object created by the
 * `Object` constructor or one with a `[[Prototype]]` of `null`.
 *
 * @static
 * @memberOf _
 * @since 0.8.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
 * @example
 *
 * function Foo() {
 *   this.a = 1;
 * }
 *
 * _.isPlainObject(new Foo);
 * // => false
 *
 * _.isPlainObject([1, 2, 3]);
 * // => false
 *
 * _.isPlainObject({ 'x': 0, 'y': 0 });
 * // => true
 *
 * _.isPlainObject(Object.create(null));
 * // => true
 */ function isPlainObject(value) {
    if (!isObjectLike(value) || objectToString.call(value) != objectTag || isHostObject(value)) {
        return false;
    }
    var proto = getPrototype(value);
    if (proto === null) {
        return true;
    }
    var Ctor = hasOwnProperty.call(proto, "constructor") && proto.constructor;
    return typeof Ctor == "function" && Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString;
}
module.exports = isPlainObject;


/***/ }),

/***/ 12304:
/***/ ((module) => {

"use strict";
/**
 * lodash 4.0.1 (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 * Available under MIT license <https://lodash.com/license>
 */ /** `Object#toString` result references. */ 
var stringTag = "[object String]";
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/**
 * Checks if `value` is classified as an `Array` object.
 *
 * @static
 * @memberOf _
 * @type Function
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isArray([1, 2, 3]);
 * // => true
 *
 * _.isArray(document.body.children);
 * // => false
 *
 * _.isArray('abc');
 * // => false
 *
 * _.isArray(_.noop);
 * // => false
 */ var isArray = Array.isArray;
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
/**
 * Checks if `value` is classified as a `String` primitive or object.
 *
 * @static
 * @memberOf _
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.
 * @example
 *
 * _.isString('abc');
 * // => true
 *
 * _.isString(1);
 * // => false
 */ function isString(value) {
    return typeof value == "string" || !isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag;
}
module.exports = isString;


/***/ }),

/***/ 571:
/***/ ((module) => {

"use strict";
/**
 * lodash (Custom Build) <https://lodash.com/>
 * Build: `lodash modularize exports="npm" -o ./`
 * Copyright jQuery Foundation and other contributors <https://jquery.org/>
 * Released under MIT license <https://lodash.com/license>
 * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
 * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
 */ /** Used as the `TypeError` message for "Functions" methods. */ 
var FUNC_ERROR_TEXT = "Expected a function";
/** Used as references for various `Number` constants. */ var INFINITY = 1 / 0, MAX_INTEGER = 1.7976931348623157e+308, NAN = 0 / 0;
/** `Object#toString` result references. */ var symbolTag = "[object Symbol]";
/** Used to match leading and trailing whitespace. */ var reTrim = /^\s+|\s+$/g;
/** Used to detect bad signed hexadecimal string values. */ var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;
/** Used to detect binary string values. */ var reIsBinary = /^0b[01]+$/i;
/** Used to detect octal string values. */ var reIsOctal = /^0o[0-7]+$/i;
/** Built-in method references without a dependency on `root`. */ var freeParseInt = parseInt;
/** Used for built-in method references. */ var objectProto = Object.prototype;
/**
 * Used to resolve the
 * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
 * of values.
 */ var objectToString = objectProto.toString;
/**
 * Creates a function that invokes `func`, with the `this` binding and arguments
 * of the created function, while it's called less than `n` times. Subsequent
 * calls to the created function return the result of the last `func` invocation.
 *
 * @static
 * @memberOf _
 * @since 3.0.0
 * @category Function
 * @param {number} n The number of calls at which `func` is no longer invoked.
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * jQuery(element).on('click', _.before(5, addContactToList));
 * // => Allows adding up to 4 contacts to the list.
 */ function before(n, func) {
    var result;
    if (typeof func != "function") {
        throw new TypeError(FUNC_ERROR_TEXT);
    }
    n = toInteger(n);
    return function() {
        if (--n > 0) {
            result = func.apply(this, arguments);
        }
        if (n <= 1) {
            func = undefined;
        }
        return result;
    };
}
/**
 * Creates a function that is restricted to invoking `func` once. Repeat calls
 * to the function return the value of the first invocation. The `func` is
 * invoked with the `this` binding and arguments of the created function.
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Function
 * @param {Function} func The function to restrict.
 * @returns {Function} Returns the new restricted function.
 * @example
 *
 * var initialize = _.once(createApplication);
 * initialize();
 * initialize();
 * // => `createApplication` is invoked once
 */ function once(func) {
    return before(2, func);
}
/**
 * Checks if `value` is the
 * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
 * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
 *
 * @static
 * @memberOf _
 * @since 0.1.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is an object, else `false`.
 * @example
 *
 * _.isObject({});
 * // => true
 *
 * _.isObject([1, 2, 3]);
 * // => true
 *
 * _.isObject(_.noop);
 * // => true
 *
 * _.isObject(null);
 * // => false
 */ function isObject(value) {
    var type = typeof value;
    return !!value && (type == "object" || type == "function");
}
/**
 * Checks if `value` is object-like. A value is object-like if it's not `null`
 * and has a `typeof` result of "object".
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
 * @example
 *
 * _.isObjectLike({});
 * // => true
 *
 * _.isObjectLike([1, 2, 3]);
 * // => true
 *
 * _.isObjectLike(_.noop);
 * // => false
 *
 * _.isObjectLike(null);
 * // => false
 */ function isObjectLike(value) {
    return !!value && typeof value == "object";
}
/**
 * Checks if `value` is classified as a `Symbol` primitive or object.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to check.
 * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
 * @example
 *
 * _.isSymbol(Symbol.iterator);
 * // => true
 *
 * _.isSymbol('abc');
 * // => false
 */ function isSymbol(value) {
    return typeof value == "symbol" || isObjectLike(value) && objectToString.call(value) == symbolTag;
}
/**
 * Converts `value` to a finite number.
 *
 * @static
 * @memberOf _
 * @since 4.12.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted number.
 * @example
 *
 * _.toFinite(3.2);
 * // => 3.2
 *
 * _.toFinite(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toFinite(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toFinite('3.2');
 * // => 3.2
 */ function toFinite(value) {
    if (!value) {
        return value === 0 ? value : 0;
    }
    value = toNumber(value);
    if (value === INFINITY || value === -INFINITY) {
        var sign = value < 0 ? -1 : 1;
        return sign * MAX_INTEGER;
    }
    return value === value ? value : 0;
}
/**
 * Converts `value` to an integer.
 *
 * **Note:** This method is loosely based on
 * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to convert.
 * @returns {number} Returns the converted integer.
 * @example
 *
 * _.toInteger(3.2);
 * // => 3
 *
 * _.toInteger(Number.MIN_VALUE);
 * // => 0
 *
 * _.toInteger(Infinity);
 * // => 1.7976931348623157e+308
 *
 * _.toInteger('3.2');
 * // => 3
 */ function toInteger(value) {
    var result = toFinite(value), remainder = result % 1;
    return result === result ? remainder ? result - remainder : result : 0;
}
/**
 * Converts `value` to a number.
 *
 * @static
 * @memberOf _
 * @since 4.0.0
 * @category Lang
 * @param {*} value The value to process.
 * @returns {number} Returns the number.
 * @example
 *
 * _.toNumber(3.2);
 * // => 3.2
 *
 * _.toNumber(Number.MIN_VALUE);
 * // => 5e-324
 *
 * _.toNumber(Infinity);
 * // => Infinity
 *
 * _.toNumber('3.2');
 * // => 3.2
 */ function toNumber(value) {
    if (typeof value == "number") {
        return value;
    }
    if (isSymbol(value)) {
        return NAN;
    }
    if (isObject(value)) {
        var other = typeof value.valueOf == "function" ? value.valueOf() : value;
        value = isObject(other) ? other + "" : other;
    }
    if (typeof value != "string") {
        return value === 0 ? value : +value;
    }
    value = value.replace(reTrim, "");
    var isBinary = reIsBinary.test(value);
    return isBinary || reIsOctal.test(value) ? freeParseInt(value.slice(2), isBinary ? 2 : 8) : reIsBadHex.test(value) ? NAN : +value;
}
module.exports = once;


/***/ }),

/***/ 41594:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(69124);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.UnsupportedStrategy = exports.UnknownError = exports.OAuthCallbackError = exports.MissingSecret = exports.MissingAuthorize = exports.MissingAdapterMethods = exports.MissingAdapter = exports.MissingAPIRoute = exports.InvalidCallbackUrl = exports.AccountNotLinkedError = void 0;
exports.adapterErrorHandler = adapterErrorHandler;
exports.capitalize = capitalize;
exports.eventsErrorHandler = eventsErrorHandler;
exports.upperSnake = upperSnake;
var _regenerator = _interopRequireDefault(__webpack_require__(86721));
var _asyncToGenerator2 = _interopRequireDefault(__webpack_require__(70895));
var _assertThisInitialized2 = _interopRequireDefault(__webpack_require__(53443));
var _defineProperty2 = _interopRequireDefault(__webpack_require__(97662));
var _classCallCheck2 = _interopRequireDefault(__webpack_require__(21656));
var _createClass2 = _interopRequireDefault(__webpack_require__(73381));
var _inherits2 = _interopRequireDefault(__webpack_require__(63160));
var _possibleConstructorReturn2 = _interopRequireDefault(__webpack_require__(31582));
var _getPrototypeOf2 = _interopRequireDefault(__webpack_require__(31212));
var _wrapNativeSuper2 = _interopRequireDefault(__webpack_require__(27977));
function _createSuper(Derived) {
    var hasNativeReflectConstruct = _isNativeReflectConstruct();
    return function _createSuperInternal() {
        var Super = (0, _getPrototypeOf2.default)(Derived), result;
        if (hasNativeReflectConstruct) {
            var NewTarget = (0, _getPrototypeOf2.default)(this).constructor;
            result = Reflect.construct(Super, arguments, NewTarget);
        } else {
            result = Super.apply(this, arguments);
        }
        return (0, _possibleConstructorReturn2.default)(this, result);
    };
}
function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
var UnknownError = function(_Error) {
    (0, _inherits2.default)(UnknownError, _Error);
    var _super = _createSuper(UnknownError);
    function UnknownError(error) {
        var _message;
        var _this;
        (0, _classCallCheck2.default)(this, UnknownError);
        _this = _super.call(this, (_message = error === null || error === void 0 ? void 0 : error.message) !== null && _message !== void 0 ? _message : error);
        _this.name = "UnknownError";
        _this.code = error.code;
        if (error instanceof Error) {
            _this.stack = error.stack;
        }
        return _this;
    }
    (0, _createClass2.default)(UnknownError, [
        {
            key: "toJSON",
            value: function toJSON() {
                return {
                    name: this.name,
                    message: this.message,
                    stack: this.stack
                };
            }
        }
    ]);
    return UnknownError;
}((0, _wrapNativeSuper2.default)(Error));
exports.UnknownError = UnknownError;
var OAuthCallbackError = function(_UnknownError) {
    (0, _inherits2.default)(OAuthCallbackError, _UnknownError);
    var _super2 = _createSuper(OAuthCallbackError);
    function OAuthCallbackError() {
        var _this2;
        (0, _classCallCheck2.default)(this, OAuthCallbackError);
        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){
            args[_key] = arguments[_key];
        }
        _this2 = _super2.call.apply(_super2, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this2), "name", "OAuthCallbackError");
        return _this2;
    }
    return (0, _createClass2.default)(OAuthCallbackError);
}(UnknownError);
exports.OAuthCallbackError = OAuthCallbackError;
var AccountNotLinkedError = function(_UnknownError2) {
    (0, _inherits2.default)(AccountNotLinkedError, _UnknownError2);
    var _super3 = _createSuper(AccountNotLinkedError);
    function AccountNotLinkedError() {
        var _this3;
        (0, _classCallCheck2.default)(this, AccountNotLinkedError);
        for(var _len2 = arguments.length, args = new Array(_len2), _key2 = 0; _key2 < _len2; _key2++){
            args[_key2] = arguments[_key2];
        }
        _this3 = _super3.call.apply(_super3, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this3), "name", "AccountNotLinkedError");
        return _this3;
    }
    return (0, _createClass2.default)(AccountNotLinkedError);
}(UnknownError);
exports.AccountNotLinkedError = AccountNotLinkedError;
var MissingAPIRoute = function(_UnknownError3) {
    (0, _inherits2.default)(MissingAPIRoute, _UnknownError3);
    var _super4 = _createSuper(MissingAPIRoute);
    function MissingAPIRoute() {
        var _this4;
        (0, _classCallCheck2.default)(this, MissingAPIRoute);
        for(var _len3 = arguments.length, args = new Array(_len3), _key3 = 0; _key3 < _len3; _key3++){
            args[_key3] = arguments[_key3];
        }
        _this4 = _super4.call.apply(_super4, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), "name", "MissingAPIRouteError");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this4), "code", "MISSING_NEXTAUTH_API_ROUTE_ERROR");
        return _this4;
    }
    return (0, _createClass2.default)(MissingAPIRoute);
}(UnknownError);
exports.MissingAPIRoute = MissingAPIRoute;
var MissingSecret = function(_UnknownError4) {
    (0, _inherits2.default)(MissingSecret, _UnknownError4);
    var _super5 = _createSuper(MissingSecret);
    function MissingSecret() {
        var _this5;
        (0, _classCallCheck2.default)(this, MissingSecret);
        for(var _len4 = arguments.length, args = new Array(_len4), _key4 = 0; _key4 < _len4; _key4++){
            args[_key4] = arguments[_key4];
        }
        _this5 = _super5.call.apply(_super5, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), "name", "MissingSecretError");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this5), "code", "NO_SECRET");
        return _this5;
    }
    return (0, _createClass2.default)(MissingSecret);
}(UnknownError);
exports.MissingSecret = MissingSecret;
var MissingAuthorize = function(_UnknownError5) {
    (0, _inherits2.default)(MissingAuthorize, _UnknownError5);
    var _super6 = _createSuper(MissingAuthorize);
    function MissingAuthorize() {
        var _this6;
        (0, _classCallCheck2.default)(this, MissingAuthorize);
        for(var _len5 = arguments.length, args = new Array(_len5), _key5 = 0; _key5 < _len5; _key5++){
            args[_key5] = arguments[_key5];
        }
        _this6 = _super6.call.apply(_super6, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), "name", "MissingAuthorizeError");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this6), "code", "CALLBACK_CREDENTIALS_HANDLER_ERROR");
        return _this6;
    }
    return (0, _createClass2.default)(MissingAuthorize);
}(UnknownError);
exports.MissingAuthorize = MissingAuthorize;
var MissingAdapter = function(_UnknownError6) {
    (0, _inherits2.default)(MissingAdapter, _UnknownError6);
    var _super7 = _createSuper(MissingAdapter);
    function MissingAdapter() {
        var _this7;
        (0, _classCallCheck2.default)(this, MissingAdapter);
        for(var _len6 = arguments.length, args = new Array(_len6), _key6 = 0; _key6 < _len6; _key6++){
            args[_key6] = arguments[_key6];
        }
        _this7 = _super7.call.apply(_super7, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), "name", "MissingAdapterError");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this7), "code", "EMAIL_REQUIRES_ADAPTER_ERROR");
        return _this7;
    }
    return (0, _createClass2.default)(MissingAdapter);
}(UnknownError);
exports.MissingAdapter = MissingAdapter;
var MissingAdapterMethods = function(_UnknownError7) {
    (0, _inherits2.default)(MissingAdapterMethods, _UnknownError7);
    var _super8 = _createSuper(MissingAdapterMethods);
    function MissingAdapterMethods() {
        var _this8;
        (0, _classCallCheck2.default)(this, MissingAdapterMethods);
        for(var _len7 = arguments.length, args = new Array(_len7), _key7 = 0; _key7 < _len7; _key7++){
            args[_key7] = arguments[_key7];
        }
        _this8 = _super8.call.apply(_super8, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this8), "name", "MissingAdapterMethodsError");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this8), "code", "MISSING_ADAPTER_METHODS_ERROR");
        return _this8;
    }
    return (0, _createClass2.default)(MissingAdapterMethods);
}(UnknownError);
exports.MissingAdapterMethods = MissingAdapterMethods;
var UnsupportedStrategy = function(_UnknownError8) {
    (0, _inherits2.default)(UnsupportedStrategy, _UnknownError8);
    var _super9 = _createSuper(UnsupportedStrategy);
    function UnsupportedStrategy() {
        var _this9;
        (0, _classCallCheck2.default)(this, UnsupportedStrategy);
        for(var _len8 = arguments.length, args = new Array(_len8), _key8 = 0; _key8 < _len8; _key8++){
            args[_key8] = arguments[_key8];
        }
        _this9 = _super9.call.apply(_super9, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this9), "name", "UnsupportedStrategyError");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this9), "code", "CALLBACK_CREDENTIALS_JWT_ERROR");
        return _this9;
    }
    return (0, _createClass2.default)(UnsupportedStrategy);
}(UnknownError);
exports.UnsupportedStrategy = UnsupportedStrategy;
var InvalidCallbackUrl = function(_UnknownError9) {
    (0, _inherits2.default)(InvalidCallbackUrl, _UnknownError9);
    var _super10 = _createSuper(InvalidCallbackUrl);
    function InvalidCallbackUrl() {
        var _this10;
        (0, _classCallCheck2.default)(this, InvalidCallbackUrl);
        for(var _len9 = arguments.length, args = new Array(_len9), _key9 = 0; _key9 < _len9; _key9++){
            args[_key9] = arguments[_key9];
        }
        _this10 = _super10.call.apply(_super10, [
            this
        ].concat(args));
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this10), "name", "InvalidCallbackUrl");
        (0, _defineProperty2.default)((0, _assertThisInitialized2.default)(_this10), "code", "INVALID_CALLBACK_URL_ERROR");
        return _this10;
    }
    return (0, _createClass2.default)(InvalidCallbackUrl);
}(UnknownError);
exports.InvalidCallbackUrl = InvalidCallbackUrl;
function upperSnake(s) {
    return s.replace(/([A-Z])/g, "_$1").toUpperCase();
}
function capitalize(s) {
    return "".concat(s[0].toUpperCase()).concat(s.slice(1));
}
function eventsErrorHandler(methods, logger) {
    return Object.keys(methods).reduce(function(acc, name) {
        acc[name] = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee() {
            var method, _args = arguments;
            return _regenerator.default.wrap(function _callee$(_context) {
                while(1){
                    switch(_context.prev = _context.next){
                        case 0:
                            _context.prev = 0;
                            method = methods[name];
                            _context.next = 4;
                            return method.apply(void 0, _args);
                        case 4:
                            return _context.abrupt("return", _context.sent);
                        case 7:
                            _context.prev = 7;
                            _context.t0 = _context["catch"](0);
                            logger.error("".concat(upperSnake(name), "_EVENT_ERROR"), _context.t0);
                        case 10:
                        case "end":
                            return _context.stop();
                    }
                }
            }, _callee, null, [
                [
                    0,
                    7
                ]
            ]);
        }));
        return acc;
    }, {});
}
function adapterErrorHandler(adapter, logger) {
    if (!adapter) return;
    return Object.keys(adapter).reduce(function(acc, name) {
        acc[name] = (0, _asyncToGenerator2.default)(_regenerator.default.mark(function _callee2() {
            var _len10, args, _key10, method, e, _args2 = arguments;
            return _regenerator.default.wrap(function _callee2$(_context2) {
                while(1){
                    switch(_context2.prev = _context2.next){
                        case 0:
                            _context2.prev = 0;
                            for(_len10 = _args2.length, args = new Array(_len10), _key10 = 0; _key10 < _len10; _key10++){
                                args[_key10] = _args2[_key10];
                            }
                            logger.debug("adapter_".concat(name), {
                                args: args
                            });
                            method = adapter[name];
                            _context2.next = 6;
                            return method.apply(void 0, args);
                        case 6:
                            return _context2.abrupt("return", _context2.sent);
                        case 9:
                            _context2.prev = 9;
                            _context2.t0 = _context2["catch"](0);
                            logger.error("adapter_error_".concat(name), _context2.t0);
                            e = new UnknownError(_context2.t0);
                            e.name = "".concat(capitalize(name), "Error");
                            throw e;
                        case 15:
                        case "end":
                            return _context2.stop();
                    }
                }
            }, _callee2, null, [
                [
                    0,
                    9
                ]
            ]);
        }));
        return acc;
    }, {});
}


/***/ }),

/***/ 71646:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(69124);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.AuthHandler = AuthHandler;
var _logger = _interopRequireWildcard(__webpack_require__(96828));
var _detectOrigin = __webpack_require__(48775);
var routes = _interopRequireWildcard(__webpack_require__(58608));
var _pages = _interopRequireDefault(__webpack_require__(58518));
var _init = __webpack_require__(60828);
var _assert = __webpack_require__(52234);
var _cookie = __webpack_require__(75310);
var _cookie2 = __webpack_require__(87445);
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
async function getBody(req) {
    try {
        return await req.json();
    } catch (_unused) {}
}
async function toInternalRequest(req) {
    var _headers$xForwarded2;
    if (req instanceof Request) {
        var _req$headers$get, _url$searchParams$get, _headers$xForwarded;
        const url = new URL(req.url);
        const nextauth = url.pathname.split("/").slice(3);
        const headers = Object.fromEntries(req.headers);
        const query = Object.fromEntries(url.searchParams);
        query.nextauth = nextauth;
        return {
            action: nextauth[0],
            method: req.method,
            headers,
            body: await getBody(req),
            cookies: (0, _cookie2.parse)((_req$headers$get = req.headers.get("cookie")) !== null && _req$headers$get !== void 0 ? _req$headers$get : ""),
            providerId: nextauth[1],
            error: (_url$searchParams$get = url.searchParams.get("error")) !== null && _url$searchParams$get !== void 0 ? _url$searchParams$get : nextauth[1],
            origin: (0, _detectOrigin.detectOrigin)((_headers$xForwarded = headers["x-forwarded-host"]) !== null && _headers$xForwarded !== void 0 ? _headers$xForwarded : headers.host, headers["x-forwarded-proto"]),
            query
        };
    }
    const { headers } = req;
    const host = (_headers$xForwarded2 = headers === null || headers === void 0 ? void 0 : headers["x-forwarded-host"]) !== null && _headers$xForwarded2 !== void 0 ? _headers$xForwarded2 : headers === null || headers === void 0 ? void 0 : headers.host;
    req.origin = (0, _detectOrigin.detectOrigin)(host, headers === null || headers === void 0 ? void 0 : headers["x-forwarded-proto"]);
    return req;
}
async function AuthHandler(params) {
    var _req$body$callbackUrl, _req$body, _req$query2, _req$body2;
    const { options: authOptions, req: incomingRequest } = params;
    const req = await toInternalRequest(incomingRequest);
    (0, _logger.setLogger)(authOptions.logger, authOptions.debug);
    const assertionResult = (0, _assert.assertConfig)({
        options: authOptions,
        req
    });
    if (Array.isArray(assertionResult)) {
        assertionResult.forEach(_logger.default.warn);
    } else if (assertionResult instanceof Error) {
        var _req$query, _req$query$callbackUr;
        _logger.default.error(assertionResult.code, assertionResult);
        const htmlPages = [
            "signin",
            "signout",
            "error",
            "verify-request"
        ];
        if (!htmlPages.includes(req.action) || req.method !== "GET") {
            const message = `There is a problem with the server configuration. Check the server logs for more information.`;
            return {
                status: 500,
                headers: [
                    {
                        key: "Content-Type",
                        value: "application/json"
                    }
                ],
                body: {
                    message
                }
            };
        }
        const { pages, theme } = authOptions;
        const authOnErrorPage = (pages === null || pages === void 0 ? void 0 : pages.error) && ((_req$query = req.query) === null || _req$query === void 0 ? void 0 : (_req$query$callbackUr = _req$query.callbackUrl) === null || _req$query$callbackUr === void 0 ? void 0 : _req$query$callbackUr.startsWith(pages.error));
        if (!(pages !== null && pages !== void 0 && pages.error) || authOnErrorPage) {
            if (authOnErrorPage) {
                _logger.default.error("AUTH_ON_ERROR_PAGE_ERROR", new Error(`The error page ${pages === null || pages === void 0 ? void 0 : pages.error} should not require authentication`));
            }
            const render = (0, _pages.default)({
                theme
            });
            return render.error({
                error: "configuration"
            });
        }
        return {
            redirect: `${pages.error}?error=Configuration`
        };
    }
    const { action, providerId, error, method = "GET" } = req;
    const { options, cookies } = await (0, _init.init)({
        authOptions,
        action,
        providerId,
        origin: req.origin,
        callbackUrl: (_req$body$callbackUrl = (_req$body = req.body) === null || _req$body === void 0 ? void 0 : _req$body.callbackUrl) !== null && _req$body$callbackUrl !== void 0 ? _req$body$callbackUrl : (_req$query2 = req.query) === null || _req$query2 === void 0 ? void 0 : _req$query2.callbackUrl,
        csrfToken: (_req$body2 = req.body) === null || _req$body2 === void 0 ? void 0 : _req$body2.csrfToken,
        cookies: req.cookies,
        isPost: method === "POST"
    });
    const sessionStore = new _cookie.SessionStore(options.cookies.sessionToken, req, options.logger);
    if (method === "GET") {
        const render = (0, _pages.default)({
            ...options,
            query: req.query,
            cookies
        });
        const { pages } = options;
        switch(action){
            case "providers":
                return await routes.providers(options.providers);
            case "session":
                {
                    const session = await routes.session({
                        options,
                        sessionStore
                    });
                    if (session.cookies) cookies.push(...session.cookies);
                    return {
                        ...session,
                        cookies
                    };
                }
            case "csrf":
                return {
                    headers: [
                        {
                            key: "Content-Type",
                            value: "application/json"
                        }
                    ],
                    body: {
                        csrfToken: options.csrfToken
                    },
                    cookies
                };
            case "signin":
                if (pages.signIn) {
                    let signinUrl = `${pages.signIn}${pages.signIn.includes("?") ? "&" : "?"}callbackUrl=${encodeURIComponent(options.callbackUrl)}`;
                    if (error) signinUrl = `${signinUrl}&error=${encodeURIComponent(error)}`;
                    return {
                        redirect: signinUrl,
                        cookies
                    };
                }
                return render.signin();
            case "signout":
                if (pages.signOut) return {
                    redirect: pages.signOut,
                    cookies
                };
                return render.signout();
            case "callback":
                if (options.provider) {
                    const callback = await routes.callback({
                        body: req.body,
                        query: req.query,
                        headers: req.headers,
                        cookies: req.cookies,
                        method,
                        options,
                        sessionStore
                    });
                    if (callback.cookies) cookies.push(...callback.cookies);
                    return {
                        ...callback,
                        cookies
                    };
                }
                break;
            case "verify-request":
                if (pages.verifyRequest) {
                    return {
                        redirect: pages.verifyRequest,
                        cookies
                    };
                }
                return render.verifyRequest();
            case "error":
                if ([
                    "Signin",
                    "OAuthSignin",
                    "OAuthCallback",
                    "OAuthCreateAccount",
                    "EmailCreateAccount",
                    "Callback",
                    "OAuthAccountNotLinked",
                    "EmailSignin",
                    "CredentialsSignin",
                    "SessionRequired"
                ].includes(error)) {
                    return {
                        redirect: `${options.url}/signin?error=${error}`,
                        cookies
                    };
                }
                if (pages.error) {
                    return {
                        redirect: `${pages.error}${pages.error.includes("?") ? "&" : "?"}error=${error}`,
                        cookies
                    };
                }
                return render.error({
                    error: error
                });
            default:
        }
    } else if (method === "POST") {
        switch(action){
            case "signin":
                if (options.csrfTokenVerified && options.provider) {
                    const signin = await routes.signin({
                        query: req.query,
                        body: req.body,
                        options
                    });
                    if (signin.cookies) cookies.push(...signin.cookies);
                    return {
                        ...signin,
                        cookies
                    };
                }
                return {
                    redirect: `${options.url}/signin?csrf=true`,
                    cookies
                };
            case "signout":
                if (options.csrfTokenVerified) {
                    const signout = await routes.signout({
                        options,
                        sessionStore
                    });
                    if (signout.cookies) cookies.push(...signout.cookies);
                    return {
                        ...signout,
                        cookies
                    };
                }
                return {
                    redirect: `${options.url}/signout?csrf=true`,
                    cookies
                };
            case "callback":
                if (options.provider) {
                    if (options.provider.type === "credentials" && !options.csrfTokenVerified) {
                        return {
                            redirect: `${options.url}/signin?csrf=true`,
                            cookies
                        };
                    }
                    const callback = await routes.callback({
                        body: req.body,
                        query: req.query,
                        headers: req.headers,
                        cookies: req.cookies,
                        method,
                        options,
                        sessionStore
                    });
                    if (callback.cookies) cookies.push(...callback.cookies);
                    return {
                        ...callback,
                        cookies
                    };
                }
                break;
            case "_log":
                {
                    if (authOptions.logger) {
                        try {
                            var _req$body3;
                            const { code, level, ...metadata } = (_req$body3 = req.body) !== null && _req$body3 !== void 0 ? _req$body3 : {};
                            _logger.default[level](code, metadata);
                        } catch (error) {
                            _logger.default.error("LOGGER_ERROR", error);
                        }
                    }
                    return {};
                }
            case "session":
                {
                    if (options.csrfTokenVerified) {
                        var _req$body4;
                        const session = await routes.session({
                            options,
                            sessionStore,
                            newSession: (_req$body4 = req.body) === null || _req$body4 === void 0 ? void 0 : _req$body4.data,
                            isUpdate: true
                        });
                        if (session.cookies) cookies.push(...session.cookies);
                        return {
                            ...session,
                            cookies
                        };
                    }
                    return {
                        status: 400,
                        body: {},
                        cookies
                    };
                }
            default:
        }
    }
    return {
        status: 400,
        body: `Error: This action with HTTP ${method} is not supported by NextAuth.js`
    };
}


/***/ }),

/***/ 60828:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(69124);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.init = init;
var _crypto = __webpack_require__(6113);
var _logger = _interopRequireDefault(__webpack_require__(96828));
var _errors = __webpack_require__(41594);
var _providers = _interopRequireDefault(__webpack_require__(64229));
var _utils = __webpack_require__(95134);
var cookie = _interopRequireWildcard(__webpack_require__(75310));
var jwt = _interopRequireWildcard(__webpack_require__(80789));
var _defaultCallbacks = __webpack_require__(89403);
var _csrfToken = __webpack_require__(67023);
var _callbackUrl = __webpack_require__(7541);
var _parseUrl = _interopRequireDefault(__webpack_require__(36150));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
async function init({ authOptions, providerId, action, origin, cookies: reqCookies, callbackUrl: reqCallbackUrl, csrfToken: reqCsrfToken, isPost }) {
    var _authOptions$useSecur, _authOptions$events;
    const url = (0, _parseUrl.default)(origin);
    const secret = (0, _utils.createSecret)({
        authOptions,
        url
    });
    const { providers, provider } = (0, _providers.default)({
        providers: authOptions.providers,
        url,
        providerId
    });
    const maxAge = 30 * 24 * 60 * 60;
    const options = {
        debug: false,
        pages: {},
        theme: {
            colorScheme: "auto",
            logo: "",
            brandColor: "",
            buttonText: ""
        },
        ...authOptions,
        url,
        action,
        provider,
        cookies: {
            ...cookie.defaultCookies((_authOptions$useSecur = authOptions.useSecureCookies) !== null && _authOptions$useSecur !== void 0 ? _authOptions$useSecur : url.base.startsWith("https://")),
            ...authOptions.cookies
        },
        secret,
        providers,
        session: {
            strategy: authOptions.adapter ? "database" : "jwt",
            maxAge,
            updateAge: 24 * 60 * 60,
            generateSessionToken: ()=>{
                var _randomUUID;
                return (_randomUUID = _crypto.randomUUID === null || _crypto.randomUUID === void 0 ? void 0 : (0, _crypto.randomUUID)()) !== null && _randomUUID !== void 0 ? _randomUUID : (0, _crypto.randomBytes)(32).toString("hex");
            },
            ...authOptions.session
        },
        jwt: {
            secret,
            maxAge,
            encode: jwt.encode,
            decode: jwt.decode,
            ...authOptions.jwt
        },
        events: (0, _errors.eventsErrorHandler)((_authOptions$events = authOptions.events) !== null && _authOptions$events !== void 0 ? _authOptions$events : {}, _logger.default),
        adapter: (0, _errors.adapterErrorHandler)(authOptions.adapter, _logger.default),
        callbacks: {
            ..._defaultCallbacks.defaultCallbacks,
            ...authOptions.callbacks
        },
        logger: _logger.default,
        callbackUrl: url.origin
    };
    const cookies = [];
    const { csrfToken, cookie: csrfCookie, csrfTokenVerified } = (0, _csrfToken.createCSRFToken)({
        options,
        cookieValue: reqCookies === null || reqCookies === void 0 ? void 0 : reqCookies[options.cookies.csrfToken.name],
        isPost,
        bodyValue: reqCsrfToken
    });
    options.csrfToken = csrfToken;
    options.csrfTokenVerified = csrfTokenVerified;
    if (csrfCookie) {
        cookies.push({
            name: options.cookies.csrfToken.name,
            value: csrfCookie,
            options: options.cookies.csrfToken.options
        });
    }
    const { callbackUrl, callbackUrlCookie } = await (0, _callbackUrl.createCallbackUrl)({
        options,
        cookieValue: reqCookies === null || reqCookies === void 0 ? void 0 : reqCookies[options.cookies.callbackUrl.name],
        paramValue: reqCallbackUrl
    });
    options.callbackUrl = callbackUrl;
    if (callbackUrlCookie) {
        cookies.push({
            name: options.cookies.callbackUrl.name,
            value: callbackUrlCookie,
            options: options.cookies.callbackUrl.options
        });
    }
    return {
        options,
        cookies
    };
}


/***/ }),

/***/ 52234:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(69124);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.assertConfig = assertConfig;
var _errors = __webpack_require__(41594);
var _parseUrl = _interopRequireDefault(__webpack_require__(36150));
var _cookie = __webpack_require__(75310);
let warned = false;
function isValidHttpUrl(url, baseUrl) {
    try {
        return /^https?:/.test(new URL(url, url.startsWith("/") ? baseUrl : undefined).protocol);
    } catch (_unused) {
        return false;
    }
}
function assertConfig(params) {
    var _req$query, _req$query2, _options$useSecureCoo, _req$cookies, _options$cookies$call, _options$cookies, _options$cookies$call2;
    const { options, req } = params;
    const warnings = [];
    if (!warned) {
        if (!req.origin) warnings.push("NEXTAUTH_URL");
        if (!options.secret && "production" !== "production") {}
        if (options.debug) warnings.push("DEBUG_ENABLED");
    }
    if (!options.secret && "production" === "production") {
        return new _errors.MissingSecret("Please define a `secret` in production.");
    }
    if (!((_req$query = req.query) !== null && _req$query !== void 0 && _req$query.nextauth) && !req.action) {
        return new _errors.MissingAPIRoute("Cannot find [...nextauth].{js,ts} in `/pages/api/auth`. Make sure the filename is written correctly.");
    }
    const callbackUrlParam = (_req$query2 = req.query) === null || _req$query2 === void 0 ? void 0 : _req$query2.callbackUrl;
    const url = (0, _parseUrl.default)(req.origin);
    if (callbackUrlParam && !isValidHttpUrl(callbackUrlParam, url.base)) {
        return new _errors.InvalidCallbackUrl(`Invalid callback URL. Received: ${callbackUrlParam}`);
    }
    const { callbackUrl: defaultCallbackUrl } = (0, _cookie.defaultCookies)((_options$useSecureCoo = options.useSecureCookies) !== null && _options$useSecureCoo !== void 0 ? _options$useSecureCoo : url.base.startsWith("https://"));
    const callbackUrlCookie = (_req$cookies = req.cookies) === null || _req$cookies === void 0 ? void 0 : _req$cookies[(_options$cookies$call = (_options$cookies = options.cookies) === null || _options$cookies === void 0 ? void 0 : (_options$cookies$call2 = _options$cookies.callbackUrl) === null || _options$cookies$call2 === void 0 ? void 0 : _options$cookies$call2.name) !== null && _options$cookies$call !== void 0 ? _options$cookies$call : defaultCallbackUrl.name];
    if (callbackUrlCookie && !isValidHttpUrl(callbackUrlCookie, url.base)) {
        return new _errors.InvalidCallbackUrl(`Invalid callback URL. Received: ${callbackUrlCookie}`);
    }
    let hasCredentials, hasEmail;
    let hasTwitterOAuth2;
    for (const provider of options.providers){
        if (provider.type === "credentials") hasCredentials = true;
        else if (provider.type === "email") hasEmail = true;
        else if (provider.id === "twitter" && provider.version === "2.0") hasTwitterOAuth2 = true;
    }
    if (hasCredentials) {
        var _options$session;
        const dbStrategy = ((_options$session = options.session) === null || _options$session === void 0 ? void 0 : _options$session.strategy) === "database";
        const onlyCredentials = !options.providers.some((p)=>p.type !== "credentials");
        if (dbStrategy && onlyCredentials) {
            return new _errors.UnsupportedStrategy("Signin in with credentials only supported if JWT strategy is enabled");
        }
        const credentialsNoAuthorize = options.providers.some((p)=>p.type === "credentials" && !p.authorize);
        if (credentialsNoAuthorize) {
            return new _errors.MissingAuthorize("Must define an authorize() handler to use credentials authentication provider");
        }
    }
    if (hasEmail) {
        const { adapter } = options;
        if (!adapter) {
            return new _errors.MissingAdapter("E-mail login requires an adapter.");
        }
        const missingMethods = [
            "createVerificationToken",
            "useVerificationToken",
            "getUserByEmail"
        ].filter((method)=>!adapter[method]);
        if (missingMethods.length) {
            return new _errors.MissingAdapterMethods(`Required adapter methods were missing: ${missingMethods.join(", ")}`);
        }
    }
    if (!warned) {
        if (hasTwitterOAuth2) warnings.push("TWITTER_OAUTH_2_BETA");
        warned = true;
    }
    return warnings;
}


/***/ }),

/***/ 64195:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = callbackHandler;
var _errors = __webpack_require__(41594);
var _utils = __webpack_require__(95134);
async function callbackHandler(params) {
    const { sessionToken, profile: _profile, account, options } = params;
    if (!(account !== null && account !== void 0 && account.providerAccountId) || !account.type) throw new Error("Missing or invalid provider account");
    if (![
        "email",
        "oauth"
    ].includes(account.type)) throw new Error("Provider not supported");
    const { adapter, jwt, events, session: { strategy: sessionStrategy, generateSessionToken } } = options;
    if (!adapter) {
        return {
            user: _profile,
            account
        };
    }
    const profile = _profile;
    const { createUser, updateUser, getUser, getUserByAccount, getUserByEmail, linkAccount, createSession, getSessionAndUser, deleteSession } = adapter;
    let session = null;
    let user = null;
    let isNewUser = false;
    const useJwtSession = sessionStrategy === "jwt";
    if (sessionToken) {
        if (useJwtSession) {
            try {
                session = await jwt.decode({
                    ...jwt,
                    token: sessionToken
                });
                if (session && "sub" in session && session.sub) {
                    user = await getUser(session.sub);
                }
            } catch (_unused) {}
        } else {
            const userAndSession = await getSessionAndUser(sessionToken);
            if (userAndSession) {
                session = userAndSession.session;
                user = userAndSession.user;
            }
        }
    }
    if (account.type === "email") {
        const userByEmail = await getUserByEmail(profile.email);
        if (userByEmail) {
            var _user, _events$updateUser;
            if (((_user = user) === null || _user === void 0 ? void 0 : _user.id) !== userByEmail.id && !useJwtSession && sessionToken) {
                await deleteSession(sessionToken);
            }
            user = await updateUser({
                id: userByEmail.id,
                emailVerified: new Date()
            });
            await ((_events$updateUser = events.updateUser) === null || _events$updateUser === void 0 ? void 0 : _events$updateUser.call(events, {
                user
            }));
        } else {
            var _events$createUser;
            const { id: _, ...newUser } = {
                ...profile,
                emailVerified: new Date()
            };
            user = await createUser(newUser);
            await ((_events$createUser = events.createUser) === null || _events$createUser === void 0 ? void 0 : _events$createUser.call(events, {
                user
            }));
            isNewUser = true;
        }
        session = useJwtSession ? {} : await createSession({
            sessionToken: await generateSessionToken(),
            userId: user.id,
            expires: (0, _utils.fromDate)(options.session.maxAge)
        });
        return {
            session,
            user,
            isNewUser
        };
    } else if (account.type === "oauth") {
        const userByAccount = await getUserByAccount({
            providerAccountId: account.providerAccountId,
            provider: account.provider
        });
        if (userByAccount) {
            if (user) {
                if (userByAccount.id === user.id) {
                    return {
                        session,
                        user,
                        isNewUser
                    };
                }
                throw new _errors.AccountNotLinkedError("The account is already associated with another user");
            }
            session = useJwtSession ? {} : await createSession({
                sessionToken: await generateSessionToken(),
                userId: userByAccount.id,
                expires: (0, _utils.fromDate)(options.session.maxAge)
            });
            return {
                session,
                user: userByAccount,
                isNewUser
            };
        } else {
            var _events$createUser2, _events$linkAccount2;
            if (user) {
                var _events$linkAccount;
                await linkAccount({
                    ...account,
                    userId: user.id
                });
                await ((_events$linkAccount = events.linkAccount) === null || _events$linkAccount === void 0 ? void 0 : _events$linkAccount.call(events, {
                    user,
                    account,
                    profile
                }));
                return {
                    session,
                    user,
                    isNewUser
                };
            }
            const userByEmail = profile.email ? await getUserByEmail(profile.email) : null;
            if (userByEmail) {
                const provider = options.provider;
                if (provider !== null && provider !== void 0 && provider.allowDangerousEmailAccountLinking) {
                    user = userByEmail;
                } else {
                    throw new _errors.AccountNotLinkedError("Another account already exists with the same e-mail address");
                }
            } else {
                const { id: _, ...newUser } = {
                    ...profile,
                    emailVerified: null
                };
                user = await createUser(newUser);
            }
            await ((_events$createUser2 = events.createUser) === null || _events$createUser2 === void 0 ? void 0 : _events$createUser2.call(events, {
                user
            }));
            await linkAccount({
                ...account,
                userId: user.id
            });
            await ((_events$linkAccount2 = events.linkAccount) === null || _events$linkAccount2 === void 0 ? void 0 : _events$linkAccount2.call(events, {
                user,
                account,
                profile
            }));
            session = useJwtSession ? {} : await createSession({
                sessionToken: await generateSessionToken(),
                userId: user.id,
                expires: (0, _utils.fromDate)(options.session.maxAge)
            });
            return {
                session,
                user,
                isNewUser: true
            };
        }
    }
    throw new Error("Unsupported account type");
}


/***/ }),

/***/ 7541:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createCallbackUrl = createCallbackUrl;
async function createCallbackUrl({ options, paramValue, cookieValue }) {
    const { url, callbacks } = options;
    let callbackUrl = url.origin;
    if (paramValue) {
        callbackUrl = await callbacks.redirect({
            url: paramValue,
            baseUrl: url.origin
        });
    } else if (cookieValue) {
        callbackUrl = await callbacks.redirect({
            url: cookieValue,
            baseUrl: url.origin
        });
    }
    return {
        callbackUrl,
        callbackUrlCookie: callbackUrl !== cookieValue ? callbackUrl : undefined
    };
}


/***/ }),

/***/ 67023:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createCSRFToken = createCSRFToken;
var _crypto = __webpack_require__(6113);
function createCSRFToken({ options, cookieValue, isPost, bodyValue }) {
    if (cookieValue) {
        const [csrfToken, csrfTokenHash] = cookieValue.split("|");
        const expectedCsrfTokenHash = (0, _crypto.createHash)("sha256").update(`${csrfToken}${options.secret}`).digest("hex");
        if (csrfTokenHash === expectedCsrfTokenHash) {
            const csrfTokenVerified = isPost && csrfToken === bodyValue;
            return {
                csrfTokenVerified,
                csrfToken
            };
        }
    }
    const csrfToken = (0, _crypto.randomBytes)(32).toString("hex");
    const csrfTokenHash = (0, _crypto.createHash)("sha256").update(`${csrfToken}${options.secret}`).digest("hex");
    const cookie = `${csrfToken}|${csrfTokenHash}`;
    return {
        cookie,
        csrfToken
    };
}


/***/ }),

/***/ 89403:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.defaultCallbacks = void 0;
const defaultCallbacks = {
    signIn () {
        return true;
    },
    redirect ({ url, baseUrl }) {
        if (url.startsWith("/")) return `${baseUrl}${url}`;
        else if (new URL(url).origin === baseUrl) return url;
        return baseUrl;
    },
    session ({ session }) {
        return session;
    },
    jwt ({ token }) {
        return token;
    }
};
exports.defaultCallbacks = defaultCallbacks;


/***/ }),

/***/ 39274:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = getAdapterUserFromEmail;
async function getAdapterUserFromEmail({ email, adapter }) {
    const { getUserByEmail } = adapter;
    const adapterUser = email ? await getUserByEmail(email) : null;
    if (adapterUser) return adapterUser;
    return {
        id: email,
        email,
        emailVerified: null
    };
}


/***/ }),

/***/ 34056:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = email;
var _crypto = __webpack_require__(6113);
var _utils = __webpack_require__(95134);
async function email(identifier, options) {
    var _await$provider$gener, _provider$generateVer, _provider$maxAge, _adapter$createVerifi;
    const { url, adapter, provider, callbackUrl, theme } = options;
    const token = (_await$provider$gener = await ((_provider$generateVer = provider.generateVerificationToken) === null || _provider$generateVer === void 0 ? void 0 : _provider$generateVer.call(provider))) !== null && _await$provider$gener !== void 0 ? _await$provider$gener : (0, _crypto.randomBytes)(32).toString("hex");
    const ONE_DAY_IN_SECONDS = 86400;
    const expires = new Date(Date.now() + ((_provider$maxAge = provider.maxAge) !== null && _provider$maxAge !== void 0 ? _provider$maxAge : ONE_DAY_IN_SECONDS) * 1000);
    const params = new URLSearchParams({
        callbackUrl,
        token,
        email: identifier
    });
    const _url = `${url}/callback/${provider.id}?${params}`;
    await Promise.all([
        provider.sendVerificationRequest({
            identifier,
            token,
            expires,
            url: _url,
            provider,
            theme
        }),
        (_adapter$createVerifi = adapter.createVerificationToken) === null || _adapter$createVerifi === void 0 ? void 0 : _adapter$createVerifi.call(adapter, {
            identifier,
            token: (0, _utils.hashToken)(token, options),
            expires
        })
    ]);
    return `${url}/verify-request?${new URLSearchParams({
        provider: provider.id,
        type: provider.type
    })}`;
}


/***/ }),

/***/ 70782:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = getAuthorizationUrl;
var _client = __webpack_require__(19914);
var _clientLegacy = __webpack_require__(92512);
var checks = _interopRequireWildcard(__webpack_require__(7698));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
async function getAuthorizationUrl({ options, query }) {
    var _provider$version;
    const { logger, provider } = options;
    let params = {};
    if (typeof provider.authorization === "string") {
        const parsedUrl = new URL(provider.authorization);
        const parsedParams = Object.fromEntries(parsedUrl.searchParams);
        params = {
            ...params,
            ...parsedParams
        };
    } else {
        var _provider$authorizati;
        params = {
            ...params,
            ...(_provider$authorizati = provider.authorization) === null || _provider$authorizati === void 0 ? void 0 : _provider$authorizati.params
        };
    }
    params = {
        ...params,
        ...query
    };
    if ((_provider$version = provider.version) !== null && _provider$version !== void 0 && _provider$version.startsWith("1.")) {
        var _provider$authorizati2;
        const client = (0, _clientLegacy.oAuth1Client)(options);
        const tokens = await client.getOAuthRequestToken(params);
        const url = `${(_provider$authorizati2 = provider.authorization) === null || _provider$authorizati2 === void 0 ? void 0 : _provider$authorizati2.url}?${new URLSearchParams({
            oauth_token: tokens.oauth_token,
            oauth_token_secret: tokens.oauth_token_secret,
            ...tokens.params
        })}`;
        _clientLegacy.oAuth1TokenStore.set(tokens.oauth_token, tokens.oauth_token_secret);
        logger.debug("GET_AUTHORIZATION_URL", {
            url,
            provider
        });
        return {
            redirect: url
        };
    }
    const client = await (0, _client.openidClient)(options);
    const authorizationParams = params;
    const cookies = [];
    await checks.state.create(options, cookies, authorizationParams);
    await checks.pkce.create(options, cookies, authorizationParams);
    await checks.nonce.create(options, cookies, authorizationParams);
    const url = client.authorizationUrl(authorizationParams);
    logger.debug("GET_AUTHORIZATION_URL", {
        url,
        cookies,
        provider
    });
    return {
        redirect: url,
        cookies
    };
}


/***/ }),

/***/ 80623:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = oAuthCallback;
var _openidClient = __webpack_require__(32698);
var _client = __webpack_require__(19914);
var _clientLegacy = __webpack_require__(92512);
var _checks = _interopRequireWildcard(__webpack_require__(7698));
var _errors = __webpack_require__(41594);
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
async function oAuthCallback(params) {
    var _body$error, _provider$version;
    const { options, query, body, method, cookies } = params;
    const { logger, provider } = options;
    const errorMessage = (_body$error = body === null || body === void 0 ? void 0 : body.error) !== null && _body$error !== void 0 ? _body$error : query === null || query === void 0 ? void 0 : query.error;
    if (errorMessage) {
        const error = new Error(errorMessage);
        logger.error("OAUTH_CALLBACK_HANDLER_ERROR", {
            error,
            error_description: query === null || query === void 0 ? void 0 : query.error_description,
            providerId: provider.id
        });
        logger.debug("OAUTH_CALLBACK_HANDLER_ERROR", {
            body
        });
        throw error;
    }
    if ((_provider$version = provider.version) !== null && _provider$version !== void 0 && _provider$version.startsWith("1.")) {
        try {
            const client = await (0, _clientLegacy.oAuth1Client)(options);
            const { oauth_token, oauth_verifier } = query !== null && query !== void 0 ? query : {};
            const tokens = await client.getOAuthAccessToken(oauth_token, _clientLegacy.oAuth1TokenStore.get(oauth_token), oauth_verifier);
            let profile = await client.get(provider.profileUrl, tokens.oauth_token, tokens.oauth_token_secret);
            if (typeof profile === "string") {
                profile = JSON.parse(profile);
            }
            const newProfile = await getProfile({
                profile,
                tokens,
                provider,
                logger
            });
            return {
                ...newProfile,
                cookies: []
            };
        } catch (error) {
            logger.error("OAUTH_V1_GET_ACCESS_TOKEN_ERROR", error);
            throw error;
        }
    }
    if (query !== null && query !== void 0 && query.oauth_token) _clientLegacy.oAuth1TokenStore.delete(query.oauth_token);
    try {
        var _provider$token, _provider$token2, _provider$userinfo;
        const client = await (0, _client.openidClient)(options);
        let tokens;
        const checks = {};
        const resCookies = [];
        await _checks.state.use(cookies, resCookies, options, checks);
        await _checks.pkce.use(cookies, resCookies, options, checks);
        await _checks.nonce.use(cookies, resCookies, options, checks);
        const params = {
            ...client.callbackParams({
                url: `http://n?${new URLSearchParams(query)}`,
                body,
                method
            }),
            ...(_provider$token = provider.token) === null || _provider$token === void 0 ? void 0 : _provider$token.params
        };
        if ((_provider$token2 = provider.token) !== null && _provider$token2 !== void 0 && _provider$token2.request) {
            const response = await provider.token.request({
                provider,
                params,
                checks,
                client
            });
            tokens = new _openidClient.TokenSet(response.tokens);
        } else if (provider.idToken) {
            tokens = await client.callback(provider.callbackUrl, params, checks);
        } else {
            tokens = await client.oauthCallback(provider.callbackUrl, params, checks);
        }
        if (Array.isArray(tokens.scope)) {
            tokens.scope = tokens.scope.join(" ");
        }
        let profile;
        if ((_provider$userinfo = provider.userinfo) !== null && _provider$userinfo !== void 0 && _provider$userinfo.request) {
            profile = await provider.userinfo.request({
                provider,
                tokens,
                client
            });
        } else if (provider.idToken) {
            profile = tokens.claims();
        } else {
            var _provider$userinfo2;
            profile = await client.userinfo(tokens, {
                params: (_provider$userinfo2 = provider.userinfo) === null || _provider$userinfo2 === void 0 ? void 0 : _provider$userinfo2.params
            });
        }
        const profileResult = await getProfile({
            profile,
            provider,
            tokens,
            logger
        });
        return {
            ...profileResult,
            cookies: resCookies
        };
    } catch (error) {
        throw new _errors.OAuthCallbackError(error);
    }
}
async function getProfile({ profile: OAuthProfile, tokens, provider, logger }) {
    try {
        var _profile$email;
        logger.debug("PROFILE_DATA", {
            OAuthProfile
        });
        const profile = await provider.profile(OAuthProfile, tokens);
        profile.email = (_profile$email = profile.email) === null || _profile$email === void 0 ? void 0 : _profile$email.toLowerCase();
        if (!profile.id) throw new TypeError(`Profile id is missing in ${provider.name} OAuth profile response`);
        return {
            profile,
            account: {
                provider: provider.id,
                type: provider.type,
                providerAccountId: profile.id.toString(),
                ...tokens
            },
            OAuthProfile
        };
    } catch (error) {
        logger.error("OAUTH_PARSE_PROFILE_ERROR", {
            error: error,
            OAuthProfile
        });
    }
}


/***/ }),

/***/ 7698:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.pkce = exports.nonce = exports.PKCE_CODE_CHALLENGE_METHOD = void 0;
exports.signCookie = signCookie;
exports.state = void 0;
var _openidClient = __webpack_require__(32698);
var jwt = _interopRequireWildcard(__webpack_require__(80789));
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}
async function signCookie(type, value, maxAge, options) {
    const { cookies, logger } = options;
    logger.debug(`CREATE_${type.toUpperCase()}`, {
        value,
        maxAge
    });
    const expires = new Date();
    expires.setTime(expires.getTime() + maxAge * 1000);
    return {
        name: cookies[type].name,
        value: await jwt.encode({
            ...options.jwt,
            maxAge,
            token: {
                value
            }
        }),
        options: {
            ...cookies[type].options,
            expires
        }
    };
}
const PKCE_MAX_AGE = 60 * 15;
const PKCE_CODE_CHALLENGE_METHOD = "S256";
exports.PKCE_CODE_CHALLENGE_METHOD = PKCE_CODE_CHALLENGE_METHOD;
const pkce = {
    async create (options, cookies, resParams) {
        var _options$provider, _options$provider$che, _options$cookies$pkce;
        if (!((_options$provider = options.provider) !== null && _options$provider !== void 0 && (_options$provider$che = _options$provider.checks) !== null && _options$provider$che !== void 0 && _options$provider$che.includes("pkce"))) return;
        const code_verifier = _openidClient.generators.codeVerifier();
        const value = _openidClient.generators.codeChallenge(code_verifier);
        resParams.code_challenge = value;
        resParams.code_challenge_method = PKCE_CODE_CHALLENGE_METHOD;
        const maxAge = (_options$cookies$pkce = options.cookies.pkceCodeVerifier.options.maxAge) !== null && _options$cookies$pkce !== void 0 ? _options$cookies$pkce : PKCE_MAX_AGE;
        cookies.push(await signCookie("pkceCodeVerifier", code_verifier, maxAge, options));
    },
    async use (cookies, resCookies, options, checks) {
        var _options$provider2, _options$provider2$ch;
        if (!((_options$provider2 = options.provider) !== null && _options$provider2 !== void 0 && (_options$provider2$ch = _options$provider2.checks) !== null && _options$provider2$ch !== void 0 && _options$provider2$ch.includes("pkce"))) return;
        const codeVerifier = cookies === null || cookies === void 0 ? void 0 : cookies[options.cookies.pkceCodeVerifier.name];
        if (!codeVerifier) throw new TypeError("PKCE code_verifier cookie was missing.");
        const value = await jwt.decode({
            ...options.jwt,
            token: codeVerifier
        });
        if (!(value !== null && value !== void 0 && value.value)) throw new TypeError("PKCE code_verifier value could not be parsed.");
        resCookies.push({
            name: options.cookies.pkceCodeVerifier.name,
            value: "",
            options: {
                ...options.cookies.pkceCodeVerifier.options,
                maxAge: 0
            }
        });
        checks.code_verifier = value.value;
    }
};
exports.pkce = pkce;
const STATE_MAX_AGE = 60 * 15;
const state = {
    async create (options, cookies, resParams) {
        var _options$provider$che2, _options$cookies$stat;
        if (!((_options$provider$che2 = options.provider.checks) !== null && _options$provider$che2 !== void 0 && _options$provider$che2.includes("state"))) return;
        const value = _openidClient.generators.state();
        resParams.state = value;
        const maxAge = (_options$cookies$stat = options.cookies.state.options.maxAge) !== null && _options$cookies$stat !== void 0 ? _options$cookies$stat : STATE_MAX_AGE;
        cookies.push(await signCookie("state", value, maxAge, options));
    },
    async use (cookies, resCookies, options, checks) {
        var _options$provider$che3;
        if (!((_options$provider$che3 = options.provider.checks) !== null && _options$provider$che3 !== void 0 && _options$provider$che3.includes("state"))) return;
        const state = cookies === null || cookies === void 0 ? void 0 : cookies[options.cookies.state.name];
        if (!state) throw new TypeError("State cookie was missing.");
        const value = await jwt.decode({
            ...options.jwt,
            token: state
        });
        if (!(value !== null && value !== void 0 && value.value)) throw new TypeError("State value could not be parsed.");
        resCookies.push({
            name: options.cookies.state.name,
            value: "",
            options: {
                ...options.cookies.state.options,
                maxAge: 0
            }
        });
        checks.state = value.value;
    }
};
exports.state = state;
const NONCE_MAX_AGE = 60 * 15;
const nonce = {
    async create (options, cookies, resParams) {
        var _options$provider$che4, _options$cookies$nonc;
        if (!((_options$provider$che4 = options.provider.checks) !== null && _options$provider$che4 !== void 0 && _options$provider$che4.includes("nonce"))) return;
        const value = _openidClient.generators.nonce();
        resParams.nonce = value;
        const maxAge = (_options$cookies$nonc = options.cookies.nonce.options.maxAge) !== null && _options$cookies$nonc !== void 0 ? _options$cookies$nonc : NONCE_MAX_AGE;
        cookies.push(await signCookie("nonce", value, maxAge, options));
    },
    async use (cookies, resCookies, options, checks) {
        var _options$provider3, _options$provider3$ch;
        if (!((_options$provider3 = options.provider) !== null && _options$provider3 !== void 0 && (_options$provider3$ch = _options$provider3.checks) !== null && _options$provider3$ch !== void 0 && _options$provider3$ch.includes("nonce"))) return;
        const nonce = cookies === null || cookies === void 0 ? void 0 : cookies[options.cookies.nonce.name];
        if (!nonce) throw new TypeError("Nonce cookie was missing.");
        const value = await jwt.decode({
            ...options.jwt,
            token: nonce
        });
        if (!(value !== null && value !== void 0 && value.value)) throw new TypeError("Nonce value could not be parsed.");
        resCookies.push({
            name: options.cookies.nonce.name,
            value: "",
            options: {
                ...options.cookies.nonce.options,
                maxAge: 0
            }
        });
        checks.nonce = value.value;
    }
};
exports.nonce = nonce;


/***/ }),

/***/ 92512:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.oAuth1Client = oAuth1Client;
exports.oAuth1TokenStore = void 0;
var _oauth = __webpack_require__(16190);
function oAuth1Client(options) {
    var _provider$version, _provider$encoding;
    const provider = options.provider;
    const oauth1Client = new _oauth.OAuth(provider.requestTokenUrl, provider.accessTokenUrl, provider.clientId, provider.clientSecret, (_provider$version = provider.version) !== null && _provider$version !== void 0 ? _provider$version : "1.0", provider.callbackUrl, (_provider$encoding = provider.encoding) !== null && _provider$encoding !== void 0 ? _provider$encoding : "HMAC-SHA1");
    const originalGet = oauth1Client.get.bind(oauth1Client);
    oauth1Client.get = async (...args)=>{
        return await new Promise((resolve, reject)=>{
            originalGet(...args, (error, result)=>{
                if (error) {
                    return reject(error);
                }
                resolve(result);
            });
        });
    };
    const originalGetOAuth1AccessToken = oauth1Client.getOAuthAccessToken.bind(oauth1Client);
    oauth1Client.getOAuthAccessToken = async (...args)=>{
        return await new Promise((resolve, reject)=>{
            originalGetOAuth1AccessToken(...args, (error, oauth_token, oauth_token_secret)=>{
                if (error) {
                    return reject(error);
                }
                resolve({
                    oauth_token,
                    oauth_token_secret
                });
            });
        });
    };
    const originalGetOAuthRequestToken = oauth1Client.getOAuthRequestToken.bind(oauth1Client);
    oauth1Client.getOAuthRequestToken = async (params = {})=>{
        return await new Promise((resolve, reject)=>{
            originalGetOAuthRequestToken(params, (error, oauth_token, oauth_token_secret, params)=>{
                if (error) {
                    return reject(error);
                }
                resolve({
                    oauth_token,
                    oauth_token_secret,
                    params
                });
            });
        });
    };
    return oauth1Client;
}
const oAuth1TokenStore = new Map();
exports.oAuth1TokenStore = oAuth1TokenStore;


/***/ }),

/***/ 19914:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.openidClient = openidClient;
var _openidClient = __webpack_require__(32698);
async function openidClient(options) {
    const provider = options.provider;
    if (provider.httpOptions) _openidClient.custom.setHttpOptionsDefaults(provider.httpOptions);
    let issuer;
    if (provider.wellKnown) {
        issuer = await _openidClient.Issuer.discover(provider.wellKnown);
    } else {
        var _provider$authorizati, _provider$token, _provider$userinfo;
        issuer = new _openidClient.Issuer({
            issuer: provider.issuer,
            authorization_endpoint: (_provider$authorizati = provider.authorization) === null || _provider$authorizati === void 0 ? void 0 : _provider$authorizati.url,
            token_endpoint: (_provider$token = provider.token) === null || _provider$token === void 0 ? void 0 : _provider$token.url,
            userinfo_endpoint: (_provider$userinfo = provider.userinfo) === null || _provider$userinfo === void 0 ? void 0 : _provider$userinfo.url,
            jwks_uri: provider.jwks_endpoint
        });
    }
    const client = new issuer.Client({
        client_id: provider.clientId,
        client_secret: provider.clientSecret,
        redirect_uris: [
            provider.callbackUrl
        ],
        ...provider.client
    }, provider.jwks);
    client[_openidClient.custom.clock_tolerance] = 10;
    return client;
}


/***/ }),

/***/ 64229:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = parseProviders;
var _merge = __webpack_require__(16454);
function parseProviders(params) {
    const { url, providerId } = params;
    const providers = params.providers.map(({ options: userOptions, ...rest })=>{
        var _ref;
        if (rest.type === "oauth") {
            var _normalizedUserOption;
            const normalizedOptions = normalizeOAuthOptions(rest);
            const normalizedUserOptions = normalizeOAuthOptions(userOptions, true);
            const id = (_normalizedUserOption = normalizedUserOptions === null || normalizedUserOptions === void 0 ? void 0 : normalizedUserOptions.id) !== null && _normalizedUserOption !== void 0 ? _normalizedUserOption : rest.id;
            return (0, _merge.merge)(normalizedOptions, {
                ...normalizedUserOptions,
                signinUrl: `${url}/signin/${id}`,
                callbackUrl: `${url}/callback/${id}`
            });
        }
        const id = (_ref = userOptions === null || userOptions === void 0 ? void 0 : userOptions.id) !== null && _ref !== void 0 ? _ref : rest.id;
        return (0, _merge.merge)(rest, {
            ...userOptions,
            signinUrl: `${url}/signin/${id}`,
            callbackUrl: `${url}/callback/${id}`
        });
    });
    return {
        providers,
        provider: providers.find(({ id })=>id === providerId)
    };
}
function normalizeOAuthOptions(oauthOptions, isUserOptions = false) {
    var _normalized$version;
    if (!oauthOptions) return;
    const normalized = Object.entries(oauthOptions).reduce((acc, [key, value])=>{
        if ([
            "authorization",
            "token",
            "userinfo"
        ].includes(key) && typeof value === "string") {
            var _url$searchParams;
            const url = new URL(value);
            acc[key] = {
                url: `${url.origin}${url.pathname}`,
                params: Object.fromEntries((_url$searchParams = url.searchParams) !== null && _url$searchParams !== void 0 ? _url$searchParams : [])
            };
        } else {
            acc[key] = value;
        }
        return acc;
    }, {});
    if (!isUserOptions && !((_normalized$version = normalized.version) !== null && _normalized$version !== void 0 && _normalized$version.startsWith("1."))) {
        var _ref2, _normalized$idToken, _normalized$wellKnown, _normalized$authoriza, _normalized$authoriza2, _normalized$authoriza3;
        normalized.idToken = Boolean((_ref2 = (_normalized$idToken = normalized.idToken) !== null && _normalized$idToken !== void 0 ? _normalized$idToken : (_normalized$wellKnown = normalized.wellKnown) === null || _normalized$wellKnown === void 0 ? void 0 : _normalized$wellKnown.includes("openid-configuration")) !== null && _ref2 !== void 0 ? _ref2 : (_normalized$authoriza = normalized.authorization) === null || _normalized$authoriza === void 0 ? void 0 : (_normalized$authoriza2 = _normalized$authoriza.params) === null || _normalized$authoriza2 === void 0 ? void 0 : (_normalized$authoriza3 = _normalized$authoriza2.scope) === null || _normalized$authoriza3 === void 0 ? void 0 : _normalized$authoriza3.includes("openid"));
        if (!normalized.checks) normalized.checks = [
            "state"
        ];
    }
    return normalized;
}


/***/ }),

/***/ 95134:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.createSecret = createSecret;
exports.fromDate = fromDate;
exports.hashToken = hashToken;
var _crypto = __webpack_require__(6113);
function fromDate(time, date = Date.now()) {
    return new Date(date + time * 1000);
}
function hashToken(token, options) {
    var _provider$secret;
    const { provider, secret } = options;
    return (0, _crypto.createHash)("sha256").update(`${token}${(_provider$secret = provider.secret) !== null && _provider$secret !== void 0 ? _provider$secret : secret}`).digest("hex");
}
function createSecret(params) {
    var _authOptions$secret;
    const { authOptions, url } = params;
    return (_authOptions$secret = authOptions.secret) !== null && _authOptions$secret !== void 0 ? _authOptions$secret : (0, _crypto.createHash)("sha256").update(JSON.stringify({
        ...url,
        ...authOptions
    })).digest("hex");
}


/***/ }),

/***/ 56396:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = ErrorPage;
var _preact = __webpack_require__(41405);
function ErrorPage(props) {
    var _errors$error$toLower;
    const { url, error = "default", theme } = props;
    const signinPageUrl = `${url}/signin`;
    const errors = {
        default: {
            status: 200,
            heading: "Error",
            message: (0, _preact.h)("p", null, (0, _preact.h)("a", {
                className: "site",
                href: url === null || url === void 0 ? void 0 : url.origin
            }, url === null || url === void 0 ? void 0 : url.host))
        },
        configuration: {
            status: 500,
            heading: "Server error",
            message: (0, _preact.h)("div", null, (0, _preact.h)("p", null, "There is a problem with the server configuration."), (0, _preact.h)("p", null, "Check the server logs for more information."))
        },
        accessdenied: {
            status: 403,
            heading: "Access Denied",
            message: (0, _preact.h)("div", null, (0, _preact.h)("p", null, "You do not have permission to sign in."), (0, _preact.h)("p", null, (0, _preact.h)("a", {
                className: "button",
                href: signinPageUrl
            }, "Sign in")))
        },
        verification: {
            status: 403,
            heading: "Unable to sign in",
            message: (0, _preact.h)("div", null, (0, _preact.h)("p", null, "The sign in link is no longer valid."), (0, _preact.h)("p", null, "It may have been used already or it may have expired.")),
            signin: (0, _preact.h)("p", null, (0, _preact.h)("a", {
                className: "button",
                href: signinPageUrl
            }, "Sign in"))
        }
    };
    const { status, heading, message, signin } = (_errors$error$toLower = errors[error.toLowerCase()]) !== null && _errors$error$toLower !== void 0 ? _errors$error$toLower : errors.default;
    return {
        status,
        html: (0, _preact.h)("div", {
            className: "error"
        }, (theme === null || theme === void 0 ? void 0 : theme.brandColor) && (0, _preact.h)("style", {
            dangerouslySetInnerHTML: {
                __html: `
        :root {
          --brand-color: ${theme === null || theme === void 0 ? void 0 : theme.brandColor}
        }
      `
            }
        }), (0, _preact.h)("div", {
            className: "card"
        }, (theme === null || theme === void 0 ? void 0 : theme.logo) && (0, _preact.h)("img", {
            src: theme.logo,
            alt: "Logo",
            className: "logo"
        }), (0, _preact.h)("h1", null, heading), (0, _preact.h)("div", {
            className: "message"
        }, message), signin))
    };
}


/***/ }),

/***/ 58518:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(69124);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = renderPage;
var _preactRenderToString = _interopRequireDefault(__webpack_require__(58568));
var _signin = _interopRequireDefault(__webpack_require__(22640));
var _signout = _interopRequireDefault(__webpack_require__(61055));
var _verifyRequest = _interopRequireDefault(__webpack_require__(99110));
var _error = _interopRequireDefault(__webpack_require__(56396));
var _css = _interopRequireDefault(__webpack_require__(53833));
function renderPage(params) {
    const { url, theme, query, cookies } = params;
    function send({ html, title, status }) {
        var _theme$colorScheme;
        return {
            cookies,
            status,
            headers: [
                {
                    key: "Content-Type",
                    value: "text/html"
                }
            ],
            body: `<!DOCTYPE html><html lang="en"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><style>${(0, _css.default)()}</style><title>${title}</title></head><body class="__next-auth-theme-${(_theme$colorScheme = theme === null || theme === void 0 ? void 0 : theme.colorScheme) !== null && _theme$colorScheme !== void 0 ? _theme$colorScheme : "auto"}"><div class="page">${(0, _preactRenderToString.default)(html)}</div></body></html>`
        };
    }
    return {
        signin (props) {
            return send({
                html: (0, _signin.default)({
                    csrfToken: params.csrfToken,
                    providers: params.providers,
                    callbackUrl: params.callbackUrl,
                    theme,
                    ...query,
                    ...props
                }),
                title: "Sign In"
            });
        },
        signout (props) {
            return send({
                html: (0, _signout.default)({
                    csrfToken: params.csrfToken,
                    url,
                    theme,
                    ...props
                }),
                title: "Sign Out"
            });
        },
        verifyRequest (props) {
            return send({
                html: (0, _verifyRequest.default)({
                    url,
                    theme,
                    ...props
                }),
                title: "Verify Request"
            });
        },
        error (props) {
            return send({
                ...(0, _error.default)({
                    url,
                    theme,
                    ...props
                }),
                title: "Error"
            });
        }
    };
}


/***/ }),

/***/ 22640:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(69124);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = SigninPage;
var _preact = __webpack_require__(41405);
var _extends2 = _interopRequireDefault(__webpack_require__(33911));
function SigninPage(props) {
    var _errors$errorType;
    const { csrfToken, providers, callbackUrl, theme, email, error: errorType } = props;
    const providersToRender = providers.filter((provider)=>{
        if (provider.type === "oauth" || provider.type === "email") {
            return true;
        } else if (provider.type === "credentials" && provider.credentials) {
            return true;
        }
        return false;
    });
    if (typeof document !== "undefined" && theme.buttonText) {
        document.documentElement.style.setProperty("--button-text-color", theme.buttonText);
    }
    if (typeof document !== "undefined" && theme.brandColor) {
        document.documentElement.style.setProperty("--brand-color", theme.brandColor);
    }
    const errors = {
        Signin: "Try signing in with a different account.",
        OAuthSignin: "Try signing in with a different account.",
        OAuthCallback: "Try signing in with a different account.",
        OAuthCreateAccount: "Try signing in with a different account.",
        EmailCreateAccount: "Try signing in with a different account.",
        Callback: "Try signing in with a different account.",
        OAuthAccountNotLinked: "To confirm your identity, sign in with the same account you used originally.",
        EmailSignin: "The e-mail could not be sent.",
        CredentialsSignin: "Sign in failed. Check the details you provided are correct.",
        SessionRequired: "Please sign in to access this page.",
        default: "Unable to sign in."
    };
    const error = errorType && ((_errors$errorType = errors[errorType]) !== null && _errors$errorType !== void 0 ? _errors$errorType : errors.default);
    const logos = "https://authjs.dev/img/providers";
    return (0, _preact.h)("div", {
        className: "signin"
    }, theme.brandColor && (0, _preact.h)("style", {
        dangerouslySetInnerHTML: {
            __html: `
        :root {
          --brand-color: ${theme.brandColor}
        }
      `
        }
    }), theme.buttonText && (0, _preact.h)("style", {
        dangerouslySetInnerHTML: {
            __html: `
        :root {
          --button-text-color: ${theme.buttonText}
        }
      `
        }
    }), (0, _preact.h)("div", {
        className: "card"
    }, theme.logo && (0, _preact.h)("img", {
        src: theme.logo,
        alt: "Logo",
        className: "logo"
    }), error && (0, _preact.h)("div", {
        className: "error"
    }, (0, _preact.h)("p", null, error)), providersToRender.map((provider, i)=>{
        var _provider$style$bg, _provider$style, _provider$style$bgDar, _provider$style2, _provider$style$text, _provider$style3, _provider$style$textD, _provider$style4, _provider$style5, _provider$style6;
        return (0, _preact.h)("div", {
            key: provider.id,
            className: "provider"
        }, provider.type === "oauth" && (0, _preact.h)("form", {
            action: provider.signinUrl,
            method: "POST"
        }, (0, _preact.h)("input", {
            type: "hidden",
            name: "csrfToken",
            value: csrfToken
        }), callbackUrl && (0, _preact.h)("input", {
            type: "hidden",
            name: "callbackUrl",
            value: callbackUrl
        }), (0, _preact.h)("button", {
            type: "submit",
            className: "button",
            style: {
                "--provider-bg": (_provider$style$bg = (_provider$style = provider.style) === null || _provider$style === void 0 ? void 0 : _provider$style.bg) !== null && _provider$style$bg !== void 0 ? _provider$style$bg : "",
                "--provider-dark-bg": (_provider$style$bgDar = (_provider$style2 = provider.style) === null || _provider$style2 === void 0 ? void 0 : _provider$style2.bgDark) !== null && _provider$style$bgDar !== void 0 ? _provider$style$bgDar : "",
                "--provider-color": (_provider$style$text = (_provider$style3 = provider.style) === null || _provider$style3 === void 0 ? void 0 : _provider$style3.text) !== null && _provider$style$text !== void 0 ? _provider$style$text : "",
                "--provider-dark-color": (_provider$style$textD = (_provider$style4 = provider.style) === null || _provider$style4 === void 0 ? void 0 : _provider$style4.textDark) !== null && _provider$style$textD !== void 0 ? _provider$style$textD : ""
            }
        }, ((_provider$style5 = provider.style) === null || _provider$style5 === void 0 ? void 0 : _provider$style5.logo) && (0, _preact.h)("img", {
            loading: "lazy",
            height: 24,
            width: 24,
            id: "provider-logo",
            src: `${provider.style.logo.startsWith("/") ? logos : ""}${provider.style.logo}`
        }), ((_provider$style6 = provider.style) === null || _provider$style6 === void 0 ? void 0 : _provider$style6.logoDark) && (0, _preact.h)("img", {
            loading: "lazy",
            height: 24,
            width: 24,
            id: "provider-logo-dark",
            src: `${provider.style.logo.startsWith("/") ? logos : ""}${provider.style.logoDark}`
        }), (0, _preact.h)("span", null, "Sign in with ", provider.name))), (provider.type === "email" || provider.type === "credentials") && i > 0 && providersToRender[i - 1].type !== "email" && providersToRender[i - 1].type !== "credentials" && (0, _preact.h)("hr", null), provider.type === "email" && (0, _preact.h)("form", {
            action: provider.signinUrl,
            method: "POST"
        }, (0, _preact.h)("input", {
            type: "hidden",
            name: "csrfToken",
            value: csrfToken
        }), (0, _preact.h)("label", {
            className: "section-header",
            htmlFor: `input-email-for-${provider.id}-provider`
        }, "Email"), (0, _preact.h)("input", {
            id: `input-email-for-${provider.id}-provider`,
            autoFocus: true,
            type: "email",
            name: "email",
            value: email,
            placeholder: "email@example.com",
            required: true
        }), (0, _preact.h)("button", {
            id: "submitButton",
            type: "submit"
        }, "Sign in with ", provider.name)), provider.type === "credentials" && (0, _preact.h)("form", {
            action: provider.callbackUrl,
            method: "POST"
        }, (0, _preact.h)("input", {
            type: "hidden",
            name: "csrfToken",
            value: csrfToken
        }), Object.keys(provider.credentials).map((credential)=>{
            var _provider$credentials, _provider$credentials2, _provider$credentials3;
            return (0, _preact.h)("div", {
                key: `input-group-${provider.id}`
            }, (0, _preact.h)("label", {
                className: "section-header",
                htmlFor: `input-${credential}-for-${provider.id}-provider`
            }, (_provider$credentials = provider.credentials[credential].label) !== null && _provider$credentials !== void 0 ? _provider$credentials : credential), (0, _preact.h)("input", (0, _extends2.default)({
                name: credential,
                id: `input-${credential}-for-${provider.id}-provider`,
                type: (_provider$credentials2 = provider.credentials[credential].type) !== null && _provider$credentials2 !== void 0 ? _provider$credentials2 : "text",
                placeholder: (_provider$credentials3 = provider.credentials[credential].placeholder) !== null && _provider$credentials3 !== void 0 ? _provider$credentials3 : ""
            }, provider.credentials[credential])));
        }), (0, _preact.h)("button", {
            type: "submit"
        }, "Sign in with ", provider.name)), (provider.type === "email" || provider.type === "credentials") && i + 1 < providersToRender.length && (0, _preact.h)("hr", null));
    })));
}


/***/ }),

/***/ 61055:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = SignoutPage;
var _preact = __webpack_require__(41405);
function SignoutPage(props) {
    const { url, csrfToken, theme } = props;
    return (0, _preact.h)("div", {
        className: "signout"
    }, theme.brandColor && (0, _preact.h)("style", {
        dangerouslySetInnerHTML: {
            __html: `
        :root {
          --brand-color: ${theme.brandColor}
        }
      `
        }
    }), theme.buttonText && (0, _preact.h)("style", {
        dangerouslySetInnerHTML: {
            __html: `
        :root {
          --button-text-color: ${theme.buttonText}
        }
      `
        }
    }), (0, _preact.h)("div", {
        className: "card"
    }, theme.logo && (0, _preact.h)("img", {
        src: theme.logo,
        alt: "Logo",
        className: "logo"
    }), (0, _preact.h)("h1", null, "Signout"), (0, _preact.h)("p", null, "Are you sure you want to sign out?"), (0, _preact.h)("form", {
        action: `${url}/signout`,
        method: "POST"
    }, (0, _preact.h)("input", {
        type: "hidden",
        name: "csrfToken",
        value: csrfToken
    }), (0, _preact.h)("button", {
        id: "submitButton",
        type: "submit"
    }, "Sign out"))));
}


/***/ }),

/***/ 99110:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = VerifyRequestPage;
var _preact = __webpack_require__(41405);
function VerifyRequestPage(props) {
    const { url, theme } = props;
    return (0, _preact.h)("div", {
        className: "verify-request"
    }, theme.brandColor && (0, _preact.h)("style", {
        dangerouslySetInnerHTML: {
            __html: `
        :root {
          --brand-color: ${theme.brandColor}
        }
      `
        }
    }), (0, _preact.h)("div", {
        className: "card"
    }, theme.logo && (0, _preact.h)("img", {
        src: theme.logo,
        alt: "Logo",
        className: "logo"
    }), (0, _preact.h)("h1", null, "Check your email"), (0, _preact.h)("p", null, "A sign in link has been sent to your email address."), (0, _preact.h)("p", null, (0, _preact.h)("a", {
        className: "site",
        href: url.origin
    }, url.host))));
}


/***/ }),

/***/ 58680:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(69124);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = callback;
var _callback = _interopRequireDefault(__webpack_require__(80623));
var _callbackHandler = _interopRequireDefault(__webpack_require__(64195));
var _utils = __webpack_require__(95134);
var _getUserFromEmail = _interopRequireDefault(__webpack_require__(39274));
async function callback(params) {
    const { options, query, body, method, headers, sessionStore } = params;
    const { provider, adapter, url, callbackUrl, pages, jwt, events, callbacks, session: { strategy: sessionStrategy, maxAge: sessionMaxAge }, logger } = options;
    const cookies = [];
    const useJwtSession = sessionStrategy === "jwt";
    if (provider.type === "oauth") {
        try {
            const { profile, account, OAuthProfile, cookies: oauthCookies } = await (0, _callback.default)({
                query,
                body,
                method,
                options,
                cookies: params.cookies
            });
            if (oauthCookies.length) cookies.push(...oauthCookies);
            try {
                var _events$signIn;
                logger.debug("OAUTH_CALLBACK_RESPONSE", {
                    profile,
                    account,
                    OAuthProfile
                });
                if (!profile || !account || !OAuthProfile) {
                    return {
                        redirect: `${url}/signin`,
                        cookies
                    };
                }
                let userOrProfile = profile;
                if (adapter) {
                    const { getUserByAccount } = adapter;
                    const userByAccount = await getUserByAccount({
                        providerAccountId: account.providerAccountId,
                        provider: provider.id
                    });
                    if (userByAccount) userOrProfile = userByAccount;
                }
                try {
                    const isAllowed = await callbacks.signIn({
                        user: userOrProfile,
                        account,
                        profile: OAuthProfile
                    });
                    if (!isAllowed) {
                        return {
                            redirect: `${url}/error?error=AccessDenied`,
                            cookies
                        };
                    } else if (typeof isAllowed === "string") {
                        return {
                            redirect: isAllowed,
                            cookies
                        };
                    }
                } catch (error) {
                    return {
                        redirect: `${url}/error?error=${encodeURIComponent(error.message)}`,
                        cookies
                    };
                }
                const { user, session, isNewUser } = await (0, _callbackHandler.default)({
                    sessionToken: sessionStore.value,
                    profile,
                    account,
                    options
                });
                if (useJwtSession) {
                    var _user$id;
                    const defaultToken = {
                        name: user.name,
                        email: user.email,
                        picture: user.image,
                        sub: (_user$id = user.id) === null || _user$id === void 0 ? void 0 : _user$id.toString()
                    };
                    const token = await callbacks.jwt({
                        token: defaultToken,
                        user,
                        account,
                        profile: OAuthProfile,
                        isNewUser,
                        trigger: isNewUser ? "signUp" : "signIn"
                    });
                    const newToken = await jwt.encode({
                        ...jwt,
                        token
                    });
                    const cookieExpires = new Date();
                    cookieExpires.setTime(cookieExpires.getTime() + sessionMaxAge * 1000);
                    const sessionCookies = sessionStore.chunk(newToken, {
                        expires: cookieExpires
                    });
                    cookies.push(...sessionCookies);
                } else {
                    cookies.push({
                        name: options.cookies.sessionToken.name,
                        value: session.sessionToken,
                        options: {
                            ...options.cookies.sessionToken.options,
                            expires: session.expires
                        }
                    });
                }
                await ((_events$signIn = events.signIn) === null || _events$signIn === void 0 ? void 0 : _events$signIn.call(events, {
                    user,
                    account,
                    profile,
                    isNewUser
                }));
                if (isNewUser && pages.newUser) {
                    return {
                        redirect: `${pages.newUser}${pages.newUser.includes("?") ? "&" : "?"}callbackUrl=${encodeURIComponent(callbackUrl)}`,
                        cookies
                    };
                }
                return {
                    redirect: callbackUrl,
                    cookies
                };
            } catch (error) {
                if (error.name === "AccountNotLinkedError") {
                    return {
                        redirect: `${url}/error?error=OAuthAccountNotLinked`,
                        cookies
                    };
                } else if (error.name === "CreateUserError") {
                    return {
                        redirect: `${url}/error?error=OAuthCreateAccount`,
                        cookies
                    };
                }
                logger.error("OAUTH_CALLBACK_HANDLER_ERROR", error);
                return {
                    redirect: `${url}/error?error=Callback`,
                    cookies
                };
            }
        } catch (error) {
            if (error.name === "OAuthCallbackError") {
                logger.error("OAUTH_CALLBACK_ERROR", {
                    error: error,
                    providerId: provider.id
                });
                return {
                    redirect: `${url}/error?error=OAuthCallback`,
                    cookies
                };
            }
            logger.error("OAUTH_CALLBACK_ERROR", error);
            return {
                redirect: `${url}/error?error=Callback`,
                cookies
            };
        }
    } else if (provider.type === "email") {
        try {
            var _events$signIn2;
            const token = query === null || query === void 0 ? void 0 : query.token;
            const identifier = query === null || query === void 0 ? void 0 : query.email;
            if (!token || !identifier) {
                return {
                    redirect: `${url}/error?error=configuration`,
                    cookies
                };
            }
            const invite = await adapter.useVerificationToken({
                identifier,
                token: (0, _utils.hashToken)(token, options)
            });
            const invalidInvite = !invite || invite.expires.valueOf() < Date.now();
            if (invalidInvite) {
                return {
                    redirect: `${url}/error?error=Verification`,
                    cookies
                };
            }
            const profile = await (0, _getUserFromEmail.default)({
                email: identifier,
                adapter
            });
            const account = {
                providerAccountId: profile.email,
                type: "email",
                provider: provider.id
            };
            try {
                const signInCallbackResponse = await callbacks.signIn({
                    user: profile,
                    account
                });
                if (!signInCallbackResponse) {
                    return {
                        redirect: `${url}/error?error=AccessDenied`,
                        cookies
                    };
                } else if (typeof signInCallbackResponse === "string") {
                    return {
                        redirect: signInCallbackResponse,
                        cookies
                    };
                }
            } catch (error) {
                return {
                    redirect: `${url}/error?error=${encodeURIComponent(error.message)}`,
                    cookies
                };
            }
            const { user, session, isNewUser } = await (0, _callbackHandler.default)({
                sessionToken: sessionStore.value,
                profile,
                account,
                options
            });
            if (useJwtSession) {
                var _user$id2;
                const defaultToken = {
                    name: user.name,
                    email: user.email,
                    picture: user.image,
                    sub: (_user$id2 = user.id) === null || _user$id2 === void 0 ? void 0 : _user$id2.toString()
                };
                const token = await callbacks.jwt({
                    token: defaultToken,
                    user,
                    account,
                    isNewUser,
                    trigger: isNewUser ? "signUp" : "signIn"
                });
                const newToken = await jwt.encode({
                    ...jwt,
                    token
                });
                const cookieExpires = new Date();
                cookieExpires.setTime(cookieExpires.getTime() + sessionMaxAge * 1000);
                const sessionCookies = sessionStore.chunk(newToken, {
                    expires: cookieExpires
                });
                cookies.push(...sessionCookies);
            } else {
                cookies.push({
                    name: options.cookies.sessionToken.name,
                    value: session.sessionToken,
                    options: {
                        ...options.cookies.sessionToken.options,
                        expires: session.expires
                    }
                });
            }
            await ((_events$signIn2 = events.signIn) === null || _events$signIn2 === void 0 ? void 0 : _events$signIn2.call(events, {
                user,
                account,
                isNewUser
            }));
            if (isNewUser && pages.newUser) {
                return {
                    redirect: `${pages.newUser}${pages.newUser.includes("?") ? "&" : "?"}callbackUrl=${encodeURIComponent(callbackUrl)}`,
                    cookies
                };
            }
            return {
                redirect: callbackUrl,
                cookies
            };
        } catch (error) {
            if (error.name === "CreateUserError") {
                return {
                    redirect: `${url}/error?error=EmailCreateAccount`,
                    cookies
                };
            }
            logger.error("CALLBACK_EMAIL_ERROR", error);
            return {
                redirect: `${url}/error?error=Callback`,
                cookies
            };
        }
    } else if (provider.type === "credentials" && method === "POST") {
        var _user$id3, _events$signIn3;
        const credentials = body;
        let user;
        try {
            user = await provider.authorize(credentials, {
                query,
                body,
                headers,
                method
            });
            if (!user) {
                return {
                    status: 401,
                    redirect: `${url}/error?${new URLSearchParams({
                        error: "CredentialsSignin",
                        provider: provider.id
                    })}`,
                    cookies
                };
            }
        } catch (error) {
            return {
                status: 401,
                redirect: `${url}/error?error=${encodeURIComponent(error.message)}`,
                cookies
            };
        }
        const account = {
            providerAccountId: user.id,
            type: "credentials",
            provider: provider.id
        };
        try {
            const isAllowed = await callbacks.signIn({
                user,
                account,
                credentials
            });
            if (!isAllowed) {
                return {
                    status: 403,
                    redirect: `${url}/error?error=AccessDenied`,
                    cookies
                };
            } else if (typeof isAllowed === "string") {
                return {
                    redirect: isAllowed,
                    cookies
                };
            }
        } catch (error) {
            return {
                redirect: `${url}/error?error=${encodeURIComponent(error.message)}`,
                cookies
            };
        }
        const defaultToken = {
            name: user.name,
            email: user.email,
            picture: user.image,
            sub: (_user$id3 = user.id) === null || _user$id3 === void 0 ? void 0 : _user$id3.toString()
        };
        const token = await callbacks.jwt({
            token: defaultToken,
            user,
            account,
            isNewUser: false,
            trigger: "signIn"
        });
        const newToken = await jwt.encode({
            ...jwt,
            token
        });
        const cookieExpires = new Date();
        cookieExpires.setTime(cookieExpires.getTime() + sessionMaxAge * 1000);
        const sessionCookies = sessionStore.chunk(newToken, {
            expires: cookieExpires
        });
        cookies.push(...sessionCookies);
        await ((_events$signIn3 = events.signIn) === null || _events$signIn3 === void 0 ? void 0 : _events$signIn3.call(events, {
            user,
            account
        }));
        return {
            redirect: callbackUrl,
            cookies
        };
    }
    return {
        status: 500,
        body: `Error: Callback for provider type ${provider.type} not supported`,
        cookies
    };
}


/***/ }),

/***/ 58608:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(69124);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
Object.defineProperty(exports, "callback", ({
    enumerable: true,
    get: function() {
        return _callback.default;
    }
}));
Object.defineProperty(exports, "providers", ({
    enumerable: true,
    get: function() {
        return _providers.default;
    }
}));
Object.defineProperty(exports, "session", ({
    enumerable: true,
    get: function() {
        return _session.default;
    }
}));
Object.defineProperty(exports, "signin", ({
    enumerable: true,
    get: function() {
        return _signin.default;
    }
}));
Object.defineProperty(exports, "signout", ({
    enumerable: true,
    get: function() {
        return _signout.default;
    }
}));
var _callback = _interopRequireDefault(__webpack_require__(58680));
var _signin = _interopRequireDefault(__webpack_require__(25924));
var _signout = _interopRequireDefault(__webpack_require__(70812));
var _session = _interopRequireDefault(__webpack_require__(79243));
var _providers = _interopRequireDefault(__webpack_require__(93859));


/***/ }),

/***/ 93859:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = providers;
function providers(providers) {
    return {
        headers: [
            {
                key: "Content-Type",
                value: "application/json"
            }
        ],
        body: providers.reduce((acc, { id, name, type, signinUrl, callbackUrl })=>{
            acc[id] = {
                id,
                name,
                type,
                signinUrl,
                callbackUrl
            };
            return acc;
        }, {})
    };
}


/***/ }),

/***/ 79243:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = session;
var _utils = __webpack_require__(95134);
async function session(params) {
    const { options, sessionStore, newSession, isUpdate } = params;
    const { adapter, jwt, events, callbacks, logger, session: { strategy: sessionStrategy, maxAge: sessionMaxAge } } = options;
    const response = {
        body: {},
        headers: [
            {
                key: "Content-Type",
                value: "application/json"
            }
        ],
        cookies: []
    };
    const sessionToken = sessionStore.value;
    if (!sessionToken) return response;
    if (sessionStrategy === "jwt") {
        try {
            var _response$cookies, _events$session;
            const decodedToken = await jwt.decode({
                ...jwt,
                token: sessionToken
            });
            if (!decodedToken) throw new Error("JWT invalid");
            const token = await callbacks.jwt({
                token: decodedToken,
                ...isUpdate && {
                    trigger: "update"
                },
                session: newSession
            });
            const newExpires = (0, _utils.fromDate)(sessionMaxAge);
            const updatedSession = await callbacks.session({
                session: {
                    user: {
                        name: decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.name,
                        email: decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.email,
                        image: decodedToken === null || decodedToken === void 0 ? void 0 : decodedToken.picture
                    },
                    expires: newExpires.toISOString()
                },
                token
            });
            response.body = updatedSession;
            const newToken = await jwt.encode({
                ...jwt,
                token,
                maxAge: options.session.maxAge
            });
            const sessionCookies = sessionStore.chunk(newToken, {
                expires: newExpires
            });
            (_response$cookies = response.cookies) === null || _response$cookies === void 0 ? void 0 : _response$cookies.push(...sessionCookies);
            await ((_events$session = events.session) === null || _events$session === void 0 ? void 0 : _events$session.call(events, {
                session: updatedSession,
                token
            }));
        } catch (error) {
            var _response$cookies2;
            logger.error("JWT_SESSION_ERROR", error);
            (_response$cookies2 = response.cookies) === null || _response$cookies2 === void 0 ? void 0 : _response$cookies2.push(...sessionStore.clean());
        }
    } else {
        try {
            const { getSessionAndUser, deleteSession, updateSession } = adapter;
            let userAndSession = await getSessionAndUser(sessionToken);
            if (userAndSession && userAndSession.session.expires.valueOf() < Date.now()) {
                await deleteSession(sessionToken);
                userAndSession = null;
            }
            if (userAndSession) {
                var _response$cookies3, _events$session2;
                const { user, session } = userAndSession;
                const sessionUpdateAge = options.session.updateAge;
                const sessionIsDueToBeUpdatedDate = session.expires.valueOf() - sessionMaxAge * 1000 + sessionUpdateAge * 1000;
                const newExpires = (0, _utils.fromDate)(sessionMaxAge);
                if (sessionIsDueToBeUpdatedDate <= Date.now()) {
                    await updateSession({
                        sessionToken,
                        expires: newExpires
                    });
                }
                const sessionPayload = await callbacks.session({
                    session: {
                        user: {
                            name: user.name,
                            email: user.email,
                            image: user.image
                        },
                        expires: session.expires.toISOString()
                    },
                    user,
                    newSession,
                    ...isUpdate ? {
                        trigger: "update"
                    } : {}
                });
                response.body = sessionPayload;
                (_response$cookies3 = response.cookies) === null || _response$cookies3 === void 0 ? void 0 : _response$cookies3.push({
                    name: options.cookies.sessionToken.name,
                    value: sessionToken,
                    options: {
                        ...options.cookies.sessionToken.options,
                        expires: newExpires
                    }
                });
                await ((_events$session2 = events.session) === null || _events$session2 === void 0 ? void 0 : _events$session2.call(events, {
                    session: sessionPayload
                }));
            } else if (sessionToken) {
                var _response$cookies4;
                (_response$cookies4 = response.cookies) === null || _response$cookies4 === void 0 ? void 0 : _response$cookies4.push(...sessionStore.clean());
            }
        } catch (error) {
            logger.error("SESSION_ERROR", error);
        }
    }
    return response;
}


/***/ }),

/***/ 25924:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(69124);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = signin;
var _authorizationUrl = _interopRequireDefault(__webpack_require__(70782));
var _signin = _interopRequireDefault(__webpack_require__(34056));
var _getUserFromEmail = _interopRequireDefault(__webpack_require__(39274));
async function signin(params) {
    const { options, query, body } = params;
    const { url, callbacks, logger, provider } = options;
    if (!provider.type) {
        return {
            status: 500,
            text: `Error: Type not specified for ${provider.name}`
        };
    }
    if (provider.type === "oauth") {
        try {
            const response = await (0, _authorizationUrl.default)({
                options,
                query
            });
            return response;
        } catch (error) {
            logger.error("SIGNIN_OAUTH_ERROR", {
                error: error,
                providerId: provider.id
            });
            return {
                redirect: `${url}/error?error=OAuthSignin`
            };
        }
    } else if (provider.type === "email") {
        var _provider$normalizeId;
        let email = body === null || body === void 0 ? void 0 : body.email;
        if (!email) return {
            redirect: `${url}/error?error=EmailSignin`
        };
        const normalizer = (_provider$normalizeId = provider.normalizeIdentifier) !== null && _provider$normalizeId !== void 0 ? _provider$normalizeId : (identifier)=>{
            let [local, domain] = identifier.toLowerCase().trim().split("@");
            domain = domain.split(",")[0];
            return `${local}@${domain}`;
        };
        try {
            email = normalizer(body === null || body === void 0 ? void 0 : body.email);
        } catch (error) {
            logger.error("SIGNIN_EMAIL_ERROR", {
                error,
                providerId: provider.id
            });
            return {
                redirect: `${url}/error?error=EmailSignin`
            };
        }
        const user = await (0, _getUserFromEmail.default)({
            email,
            adapter: options.adapter
        });
        const account = {
            providerAccountId: email,
            userId: email,
            type: "email",
            provider: provider.id
        };
        try {
            const signInCallbackResponse = await callbacks.signIn({
                user,
                account,
                email: {
                    verificationRequest: true
                }
            });
            if (!signInCallbackResponse) {
                return {
                    redirect: `${url}/error?error=AccessDenied`
                };
            } else if (typeof signInCallbackResponse === "string") {
                return {
                    redirect: signInCallbackResponse
                };
            }
        } catch (error) {
            return {
                redirect: `${url}/error?${new URLSearchParams({
                    error: error
                })}`
            };
        }
        try {
            const redirect = await (0, _signin.default)(email, options);
            return {
                redirect
            };
        } catch (error) {
            logger.error("SIGNIN_EMAIL_ERROR", {
                error,
                providerId: provider.id
            });
            return {
                redirect: `${url}/error?error=EmailSignin`
            };
        }
    }
    return {
        redirect: `${url}/signin`
    };
}


/***/ }),

/***/ 70812:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = signout;
async function signout(params) {
    const { options, sessionStore } = params;
    const { adapter, events, jwt, callbackUrl, logger, session } = options;
    const sessionToken = sessionStore === null || sessionStore === void 0 ? void 0 : sessionStore.value;
    if (!sessionToken) {
        return {
            redirect: callbackUrl
        };
    }
    if (session.strategy === "jwt") {
        try {
            var _events$signOut;
            const decodedJwt = await jwt.decode({
                ...jwt,
                token: sessionToken
            });
            await ((_events$signOut = events.signOut) === null || _events$signOut === void 0 ? void 0 : _events$signOut.call(events, {
                token: decodedJwt
            }));
        } catch (error) {
            logger.error("SIGNOUT_ERROR", error);
        }
    } else {
        try {
            var _events$signOut2;
            const session = await adapter.deleteSession(sessionToken);
            await ((_events$signOut2 = events.signOut) === null || _events$signOut2 === void 0 ? void 0 : _events$signOut2.call(events, {
                session
            }));
        } catch (error) {
            logger.error("SIGNOUT_ERROR", error);
        }
    }
    const sessionCookies = sessionStore.clean();
    return {
        redirect: callbackUrl,
        cookies: sessionCookies
    };
}


/***/ }),

/***/ 76600:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));


/***/ }),

/***/ 53833:
/***/ ((module) => {

"use strict";

module.exports = function() {
    return ':root{--border-width:1px;--border-radius:0.5rem;--color-error:#c94b4b;--color-info:#157efb;--color-info-text:#fff}.__next-auth-theme-auto,.__next-auth-theme-light{--color-background:#ececec;--color-background-card:#fff;--color-text:#000;--color-primary:#444;--color-control-border:#bbb;--color-button-active-background:#f9f9f9;--color-button-active-border:#aaa;--color-seperator:#ccc}.__next-auth-theme-dark{--color-background:#161b22;--color-background-card:#0d1117;--color-text:#fff;--color-primary:#ccc;--color-control-border:#555;--color-button-active-background:#060606;--color-button-active-border:#666;--color-seperator:#444}@media (prefers-color-scheme:dark){.__next-auth-theme-auto{--color-background:#161b22;--color-background-card:#0d1117;--color-text:#fff;--color-primary:#ccc;--color-control-border:#555;--color-button-active-background:#060606;--color-button-active-border:#666;--color-seperator:#444}}body{background-color:var(--color-background);font-family:ui-sans-serif,system-ui,-apple-system,BlinkMacSystemFont,Segoe UI,Roboto,Helvetica Neue,Arial,Noto Sans,sans-serif,Apple Color Emoji,Segoe UI Emoji,Segoe UI Symbol,Noto Color Emoji;margin:0;padding:0}h1{font-weight:400;margin-bottom:1.5rem;padding:0 1rem}h1,p{color:var(--color-text)}form{margin:0;padding:0}label{font-weight:500;margin-bottom:.25rem;text-align:left}input[type],label{color:var(--color-text);display:block}input[type]{background:var(--color-background-card);border:var(--border-width) solid var(--color-control-border);border-radius:var(--border-radius);box-sizing:border-box;font-size:1rem;padding:.5rem 1rem;width:100%}input[type]:focus{box-shadow:none}p{font-size:1.1rem;line-height:2rem;margin:0 0 1.5rem;padding:0 1rem}a.button{line-height:1rem;text-decoration:none}a.button:link,a.button:visited{background-color:var(--color-background);color:var(--color-primary)}button span{flex-grow:1}a.button,button{align-items:center;background-color:var(--provider-bg,var(--color-background-card));border-color:rgba(0,0,0,.1);border-radius:var(--border-radius);color:var(--provider-color,var(--color-primary));display:flex;font-size:1.1rem;font-weight:500;justify-content:center;margin:0 0 .75rem;min-height:62px;padding:.75rem 1rem;position:relative;transition:all .1s ease-in-out}@media (max-width:450px){a.button,button{font-size:.9rem}}a.button:active,a.button:hover,button:active,button:hover{cursor:pointer}a.button #provider-logo,button #provider-logo{display:block;width:25px}a.button #provider-logo-dark,button #provider-logo-dark{display:none}#submitButton{background-color:var(--brand-color,var(--color-info));color:var(--button-text-color,var(--color-info-text));width:100%}@media (prefers-color-scheme:dark){a.button,button{background-color:var(--provider-dark-bg,var(--color-background));color:var(--provider-dark-color,var(--color-primary))}#provider-logo{display:none!important}#provider-logo-dark{display:block!important;width:25px}}a.site{color:var(--color-primary);font-size:1rem;line-height:2rem;text-decoration:none}a.site:hover{text-decoration:underline}.page{display:grid;height:100%;margin:0;padding:0;place-items:center;position:absolute;width:100%}.page>div{text-align:center}.error a.button{display:inline-block;margin-top:.5rem;padding-left:2rem;padding-right:2rem}.error .message{margin-bottom:1.5rem}.signin input[type=text]{display:block;margin-left:auto;margin-right:auto}.signin hr{border:0;border-top:1px solid var(--color-seperator);display:block;margin:2rem auto 1rem;overflow:visible}.signin hr:before{background:var(--color-background-card);color:#888;content:"or";padding:0 .4rem;position:relative;top:-.7rem}.signin .error{background:#f5f5f5;background:var(--color-error);border-radius:.3rem;font-weight:500}.signin .error p{color:var(--color-info-text);font-size:.9rem;line-height:1.2rem;padding:.5rem 1rem;text-align:left}.signin form,.signin>div{display:block}.signin form input[type],.signin>div input[type]{margin-bottom:.5rem}.signin form button,.signin>div button{width:100%}.signin form,.signin>div{max-width:300px}.logo{display:inline-block;margin-bottom:25px;margin-top:20px;max-height:70px;max-width:150px}@media screen and (min-width:450px){.card{width:350px}}@media screen and (max-width:450px){.card{width:200px}}.card{background-color:var(--color-background-card);border-radius:30px;margin:20px 0;padding:20px 50px}.card .header{color:var(--color-primary)}.section-header{color:var(--color-text)}';
};


/***/ }),

/***/ 83741:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
var _exportNames = {};
Object.defineProperty(exports, "default", ({
    enumerable: true,
    get: function() {
        return _next.default;
    }
}));
var _types = __webpack_require__(76600);
Object.keys(_types).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _types[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _types[key];
        }
    });
});
var _next = _interopRequireWildcard(__webpack_require__(29160));
Object.keys(_next).forEach(function(key) {
    if (key === "default" || key === "__esModule") return;
    if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
    if (key in exports && exports[key] === _next[key]) return;
    Object.defineProperty(exports, key, {
        enumerable: true,
        get: function() {
            return _next[key];
        }
    });
});
function _getRequireWildcardCache(nodeInterop) {
    if (typeof WeakMap !== "function") return null;
    var cacheBabelInterop = new WeakMap();
    var cacheNodeInterop = new WeakMap();
    return (_getRequireWildcardCache = function(nodeInterop) {
        return nodeInterop ? cacheNodeInterop : cacheBabelInterop;
    })(nodeInterop);
}
function _interopRequireWildcard(obj, nodeInterop) {
    if (!nodeInterop && obj && obj.__esModule) {
        return obj;
    }
    if (obj === null || typeof obj !== "object" && typeof obj !== "function") {
        return {
            default: obj
        };
    }
    var cache = _getRequireWildcardCache(nodeInterop);
    if (cache && cache.has(obj)) {
        return cache.get(obj);
    }
    var newObj = {};
    var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor;
    for(var key in obj){
        if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) {
            var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null;
            if (desc && (desc.get || desc.set)) {
                Object.defineProperty(newObj, key, desc);
            } else {
                newObj[key] = obj[key];
            }
        }
    }
    newObj.default = obj;
    if (cache) {
        cache.set(obj, newObj);
    }
    return newObj;
}


/***/ }),

/***/ 29160:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
exports.getServerSession = getServerSession;
exports.unstable_getServerSession = unstable_getServerSession;
var _core = __webpack_require__(71646);
var _utils = __webpack_require__(60146);
async function NextAuthApiHandler(req, res, options) {
    var _options$secret, _options$jwt$secret, _options$jwt, _ref, _handler$status, _handler$cookies, _handler$headers;
    const { nextauth, ...query } = req.query;
    (_options$secret = options.secret) !== null && _options$secret !== void 0 ? _options$secret : options.secret = (_options$jwt$secret = (_options$jwt = options.jwt) === null || _options$jwt === void 0 ? void 0 : _options$jwt.secret) !== null && _options$jwt$secret !== void 0 ? _options$jwt$secret : "50JPr1fhktUdTYZGgAzPNSHULpNY57StRbQMduW+HUE=";
    const handler = await (0, _core.AuthHandler)({
        req: {
            body: req.body,
            query,
            cookies: req.cookies,
            headers: req.headers,
            method: req.method,
            action: nextauth === null || nextauth === void 0 ? void 0 : nextauth[0],
            providerId: nextauth === null || nextauth === void 0 ? void 0 : nextauth[1],
            error: (_ref = req.query.error) !== null && _ref !== void 0 ? _ref : nextauth === null || nextauth === void 0 ? void 0 : nextauth[1]
        },
        options
    });
    res.status((_handler$status = handler.status) !== null && _handler$status !== void 0 ? _handler$status : 200);
    (_handler$cookies = handler.cookies) === null || _handler$cookies === void 0 ? void 0 : _handler$cookies.forEach((cookie)=>(0, _utils.setCookie)(res, cookie));
    (_handler$headers = handler.headers) === null || _handler$headers === void 0 ? void 0 : _handler$headers.forEach((h)=>res.setHeader(h.key, h.value));
    if (handler.redirect) {
        var _req$body;
        if (((_req$body = req.body) === null || _req$body === void 0 ? void 0 : _req$body.json) !== "true") {
            res.status(302).setHeader("Location", handler.redirect);
            res.end();
            return;
        }
        return res.json({
            url: handler.redirect
        });
    }
    return res.send(handler.body);
}
async function NextAuthRouteHandler(req, context, options) {
    var _options$secret2, _context$params, _query$error;
    (_options$secret2 = options.secret) !== null && _options$secret2 !== void 0 ? _options$secret2 : options.secret = "50JPr1fhktUdTYZGgAzPNSHULpNY57StRbQMduW+HUE=";
    const { headers, cookies } = __webpack_require__(95219);
    const nextauth = (_context$params = context.params) === null || _context$params === void 0 ? void 0 : _context$params.nextauth;
    const query = Object.fromEntries(req.nextUrl.searchParams);
    const body = await (0, _utils.getBody)(req);
    const internalResponse = await (0, _core.AuthHandler)({
        req: {
            body,
            query,
            cookies: Object.fromEntries(cookies().getAll().map((c)=>[
                    c.name,
                    c.value
                ])),
            headers: Object.fromEntries(headers()),
            method: req.method,
            action: nextauth === null || nextauth === void 0 ? void 0 : nextauth[0],
            providerId: nextauth === null || nextauth === void 0 ? void 0 : nextauth[1],
            error: (_query$error = query.error) !== null && _query$error !== void 0 ? _query$error : nextauth === null || nextauth === void 0 ? void 0 : nextauth[1]
        },
        options
    });
    const response = (0, _utils.toResponse)(internalResponse);
    const redirect = response.headers.get("Location");
    if ((body === null || body === void 0 ? void 0 : body.json) === "true" && redirect) {
        response.headers.delete("Location");
        response.headers.set("Content-Type", "application/json");
        return new Response(JSON.stringify({
            url: redirect
        }), {
            headers: response.headers
        });
    }
    return response;
}
function NextAuth(...args) {
    var _args$;
    if (args.length === 1) {
        return async (req, res)=>{
            if (res !== null && res !== void 0 && res.params) {
                return await NextAuthRouteHandler(req, res, args[0]);
            }
            return await NextAuthApiHandler(req, res, args[0]);
        };
    }
    if ((_args$ = args[1]) !== null && _args$ !== void 0 && _args$.params) {
        return NextAuthRouteHandler(...args);
    }
    return NextAuthApiHandler(...args);
}
var _default = NextAuth;
exports["default"] = _default;
async function getServerSession(...args) {
    var _options, _options$secret3;
    const isRSC = args.length === 0 || args.length === 1;
    let req, res, options;
    if (isRSC) {
        options = Object.assign({}, args[0], {
            providers: []
        });
        const { headers, cookies } = __webpack_require__(95219);
        req = {
            headers: Object.fromEntries(headers()),
            cookies: Object.fromEntries(cookies().getAll().map((c)=>[
                    c.name,
                    c.value
                ]))
        };
        res = {
            getHeader () {},
            setCookie () {},
            setHeader () {}
        };
    } else {
        req = args[0];
        res = args[1];
        options = Object.assign({}, args[2], {
            providers: []
        });
    }
    (_options$secret3 = (_options = options).secret) !== null && _options$secret3 !== void 0 ? _options$secret3 : _options.secret = "50JPr1fhktUdTYZGgAzPNSHULpNY57StRbQMduW+HUE=";
    const session = await (0, _core.AuthHandler)({
        options,
        req: {
            action: "session",
            method: "GET",
            cookies: req.cookies,
            headers: req.headers
        }
    });
    const { body, cookies, status = 200 } = session;
    cookies === null || cookies === void 0 ? void 0 : cookies.forEach((cookie)=>(0, _utils.setCookie)(res, cookie));
    if (body && typeof body !== "string" && Object.keys(body).length) {
        if (status === 200) {
            if (isRSC) delete body.expires;
            return body;
        }
        throw new Error(body.message);
    }
    return null;
}
let deprecatedWarningShown = false;
async function unstable_getServerSession(...args) {
    if (!deprecatedWarningShown && "production" !== "production") {}
    return await getServerSession(...args);
}


/***/ }),

/***/ 60146:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.getBody = getBody;
exports.setCookie = setCookie;
exports.toResponse = toResponse;
var _cookie = __webpack_require__(87445);
function setCookie(res, cookie) {
    var _res$getHeader;
    let setCookieHeader = (_res$getHeader = res.getHeader("Set-Cookie")) !== null && _res$getHeader !== void 0 ? _res$getHeader : [];
    if (!Array.isArray(setCookieHeader)) {
        setCookieHeader = [
            setCookieHeader
        ];
    }
    const { name, value, options } = cookie;
    const cookieHeader = (0, _cookie.serialize)(name, value, options);
    setCookieHeader.push(cookieHeader);
    res.setHeader("Set-Cookie", setCookieHeader);
}
async function getBody(req) {
    if (!("body" in req) || !req.body || req.method !== "POST") return;
    const contentType = req.headers.get("content-type");
    if (contentType !== null && contentType !== void 0 && contentType.includes("application/json")) {
        return await req.json();
    } else if (contentType !== null && contentType !== void 0 && contentType.includes("application/x-www-form-urlencoded")) {
        const params = new URLSearchParams(await req.text());
        return Object.fromEntries(params);
    }
}
function toResponse(res) {
    var _res$headers, _res$cookies, _res$status;
    const headers = new Headers((_res$headers = res.headers) === null || _res$headers === void 0 ? void 0 : _res$headers.reduce((acc, { key, value })=>{
        acc[key] = value;
        return acc;
    }, {}));
    (_res$cookies = res.cookies) === null || _res$cookies === void 0 ? void 0 : _res$cookies.forEach((cookie)=>{
        const { name, value, options } = cookie;
        const cookieHeader = (0, _cookie.serialize)(name, value, options);
        if (headers.has("Set-Cookie")) headers.append("Set-Cookie", cookieHeader);
        else headers.set("Set-Cookie", cookieHeader);
    });
    let body = res.body;
    if (headers.get("content-type") === "application/json") body = JSON.stringify(res.body);
    else if (headers.get("content-type") === "application/x-www-form-urlencoded") body = new URLSearchParams(res.body).toString();
    const status = res.redirect ? 302 : (_res$status = res.status) !== null && _res$status !== void 0 ? _res$status : 200;
    const response = new Response(body, {
        headers,
        status
    });
    if (res.redirect) response.headers.set("Location", res.redirect);
    return response;
}


/***/ }),

/***/ 63028:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({
    value: true
});
exports.Z = Cognito;
function Cognito(options) {
    return {
        id: "cognito",
        name: "Cognito",
        type: "oauth",
        wellKnown: `${options.issuer}/.well-known/openid-configuration`,
        idToken: true,
        profile (profile) {
            return {
                id: profile.sub,
                name: profile.name,
                email: profile.email,
                image: profile.picture
            };
        },
        style: {
            logo: "/cognito.svg",
            logoDark: "/cognito.svg",
            bg: "#fff",
            text: "#C17B9E",
            bgDark: "#fff",
            textDark: "#C17B9E"
        },
        options
    };
}


/***/ }),

/***/ 25892:
/***/ ((__unused_webpack_module, exports) => {

"use strict";
var __webpack_unused_export__;

__webpack_unused_export__ = ({
    value: true
});
exports.Z = Credentials;
function Credentials(options) {
    return {
        id: "credentials",
        name: "Credentials",
        type: "credentials",
        credentials: {},
        authorize: ()=>null,
        options
    };
}


/***/ }),

/***/ 48775:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.detectOrigin = detectOrigin;
function detectOrigin(forwardedHost, protocol) {
    var _process$env$VERCEL;
    if ((_process$env$VERCEL = process.env.VERCEL) !== null && _process$env$VERCEL !== void 0 ? _process$env$VERCEL : process.env.AUTH_TRUST_HOST) return `${protocol === "http" ? "http" : "https"}://${forwardedHost}`;
    return "http://localhost:3000";
}


/***/ }),

/***/ 96828:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

"use strict";

var _interopRequireDefault = __webpack_require__(69124);
Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = void 0;
exports.proxyLogger = proxyLogger;
exports.setLogger = setLogger;
var _defineProperty2 = _interopRequireDefault(__webpack_require__(97662));
var _errors = __webpack_require__(41594);
function ownKeys(object, enumerableOnly) {
    var keys = Object.keys(object);
    if (Object.getOwnPropertySymbols) {
        var symbols = Object.getOwnPropertySymbols(object);
        enumerableOnly && (symbols = symbols.filter(function(sym) {
            return Object.getOwnPropertyDescriptor(object, sym).enumerable;
        })), keys.push.apply(keys, symbols);
    }
    return keys;
}
function _objectSpread(target) {
    for(var i = 1; i < arguments.length; i++){
        var source = null != arguments[i] ? arguments[i] : {};
        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {
            (0, _defineProperty2.default)(target, key, source[key]);
        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {
            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));
        });
    }
    return target;
}
function formatError(o) {
    if (o instanceof Error && !(o instanceof _errors.UnknownError)) {
        return {
            message: o.message,
            stack: o.stack,
            name: o.name
        };
    }
    if (hasErrorProperty(o)) {
        var _o$message;
        o.error = formatError(o.error);
        o.message = (_o$message = o.message) !== null && _o$message !== void 0 ? _o$message : o.error.message;
    }
    return o;
}
function hasErrorProperty(x) {
    return !!(x !== null && x !== void 0 && x.error);
}
var _logger = {
    error: function error(code, metadata) {
        metadata = formatError(metadata);
        console.error("[next-auth][error][".concat(code, "]"), "\nhttps://next-auth.js.org/errors#".concat(code.toLowerCase()), metadata.message, metadata);
    },
    warn: function warn(code) {
        console.warn("[next-auth][warn][".concat(code, "]"), "\nhttps://next-auth.js.org/warnings#".concat(code.toLowerCase()));
    },
    debug: function debug(code, metadata) {
        console.log("[next-auth][debug][".concat(code, "]"), metadata);
    }
};
function setLogger() {
    var newLogger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
    var debug = arguments.length > 1 ? arguments[1] : undefined;
    if (!debug) _logger.debug = function() {};
    if (newLogger.error) _logger.error = newLogger.error;
    if (newLogger.warn) _logger.warn = newLogger.warn;
    if (newLogger.debug) _logger.debug = newLogger.debug;
}
var _default = _logger;
exports["default"] = _default;
function proxyLogger() {
    var logger = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : _logger;
    var basePath = arguments.length > 1 ? arguments[1] : undefined;
    try {
        if (true) {
            return logger;
        }
        var clientLogger = {};
        var _loop = function _loop(level) {
            clientLogger[level] = function(code, metadata) {
                _logger[level](code, metadata);
                if (level === "error") {
                    metadata = formatError(metadata);
                }
                ;
                metadata.client = true;
                var url = "".concat(basePath, "/_log");
                var body = new URLSearchParams(_objectSpread({
                    level: level,
                    code: code
                }, metadata));
                if (navigator.sendBeacon) {
                    return navigator.sendBeacon(url, body);
                }
                return fetch(url, {
                    method: "POST",
                    body: body,
                    keepalive: true
                });
            };
        };
        for(var level in logger){
            _loop(level);
        }
        return clientLogger;
    } catch (_unused) {
        return _logger;
    }
}


/***/ }),

/***/ 16454:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports.merge = merge;
function isObject(item) {
    return item && typeof item === "object" && !Array.isArray(item);
}
function merge(target, ...sources) {
    if (!sources.length) return target;
    const source = sources.shift();
    if (isObject(target) && isObject(source)) {
        for(const key in source){
            if (isObject(source[key])) {
                if (!target[key]) Object.assign(target, {
                    [key]: {}
                });
                merge(target[key], source[key]);
            } else {
                Object.assign(target, {
                    [key]: source[key]
                });
            }
        }
    }
    return merge(target, ...sources);
}


/***/ }),

/***/ 36150:
/***/ ((__unused_webpack_module, exports) => {

"use strict";

Object.defineProperty(exports, "__esModule", ({
    value: true
}));
exports["default"] = parseUrl;
function parseUrl(url) {
    var _url2;
    const defaultUrl = new URL("http://localhost:3000/api/auth");
    if (url && !url.startsWith("http")) {
        url = `https://${url}`;
    }
    const _url = new URL((_url2 = url) !== null && _url2 !== void 0 ? _url2 : defaultUrl);
    const path = (_url.pathname === "/" ? defaultUrl.pathname : _url.pathname).replace(/\/$/, "");
    const base = `${_url.origin}${path}`;
    return {
        origin: _url.origin,
        host: _url.host,
        path,
        base,
        toString: ()=>base
    };
}


/***/ }),

/***/ 95219:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(67996);


/***/ }),

/***/ 16190:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

exports.OAuth = __webpack_require__(9085).OAuth;
exports.OAuthEcho = __webpack_require__(9085).OAuthEcho;
exports.OAuth2 = __webpack_require__(16097).OAuth2;


/***/ }),

/***/ 51295:
/***/ ((module) => {

"use strict";
// Returns true if this is a host that closes *before* it ends?!?!

module.exports.isAnEarlyCloseHost = function(hostName) {
    return hostName && hostName.match(".*google(apis)?.com$");
};


/***/ }),

/***/ 9085:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var crypto = __webpack_require__(6113), sha1 = __webpack_require__(36750), http = __webpack_require__(13685), https = __webpack_require__(95687), URL = __webpack_require__(57310), querystring = __webpack_require__(63477), OAuthUtils = __webpack_require__(51295);
exports.OAuth = function(requestUrl, accessUrl, consumerKey, consumerSecret, version, authorize_callback, signatureMethod, nonceSize, customHeaders) {
    this._isEcho = false;
    this._requestUrl = requestUrl;
    this._accessUrl = accessUrl;
    this._consumerKey = consumerKey;
    this._consumerSecret = this._encodeData(consumerSecret);
    if (signatureMethod == "RSA-SHA1") {
        this._privateKey = consumerSecret;
    }
    this._version = version;
    if (authorize_callback === undefined) {
        this._authorize_callback = "oob";
    } else {
        this._authorize_callback = authorize_callback;
    }
    if (signatureMethod != "PLAINTEXT" && signatureMethod != "HMAC-SHA1" && signatureMethod != "RSA-SHA1") throw new Error("Un-supported signature method: " + signatureMethod);
    this._signatureMethod = signatureMethod;
    this._nonceSize = nonceSize || 32;
    this._headers = customHeaders || {
        "Accept": "*/*",
        "Connection": "close",
        "User-Agent": "Node authentication"
    };
    this._clientOptions = this._defaultClientOptions = {
        "requestTokenHttpMethod": "POST",
        "accessTokenHttpMethod": "POST",
        "followRedirects": true
    };
    this._oauthParameterSeperator = ",";
};
exports.OAuthEcho = function(realm, verify_credentials, consumerKey, consumerSecret, version, signatureMethod, nonceSize, customHeaders) {
    this._isEcho = true;
    this._realm = realm;
    this._verifyCredentials = verify_credentials;
    this._consumerKey = consumerKey;
    this._consumerSecret = this._encodeData(consumerSecret);
    if (signatureMethod == "RSA-SHA1") {
        this._privateKey = consumerSecret;
    }
    this._version = version;
    if (signatureMethod != "PLAINTEXT" && signatureMethod != "HMAC-SHA1" && signatureMethod != "RSA-SHA1") throw new Error("Un-supported signature method: " + signatureMethod);
    this._signatureMethod = signatureMethod;
    this._nonceSize = nonceSize || 32;
    this._headers = customHeaders || {
        "Accept": "*/*",
        "Connection": "close",
        "User-Agent": "Node authentication"
    };
    this._oauthParameterSeperator = ",";
};
exports.OAuthEcho.prototype = exports.OAuth.prototype;
exports.OAuth.prototype._getTimestamp = function() {
    return Math.floor(new Date().getTime() / 1000);
};
exports.OAuth.prototype._encodeData = function(toEncode) {
    if (toEncode == null || toEncode == "") return "";
    else {
        var result = encodeURIComponent(toEncode);
        // Fix the mismatch between OAuth's  RFC3986's and Javascript's beliefs in what is right and wrong ;)
        return result.replace(/\!/g, "%21").replace(/\'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
    }
};
exports.OAuth.prototype._decodeData = function(toDecode) {
    if (toDecode != null) {
        toDecode = toDecode.replace(/\+/g, " ");
    }
    return decodeURIComponent(toDecode);
};
exports.OAuth.prototype._getSignature = function(method, url, parameters, tokenSecret) {
    var signatureBase = this._createSignatureBase(method, url, parameters);
    return this._createSignature(signatureBase, tokenSecret);
};
exports.OAuth.prototype._normalizeUrl = function(url) {
    var parsedUrl = URL.parse(url, true);
    var port = "";
    if (parsedUrl.port) {
        if (parsedUrl.protocol == "http:" && parsedUrl.port != "80" || parsedUrl.protocol == "https:" && parsedUrl.port != "443") {
            port = ":" + parsedUrl.port;
        }
    }
    if (!parsedUrl.pathname || parsedUrl.pathname == "") parsedUrl.pathname = "/";
    return parsedUrl.protocol + "//" + parsedUrl.hostname + port + parsedUrl.pathname;
};
// Is the parameter considered an OAuth parameter
exports.OAuth.prototype._isParameterNameAnOAuthParameter = function(parameter) {
    var m = parameter.match("^oauth_");
    if (m && m[0] === "oauth_") {
        return true;
    } else {
        return false;
    }
};
// build the OAuth request authorization header
exports.OAuth.prototype._buildAuthorizationHeaders = function(orderedParameters) {
    var authHeader = "OAuth ";
    if (this._isEcho) {
        authHeader += 'realm="' + this._realm + '",';
    }
    for(var i = 0; i < orderedParameters.length; i++){
        // Whilst the all the parameters should be included within the signature, only the oauth_ arguments
        // should appear within the authorization header.
        if (this._isParameterNameAnOAuthParameter(orderedParameters[i][0])) {
            authHeader += "" + this._encodeData(orderedParameters[i][0]) + '="' + this._encodeData(orderedParameters[i][1]) + '"' + this._oauthParameterSeperator;
        }
    }
    authHeader = authHeader.substring(0, authHeader.length - this._oauthParameterSeperator.length);
    return authHeader;
};
// Takes an object literal that represents the arguments, and returns an array
// of argument/value pairs.
exports.OAuth.prototype._makeArrayOfArgumentsHash = function(argumentsHash) {
    var argument_pairs = [];
    for(var key in argumentsHash){
        if (argumentsHash.hasOwnProperty(key)) {
            var value = argumentsHash[key];
            if (Array.isArray(value)) {
                for(var i = 0; i < value.length; i++){
                    argument_pairs[argument_pairs.length] = [
                        key,
                        value[i]
                    ];
                }
            } else {
                argument_pairs[argument_pairs.length] = [
                    key,
                    value
                ];
            }
        }
    }
    return argument_pairs;
};
// Sorts the encoded key value pairs by encoded name, then encoded value
exports.OAuth.prototype._sortRequestParams = function(argument_pairs) {
    // Sort by name, then value.
    argument_pairs.sort(function(a, b) {
        if (a[0] == b[0]) {
            return a[1] < b[1] ? -1 : 1;
        } else return a[0] < b[0] ? -1 : 1;
    });
    return argument_pairs;
};
exports.OAuth.prototype._normaliseRequestParams = function(args) {
    var argument_pairs = this._makeArrayOfArgumentsHash(args);
    // First encode them #3.4.1.3.2 .1
    for(var i = 0; i < argument_pairs.length; i++){
        argument_pairs[i][0] = this._encodeData(argument_pairs[i][0]);
        argument_pairs[i][1] = this._encodeData(argument_pairs[i][1]);
    }
    // Then sort them #3.4.1.3.2 .2
    argument_pairs = this._sortRequestParams(argument_pairs);
    // Then concatenate together #3.4.1.3.2 .3 & .4
    var args = "";
    for(var i = 0; i < argument_pairs.length; i++){
        args += argument_pairs[i][0];
        args += "=";
        args += argument_pairs[i][1];
        if (i < argument_pairs.length - 1) args += "&";
    }
    return args;
};
exports.OAuth.prototype._createSignatureBase = function(method, url, parameters) {
    url = this._encodeData(this._normalizeUrl(url));
    parameters = this._encodeData(parameters);
    return method.toUpperCase() + "&" + url + "&" + parameters;
};
exports.OAuth.prototype._createSignature = function(signatureBase, tokenSecret) {
    if (tokenSecret === undefined) var tokenSecret = "";
    else tokenSecret = this._encodeData(tokenSecret);
    // consumerSecret is already encoded
    var key = this._consumerSecret + "&" + tokenSecret;
    var hash = "";
    if (this._signatureMethod == "PLAINTEXT") {
        hash = key;
    } else if (this._signatureMethod == "RSA-SHA1") {
        key = this._privateKey || "";
        hash = crypto.createSign("RSA-SHA1").update(signatureBase).sign(key, "base64");
    } else {
        if (crypto.Hmac) {
            hash = crypto.createHmac("sha1", key).update(signatureBase).digest("base64");
        } else {
            hash = sha1.HMACSHA1(key, signatureBase);
        }
    }
    return hash;
};
exports.OAuth.prototype.NONCE_CHARS = [
    "a",
    "b",
    "c",
    "d",
    "e",
    "f",
    "g",
    "h",
    "i",
    "j",
    "k",
    "l",
    "m",
    "n",
    "o",
    "p",
    "q",
    "r",
    "s",
    "t",
    "u",
    "v",
    "w",
    "x",
    "y",
    "z",
    "A",
    "B",
    "C",
    "D",
    "E",
    "F",
    "G",
    "H",
    "I",
    "J",
    "K",
    "L",
    "M",
    "N",
    "O",
    "P",
    "Q",
    "R",
    "S",
    "T",
    "U",
    "V",
    "W",
    "X",
    "Y",
    "Z",
    "0",
    "1",
    "2",
    "3",
    "4",
    "5",
    "6",
    "7",
    "8",
    "9"
];
exports.OAuth.prototype._getNonce = function(nonceSize) {
    var result = [];
    var chars = this.NONCE_CHARS;
    var char_pos;
    var nonce_chars_length = chars.length;
    for(var i = 0; i < nonceSize; i++){
        char_pos = Math.floor(Math.random() * nonce_chars_length);
        result[i] = chars[char_pos];
    }
    return result.join("");
};
exports.OAuth.prototype._createClient = function(port, hostname, method, path, headers, sslEnabled) {
    var options = {
        host: hostname,
        port: port,
        path: path,
        method: method,
        headers: headers
    };
    var httpModel;
    if (sslEnabled) {
        httpModel = https;
    } else {
        httpModel = http;
    }
    return httpModel.request(options);
};
exports.OAuth.prototype._prepareParameters = function(oauth_token, oauth_token_secret, method, url, extra_params) {
    var oauthParameters = {
        "oauth_timestamp": this._getTimestamp(),
        "oauth_nonce": this._getNonce(this._nonceSize),
        "oauth_version": this._version,
        "oauth_signature_method": this._signatureMethod,
        "oauth_consumer_key": this._consumerKey
    };
    if (oauth_token) {
        oauthParameters["oauth_token"] = oauth_token;
    }
    var sig;
    if (this._isEcho) {
        sig = this._getSignature("GET", this._verifyCredentials, this._normaliseRequestParams(oauthParameters), oauth_token_secret);
    } else {
        if (extra_params) {
            for(var key in extra_params){
                if (extra_params.hasOwnProperty(key)) oauthParameters[key] = extra_params[key];
            }
        }
        var parsedUrl = URL.parse(url, false);
        if (parsedUrl.query) {
            var key2;
            var extraParameters = querystring.parse(parsedUrl.query);
            for(var key in extraParameters){
                var value = extraParameters[key];
                if (typeof value == "object") {
                    // TODO: This probably should be recursive
                    for(key2 in value){
                        oauthParameters[key + "[" + key2 + "]"] = value[key2];
                    }
                } else {
                    oauthParameters[key] = value;
                }
            }
        }
        sig = this._getSignature(method, url, this._normaliseRequestParams(oauthParameters), oauth_token_secret);
    }
    var orderedParameters = this._sortRequestParams(this._makeArrayOfArgumentsHash(oauthParameters));
    orderedParameters[orderedParameters.length] = [
        "oauth_signature",
        sig
    ];
    return orderedParameters;
};
exports.OAuth.prototype._performSecureRequest = function(oauth_token, oauth_token_secret, method, url, extra_params, post_body, post_content_type, callback) {
    var orderedParameters = this._prepareParameters(oauth_token, oauth_token_secret, method, url, extra_params);
    if (!post_content_type) {
        post_content_type = "application/x-www-form-urlencoded";
    }
    var parsedUrl = URL.parse(url, false);
    if (parsedUrl.protocol == "http:" && !parsedUrl.port) parsedUrl.port = 80;
    if (parsedUrl.protocol == "https:" && !parsedUrl.port) parsedUrl.port = 443;
    var headers = {};
    var authorization = this._buildAuthorizationHeaders(orderedParameters);
    if (this._isEcho) {
        headers["X-Verify-Credentials-Authorization"] = authorization;
    } else {
        headers["Authorization"] = authorization;
    }
    headers["Host"] = parsedUrl.host;
    for(var key in this._headers){
        if (this._headers.hasOwnProperty(key)) {
            headers[key] = this._headers[key];
        }
    }
    // Filter out any passed extra_params that are really to do with OAuth
    for(var key in extra_params){
        if (this._isParameterNameAnOAuthParameter(key)) {
            delete extra_params[key];
        }
    }
    if ((method == "POST" || method == "PUT") && post_body == null && extra_params != null) {
        // Fix the mismatch between the output of querystring.stringify() and this._encodeData()
        post_body = querystring.stringify(extra_params).replace(/\!/g, "%21").replace(/\'/g, "%27").replace(/\(/g, "%28").replace(/\)/g, "%29").replace(/\*/g, "%2A");
    }
    if (post_body) {
        if (Buffer.isBuffer(post_body)) {
            headers["Content-length"] = post_body.length;
        } else {
            headers["Content-length"] = Buffer.byteLength(post_body);
        }
    } else {
        headers["Content-length"] = 0;
    }
    headers["Content-Type"] = post_content_type;
    var path;
    if (!parsedUrl.pathname || parsedUrl.pathname == "") parsedUrl.pathname = "/";
    if (parsedUrl.query) path = parsedUrl.pathname + "?" + parsedUrl.query;
    else path = parsedUrl.pathname;
    var request;
    if (parsedUrl.protocol == "https:") {
        request = this._createClient(parsedUrl.port, parsedUrl.hostname, method, path, headers, true);
    } else {
        request = this._createClient(parsedUrl.port, parsedUrl.hostname, method, path, headers);
    }
    var clientOptions = this._clientOptions;
    if (callback) {
        var data = "";
        var self = this;
        // Some hosts *cough* google appear to close the connection early / send no content-length header
        // allow this behaviour.
        var allowEarlyClose = OAuthUtils.isAnEarlyCloseHost(parsedUrl.hostname);
        var callbackCalled = false;
        var passBackControl = function(response) {
            if (!callbackCalled) {
                callbackCalled = true;
                if (response.statusCode >= 200 && response.statusCode <= 299) {
                    callback(null, data, response);
                } else {
                    // Follow 301 or 302 redirects with Location HTTP header
                    if ((response.statusCode == 301 || response.statusCode == 302) && clientOptions.followRedirects && response.headers && response.headers.location) {
                        self._performSecureRequest(oauth_token, oauth_token_secret, method, response.headers.location, extra_params, post_body, post_content_type, callback);
                    } else {
                        callback({
                            statusCode: response.statusCode,
                            data: data
                        }, data, response);
                    }
                }
            }
        };
        request.on("response", function(response) {
            response.setEncoding("utf8");
            response.on("data", function(chunk) {
                data += chunk;
            });
            response.on("end", function() {
                passBackControl(response);
            });
            response.on("close", function() {
                if (allowEarlyClose) {
                    passBackControl(response);
                }
            });
        });
        request.on("error", function(err) {
            if (!callbackCalled) {
                callbackCalled = true;
                callback(err);
            }
        });
        if ((method == "POST" || method == "PUT") && post_body != null && post_body != "") {
            request.write(post_body);
        }
        request.end();
    } else {
        if ((method == "POST" || method == "PUT") && post_body != null && post_body != "") {
            request.write(post_body);
        }
        return request;
    }
    return;
};
exports.OAuth.prototype.setClientOptions = function(options) {
    var key, mergedOptions = {}, hasOwnProperty = Object.prototype.hasOwnProperty;
    for(key in this._defaultClientOptions){
        if (!hasOwnProperty.call(options, key)) {
            mergedOptions[key] = this._defaultClientOptions[key];
        } else {
            mergedOptions[key] = options[key];
        }
    }
    this._clientOptions = mergedOptions;
};
exports.OAuth.prototype.getOAuthAccessToken = function(oauth_token, oauth_token_secret, oauth_verifier, callback) {
    var extraParams = {};
    if (typeof oauth_verifier == "function") {
        callback = oauth_verifier;
    } else {
        extraParams.oauth_verifier = oauth_verifier;
    }
    this._performSecureRequest(oauth_token, oauth_token_secret, this._clientOptions.accessTokenHttpMethod, this._accessUrl, extraParams, null, null, function(error, data, response) {
        if (error) callback(error);
        else {
            var results = querystring.parse(data);
            var oauth_access_token = results["oauth_token"];
            delete results["oauth_token"];
            var oauth_access_token_secret = results["oauth_token_secret"];
            delete results["oauth_token_secret"];
            callback(null, oauth_access_token, oauth_access_token_secret, results);
        }
    });
};
// Deprecated
exports.OAuth.prototype.getProtectedResource = function(url, method, oauth_token, oauth_token_secret, callback) {
    this._performSecureRequest(oauth_token, oauth_token_secret, method, url, null, "", null, callback);
};
exports.OAuth.prototype["delete"] = function(url, oauth_token, oauth_token_secret, callback) {
    return this._performSecureRequest(oauth_token, oauth_token_secret, "DELETE", url, null, "", null, callback);
};
exports.OAuth.prototype.get = function(url, oauth_token, oauth_token_secret, callback) {
    return this._performSecureRequest(oauth_token, oauth_token_secret, "GET", url, null, "", null, callback);
};
exports.OAuth.prototype._putOrPost = function(method, url, oauth_token, oauth_token_secret, post_body, post_content_type, callback) {
    var extra_params = null;
    if (typeof post_content_type == "function") {
        callback = post_content_type;
        post_content_type = null;
    }
    if (typeof post_body != "string" && !Buffer.isBuffer(post_body)) {
        post_content_type = "application/x-www-form-urlencoded";
        extra_params = post_body;
        post_body = null;
    }
    return this._performSecureRequest(oauth_token, oauth_token_secret, method, url, extra_params, post_body, post_content_type, callback);
};
exports.OAuth.prototype.put = function(url, oauth_token, oauth_token_secret, post_body, post_content_type, callback) {
    return this._putOrPost("PUT", url, oauth_token, oauth_token_secret, post_body, post_content_type, callback);
};
exports.OAuth.prototype.post = function(url, oauth_token, oauth_token_secret, post_body, post_content_type, callback) {
    return this._putOrPost("POST", url, oauth_token, oauth_token_secret, post_body, post_content_type, callback);
};
/**
 * Gets a request token from the OAuth provider and passes that information back
 * to the calling code.
 *
 * The callback should expect a function of the following form:
 *
 * function(err, token, token_secret, parsedQueryString) {}
 *
 * This method has optional parameters so can be called in the following 2 ways:
 *
 * 1) Primary use case: Does a basic request with no extra parameters
 *  getOAuthRequestToken( callbackFunction )
 *
 * 2) As above but allows for provision of extra parameters to be sent as part of the query to the server.
 *  getOAuthRequestToken( extraParams, callbackFunction )
 *
 * N.B. This method will HTTP POST verbs by default, if you wish to override this behaviour you will
 * need to provide a requestTokenHttpMethod option when creating the client.
 *
 **/ exports.OAuth.prototype.getOAuthRequestToken = function(extraParams, callback) {
    if (typeof extraParams == "function") {
        callback = extraParams;
        extraParams = {};
    }
    // Callbacks are 1.0A related
    if (this._authorize_callback) {
        extraParams["oauth_callback"] = this._authorize_callback;
    }
    this._performSecureRequest(null, null, this._clientOptions.requestTokenHttpMethod, this._requestUrl, extraParams, null, null, function(error, data, response) {
        if (error) callback(error);
        else {
            var results = querystring.parse(data);
            var oauth_token = results["oauth_token"];
            var oauth_token_secret = results["oauth_token_secret"];
            delete results["oauth_token"];
            delete results["oauth_token_secret"];
            callback(null, oauth_token, oauth_token_secret, results);
        }
    });
};
exports.OAuth.prototype.signUrl = function(url, oauth_token, oauth_token_secret, method) {
    if (method === undefined) {
        var method = "GET";
    }
    var orderedParameters = this._prepareParameters(oauth_token, oauth_token_secret, method, url, {});
    var parsedUrl = URL.parse(url, false);
    var query = "";
    for(var i = 0; i < orderedParameters.length; i++){
        query += orderedParameters[i][0] + "=" + this._encodeData(orderedParameters[i][1]) + "&";
    }
    query = query.substring(0, query.length - 1);
    return parsedUrl.protocol + "//" + parsedUrl.host + parsedUrl.pathname + "?" + query;
};
exports.OAuth.prototype.authHeader = function(url, oauth_token, oauth_token_secret, method) {
    if (method === undefined) {
        var method = "GET";
    }
    var orderedParameters = this._prepareParameters(oauth_token, oauth_token_secret, method, url, {});
    return this._buildAuthorizationHeaders(orderedParameters);
};


/***/ }),

/***/ 16097:
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

var querystring = __webpack_require__(63477), crypto = __webpack_require__(6113), https = __webpack_require__(95687), http = __webpack_require__(13685), URL = __webpack_require__(57310), OAuthUtils = __webpack_require__(51295);
exports.OAuth2 = function(clientId, clientSecret, baseSite, authorizePath, accessTokenPath, customHeaders) {
    this._clientId = clientId;
    this._clientSecret = clientSecret;
    this._baseSite = baseSite;
    this._authorizeUrl = authorizePath || "/oauth/authorize";
    this._accessTokenUrl = accessTokenPath || "/oauth/access_token";
    this._accessTokenName = "access_token";
    this._authMethod = "Bearer";
    this._customHeaders = customHeaders || {};
    this._useAuthorizationHeaderForGET = false;
    //our agent
    this._agent = undefined;
};
// Allows you to set an agent to use instead of the default HTTP or
// HTTPS agents. Useful when dealing with your own certificates.
exports.OAuth2.prototype.setAgent = function(agent) {
    this._agent = agent;
};
// This 'hack' method is required for sites that don't use
// 'access_token' as the name of the access token (for requests).
// ( http://tools.ietf.org/html/draft-ietf-oauth-v2-16#section-7 )
// it isn't clear what the correct value should be atm, so allowing
// for specific (temporary?) override for now.
exports.OAuth2.prototype.setAccessTokenName = function(name) {
    this._accessTokenName = name;
};
// Sets the authorization method for Authorization header.
// e.g. Authorization: Bearer <token>  # "Bearer" is the authorization method.
exports.OAuth2.prototype.setAuthMethod = function(authMethod) {
    this._authMethod = authMethod;
};
// If you use the OAuth2 exposed 'get' method (and don't construct your own _request call )
// this will specify whether to use an 'Authorize' header instead of passing the access_token as a query parameter
exports.OAuth2.prototype.useAuthorizationHeaderforGET = function(useIt) {
    this._useAuthorizationHeaderForGET = useIt;
};
exports.OAuth2.prototype._getAccessTokenUrl = function() {
    return this._baseSite + this._accessTokenUrl; /* + "?" + querystring.stringify(params); */ 
};
// Build the authorization header. In particular, build the part after the colon.
// e.g. Authorization: Bearer <token>  # Build "Bearer <token>"
exports.OAuth2.prototype.buildAuthHeader = function(token) {
    return this._authMethod + " " + token;
};
exports.OAuth2.prototype._chooseHttpLibrary = function(parsedUrl) {
    var http_library = https;
    // As this is OAUth2, we *assume* https unless told explicitly otherwise.
    if (parsedUrl.protocol != "https:") {
        http_library = http;
    }
    return http_library;
};
exports.OAuth2.prototype._request = function(method, url, headers, post_body, access_token, callback) {
    var parsedUrl = URL.parse(url, true);
    if (parsedUrl.protocol == "https:" && !parsedUrl.port) {
        parsedUrl.port = 443;
    }
    var http_library = this._chooseHttpLibrary(parsedUrl);
    var realHeaders = {};
    for(var key in this._customHeaders){
        realHeaders[key] = this._customHeaders[key];
    }
    if (headers) {
        for(var key in headers){
            realHeaders[key] = headers[key];
        }
    }
    realHeaders["Host"] = parsedUrl.host;
    if (!realHeaders["User-Agent"]) {
        realHeaders["User-Agent"] = "Node-oauth";
    }
    if (post_body) {
        if (Buffer.isBuffer(post_body)) {
            realHeaders["Content-Length"] = post_body.length;
        } else {
            realHeaders["Content-Length"] = Buffer.byteLength(post_body);
        }
    } else {
        realHeaders["Content-length"] = 0;
    }
    if (access_token && !("Authorization" in realHeaders)) {
        if (!parsedUrl.query) parsedUrl.query = {};
        parsedUrl.query[this._accessTokenName] = access_token;
    }
    var queryStr = querystring.stringify(parsedUrl.query);
    if (queryStr) queryStr = "?" + queryStr;
    var options = {
        host: parsedUrl.hostname,
        port: parsedUrl.port,
        path: parsedUrl.pathname + queryStr,
        method: method,
        headers: realHeaders
    };
    this._executeRequest(http_library, options, post_body, callback);
};
exports.OAuth2.prototype._executeRequest = function(http_library, options, post_body, callback) {
    // Some hosts *cough* google appear to close the connection early / send no content-length header
    // allow this behaviour.
    var allowEarlyClose = OAuthUtils.isAnEarlyCloseHost(options.host);
    var callbackCalled = false;
    function passBackControl(response, result) {
        if (!callbackCalled) {
            callbackCalled = true;
            if (!(response.statusCode >= 200 && response.statusCode <= 299) && response.statusCode != 301 && response.statusCode != 302) {
                callback({
                    statusCode: response.statusCode,
                    data: result
                });
            } else {
                callback(null, result, response);
            }
        }
    }
    var result = "";
    //set the agent on the request options
    if (this._agent) {
        options.agent = this._agent;
    }
    var request = http_library.request(options);
    request.on("response", function(response) {
        response.on("data", function(chunk) {
            result += chunk;
        });
        response.on("close", function(err) {
            if (allowEarlyClose) {
                passBackControl(response, result);
            }
        });
        response.addListener("end", function() {
            passBackControl(response, result);
        });
    });
    request.on("error", function(e) {
        callbackCalled = true;
        callback(e);
    });
    if ((options.method == "POST" || options.method == "PUT") && post_body) {
        request.write(post_body);
    }
    request.end();
};
exports.OAuth2.prototype.getAuthorizeUrl = function(params) {
    var params = params || {};
    params["client_id"] = this._clientId;
    return this._baseSite + this._authorizeUrl + "?" + querystring.stringify(params);
};
exports.OAuth2.prototype.getOAuthAccessToken = function(code, params, callback) {
    var params = params || {};
    params["client_id"] = this._clientId;
    params["client_secret"] = this._clientSecret;
    var codeParam = params.grant_type === "refresh_token" ? "refresh_token" : "code";
    params[codeParam] = code;
    var post_data = querystring.stringify(params);
    var post_headers = {
        "Content-Type": "application/x-www-form-urlencoded"
    };
    this._request("POST", this._getAccessTokenUrl(), post_headers, post_data, null, function(error, data, response) {
        if (error) callback(error);
        else {
            var results;
            try {
                // As of http://tools.ietf.org/html/draft-ietf-oauth-v2-07
                // responses should be in JSON
                results = JSON.parse(data);
            } catch (e) {
                // .... However both Facebook + Github currently use rev05 of the spec
                // and neither seem to specify a content-type correctly in their response headers :(
                // clients of these services will suffer a *minor* performance cost of the exception
                // being thrown
                results = querystring.parse(data);
            }
            var access_token = results["access_token"];
            var refresh_token = results["refresh_token"];
            delete results["refresh_token"];
            callback(null, access_token, refresh_token, results); // callback results =-=
        }
    });
};
// Deprecated
exports.OAuth2.prototype.getProtectedResource = function(url, access_token, callback) {
    this._request("GET", url, {}, "", access_token, callback);
};
exports.OAuth2.prototype.get = function(url, access_token, callback) {
    if (this._useAuthorizationHeaderForGET) {
        var headers = {
            "Authorization": this.buildAuthHeader(access_token)
        };
        access_token = null;
    } else {
        headers = {};
    }
    this._request("GET", url, headers, "", access_token, callback);
};


/***/ }),

/***/ 36750:
/***/ ((__unused_webpack_module, exports) => {

/*
 * A JavaScript implementation of the Secure Hash Algorithm, SHA-1, as defined
 * in FIPS 180-1
 * Version 2.2 Copyright Paul Johnston 2000 - 2009.
 * Other contributors: Greg Holt, Andrew Kepert, Ydnar, Lostinet
 * Distributed under the BSD License
 * See http://pajhome.org.uk/crypt/md5 for details.
 */ /*
 * Configurable variables. You may need to tweak these to be compatible with
 * the server-side, but the defaults work in most cases.
 */ var hexcase = 1; /* hex output format. 0 - lowercase; 1 - uppercase        */ 
var b64pad = "="; /* base-64 pad character. "=" for strict RFC compliance   */ 
/*
 * These are the functions you'll usually want to call
 * They take string arguments and return either hex or base-64 encoded strings
 */ function hex_sha1(s) {
    return rstr2hex(rstr_sha1(str2rstr_utf8(s)));
}
function b64_sha1(s) {
    return rstr2b64(rstr_sha1(str2rstr_utf8(s)));
}
function any_sha1(s, e) {
    return rstr2any(rstr_sha1(str2rstr_utf8(s)), e);
}
function hex_hmac_sha1(k, d) {
    return rstr2hex(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)));
}
function b64_hmac_sha1(k, d) {
    return rstr2b64(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)));
}
function any_hmac_sha1(k, d, e) {
    return rstr2any(rstr_hmac_sha1(str2rstr_utf8(k), str2rstr_utf8(d)), e);
}
/*
 * Perform a simple self-test to see if the VM is working
 */ function sha1_vm_test() {
    return hex_sha1("abc").toLowerCase() == "a9993e364706816aba3e25717850c26c9cd0d89d";
}
/*
 * Calculate the SHA1 of a raw string
 */ function rstr_sha1(s) {
    return binb2rstr(binb_sha1(rstr2binb(s), s.length * 8));
}
/*
 * Calculate the HMAC-SHA1 of a key and some data (raw strings)
 */ function rstr_hmac_sha1(key, data) {
    var bkey = rstr2binb(key);
    if (bkey.length > 16) bkey = binb_sha1(bkey, key.length * 8);
    var ipad = Array(16), opad = Array(16);
    for(var i = 0; i < 16; i++){
        ipad[i] = bkey[i] ^ 0x36363636;
        opad[i] = bkey[i] ^ 0x5C5C5C5C;
    }
    var hash = binb_sha1(ipad.concat(rstr2binb(data)), 512 + data.length * 8);
    return binb2rstr(binb_sha1(opad.concat(hash), 512 + 160));
}
/*
 * Convert a raw string to a hex string
 */ function rstr2hex(input) {
    try {
        hexcase;
    } catch (e) {
        hexcase = 0;
    }
    var hex_tab = hexcase ? "0123456789ABCDEF" : "0123456789abcdef";
    var output = "";
    var x;
    for(var i = 0; i < input.length; i++){
        x = input.charCodeAt(i);
        output += hex_tab.charAt(x >>> 4 & 0x0F) + hex_tab.charAt(x & 0x0F);
    }
    return output;
}
/*
 * Convert a raw string to a base-64 string
 */ function rstr2b64(input) {
    try {
        b64pad;
    } catch (e) {
        b64pad = "";
    }
    var tab = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/";
    var output = "";
    var len = input.length;
    for(var i = 0; i < len; i += 3){
        var triplet = input.charCodeAt(i) << 16 | (i + 1 < len ? input.charCodeAt(i + 1) << 8 : 0) | (i + 2 < len ? input.charCodeAt(i + 2) : 0);
        for(var j = 0; j < 4; j++){
            if (i * 8 + j * 6 > input.length * 8) output += b64pad;
            else output += tab.charAt(triplet >>> 6 * (3 - j) & 0x3F);
        }
    }
    return output;
}
/*
 * Convert a raw string to an arbitrary string encoding
 */ function rstr2any(input, encoding) {
    var divisor = encoding.length;
    var remainders = Array();
    var i, q, x, quotient;
    /* Convert to an array of 16-bit big-endian values, forming the dividend */ var dividend = Array(Math.ceil(input.length / 2));
    for(i = 0; i < dividend.length; i++){
        dividend[i] = input.charCodeAt(i * 2) << 8 | input.charCodeAt(i * 2 + 1);
    }
    /*
   * Repeatedly perform a long division. The binary array forms the dividend,
   * the length of the encoding is the divisor. Once computed, the quotient
   * forms the dividend for the next step. We stop when the dividend is zero.
   * All remainders are stored for later use.
   */ while(dividend.length > 0){
        quotient = Array();
        x = 0;
        for(i = 0; i < dividend.length; i++){
            x = (x << 16) + dividend[i];
            q = Math.floor(x / divisor);
            x -= q * divisor;
            if (quotient.length > 0 || q > 0) quotient[quotient.length] = q;
        }
        remainders[remainders.length] = x;
        dividend = quotient;
    }
    /* Convert the remainders to the output string */ var output = "";
    for(i = remainders.length - 1; i >= 0; i--)output += encoding.charAt(remainders[i]);
    /* Append leading zero equivalents */ var full_length = Math.ceil(input.length * 8 / (Math.log(encoding.length) / Math.log(2)));
    for(i = output.length; i < full_length; i++)output = encoding[0] + output;
    return output;
}
/*
 * Encode a string as utf-8.
 * For efficiency, this assumes the input is valid utf-16.
 */ function str2rstr_utf8(input) {
    var output = "";
    var i = -1;
    var x, y;
    while(++i < input.length){
        /* Decode utf-16 surrogate pairs */ x = input.charCodeAt(i);
        y = i + 1 < input.length ? input.charCodeAt(i + 1) : 0;
        if (0xD800 <= x && x <= 0xDBFF && 0xDC00 <= y && y <= 0xDFFF) {
            x = 0x10000 + ((x & 0x03FF) << 10) + (y & 0x03FF);
            i++;
        }
        /* Encode output as utf-8 */ if (x <= 0x7F) output += String.fromCharCode(x);
        else if (x <= 0x7FF) output += String.fromCharCode(0xC0 | x >>> 6 & 0x1F, 0x80 | x & 0x3F);
        else if (x <= 0xFFFF) output += String.fromCharCode(0xE0 | x >>> 12 & 0x0F, 0x80 | x >>> 6 & 0x3F, 0x80 | x & 0x3F);
        else if (x <= 0x1FFFFF) output += String.fromCharCode(0xF0 | x >>> 18 & 0x07, 0x80 | x >>> 12 & 0x3F, 0x80 | x >>> 6 & 0x3F, 0x80 | x & 0x3F);
    }
    return output;
}
/*
 * Encode a string as utf-16
 */ function str2rstr_utf16le(input) {
    var output = "";
    for(var i = 0; i < input.length; i++)output += String.fromCharCode(input.charCodeAt(i) & 0xFF, input.charCodeAt(i) >>> 8 & 0xFF);
    return output;
}
function str2rstr_utf16be(input) {
    var output = "";
    for(var i = 0; i < input.length; i++)output += String.fromCharCode(input.charCodeAt(i) >>> 8 & 0xFF, input.charCodeAt(i) & 0xFF);
    return output;
}
/*
 * Convert a raw string to an array of big-endian words
 * Characters >255 have their high-byte silently ignored.
 */ function rstr2binb(input) {
    var output = Array(input.length >> 2);
    for(var i = 0; i < output.length; i++)output[i] = 0;
    for(var i = 0; i < input.length * 8; i += 8)output[i >> 5] |= (input.charCodeAt(i / 8) & 0xFF) << 24 - i % 32;
    return output;
}
/*
 * Convert an array of big-endian words to a string
 */ function binb2rstr(input) {
    var output = "";
    for(var i = 0; i < input.length * 32; i += 8)output += String.fromCharCode(input[i >> 5] >>> 24 - i % 32 & 0xFF);
    return output;
}
/*
 * Calculate the SHA-1 of an array of big-endian words, and a bit length
 */ function binb_sha1(x, len) {
    /* append padding */ x[len >> 5] |= 0x80 << 24 - len % 32;
    x[(len + 64 >> 9 << 4) + 15] = len;
    var w = Array(80);
    var a = 1732584193;
    var b = -271733879;
    var c = -1732584194;
    var d = 271733878;
    var e = -1009589776;
    for(var i = 0; i < x.length; i += 16){
        var olda = a;
        var oldb = b;
        var oldc = c;
        var oldd = d;
        var olde = e;
        for(var j = 0; j < 80; j++){
            if (j < 16) w[j] = x[i + j];
            else w[j] = bit_rol(w[j - 3] ^ w[j - 8] ^ w[j - 14] ^ w[j - 16], 1);
            var t = safe_add(safe_add(bit_rol(a, 5), sha1_ft(j, b, c, d)), safe_add(safe_add(e, w[j]), sha1_kt(j)));
            e = d;
            d = c;
            c = bit_rol(b, 30);
            b = a;
            a = t;
        }
        a = safe_add(a, olda);
        b = safe_add(b, oldb);
        c = safe_add(c, oldc);
        d = safe_add(d, oldd);
        e = safe_add(e, olde);
    }
    return Array(a, b, c, d, e);
}
/*
 * Perform the appropriate triplet combination function for the current
 * iteration
 */ function sha1_ft(t, b, c, d) {
    if (t < 20) return b & c | ~b & d;
    if (t < 40) return b ^ c ^ d;
    if (t < 60) return b & c | b & d | c & d;
    return b ^ c ^ d;
}
/*
 * Determine the appropriate additive constant for the current iteration
 */ function sha1_kt(t) {
    return t < 20 ? 1518500249 : t < 40 ? 1859775393 : t < 60 ? -1894007588 : -899497514;
}
/*
 * Add integers, wrapping at 2^32. This uses 16-bit operations internally
 * to work around bugs in some JS interpreters.
 */ function safe_add(x, y) {
    var lsw = (x & 0xFFFF) + (y & 0xFFFF);
    var msw = (x >> 16) + (y >> 16) + (lsw >> 16);
    return msw << 16 | lsw & 0xFFFF;
}
/*
 * Bitwise rotate a 32-bit number to the left.
 */ function bit_rol(num, cnt) {
    return num << cnt | num >>> 32 - cnt;
}
exports.HMACSHA1 = function(key, data) {
    return b64_hmac_sha1(key, data);
};


/***/ }),

/***/ 14256:
/***/ ((module, exports, __webpack_require__) => {

"use strict";

var crypto = __webpack_require__(6113);
/**
 * Exported function
 *
 * Options:
 *
 *  - `algorithm` hash algo to be used by this instance: *'sha1', 'md5'
 *  - `excludeValues` {true|*false} hash object keys, values ignored
 *  - `encoding` hash encoding, supports 'buffer', '*hex', 'binary', 'base64'
 *  - `ignoreUnknown` {true|*false} ignore unknown object types
 *  - `replacer` optional function that replaces values before hashing
 *  - `respectFunctionProperties` {*true|false} consider function properties when hashing
 *  - `respectFunctionNames` {*true|false} consider 'name' property of functions for hashing
 *  - `respectType` {*true|false} Respect special properties (prototype, constructor)
 *    when hashing to distinguish between types
 *  - `unorderedArrays` {true|*false} Sort all arrays before hashing
 *  - `unorderedSets` {*true|false} Sort `Set` and `Map` instances before hashing
 *  * = default
 *
 * @param {object} object value to hash
 * @param {object} options hashing options
 * @return {string} hash value
 * @api public
 */ exports = module.exports = objectHash;
function objectHash(object, options) {
    options = applyDefaults(object, options);
    return hash(object, options);
}
/**
 * Exported sugar methods
 *
 * @param {object} object value to hash
 * @return {string} hash value
 * @api public
 */ exports.sha1 = function(object) {
    return objectHash(object);
};
exports.keys = function(object) {
    return objectHash(object, {
        excludeValues: true,
        algorithm: "sha1",
        encoding: "hex"
    });
};
exports.MD5 = function(object) {
    return objectHash(object, {
        algorithm: "md5",
        encoding: "hex"
    });
};
exports.keysMD5 = function(object) {
    return objectHash(object, {
        algorithm: "md5",
        encoding: "hex",
        excludeValues: true
    });
};
// Internals
var hashes = crypto.getHashes ? crypto.getHashes().slice() : [
    "sha1",
    "md5"
];
hashes.push("passthrough");
var encodings = [
    "buffer",
    "hex",
    "binary",
    "base64"
];
function applyDefaults(object, sourceOptions) {
    sourceOptions = sourceOptions || {};
    // create a copy rather than mutating
    var options = {};
    options.algorithm = sourceOptions.algorithm || "sha1";
    options.encoding = sourceOptions.encoding || "hex";
    options.excludeValues = sourceOptions.excludeValues ? true : false;
    options.algorithm = options.algorithm.toLowerCase();
    options.encoding = options.encoding.toLowerCase();
    options.ignoreUnknown = sourceOptions.ignoreUnknown !== true ? false : true; // default to false
    options.respectType = sourceOptions.respectType === false ? false : true; // default to true
    options.respectFunctionNames = sourceOptions.respectFunctionNames === false ? false : true;
    options.respectFunctionProperties = sourceOptions.respectFunctionProperties === false ? false : true;
    options.unorderedArrays = sourceOptions.unorderedArrays !== true ? false : true; // default to false
    options.unorderedSets = sourceOptions.unorderedSets === false ? false : true; // default to false
    options.unorderedObjects = sourceOptions.unorderedObjects === false ? false : true; // default to true
    options.replacer = sourceOptions.replacer || undefined;
    options.excludeKeys = sourceOptions.excludeKeys || undefined;
    if (typeof object === "undefined") {
        throw new Error("Object argument required.");
    }
    // if there is a case-insensitive match in the hashes list, accept it
    // (i.e. SHA256 for sha256)
    for(var i = 0; i < hashes.length; ++i){
        if (hashes[i].toLowerCase() === options.algorithm.toLowerCase()) {
            options.algorithm = hashes[i];
        }
    }
    if (hashes.indexOf(options.algorithm) === -1) {
        throw new Error('Algorithm "' + options.algorithm + '"  not supported. ' + "supported values: " + hashes.join(", "));
    }
    if (encodings.indexOf(options.encoding) === -1 && options.algorithm !== "passthrough") {
        throw new Error('Encoding "' + options.encoding + '"  not supported. ' + "supported values: " + encodings.join(", "));
    }
    return options;
}
/** Check if the given function is a native function */ function isNativeFunction(f) {
    if (typeof f !== "function") {
        return false;
    }
    var exp = /^function\s+\w*\s*\(\s*\)\s*{\s+\[native code\]\s+}$/i;
    return exp.exec(Function.prototype.toString.call(f)) != null;
}
function hash(object, options) {
    var hashingStream;
    if (options.algorithm !== "passthrough") {
        hashingStream = crypto.createHash(options.algorithm);
    } else {
        hashingStream = new PassThrough();
    }
    if (typeof hashingStream.write === "undefined") {
        hashingStream.write = hashingStream.update;
        hashingStream.end = hashingStream.update;
    }
    var hasher = typeHasher(options, hashingStream);
    hasher.dispatch(object);
    if (!hashingStream.update) {
        hashingStream.end("");
    }
    if (hashingStream.digest) {
        return hashingStream.digest(options.encoding === "buffer" ? undefined : options.encoding);
    }
    var buf = hashingStream.read();
    if (options.encoding === "buffer") {
        return buf;
    }
    return buf.toString(options.encoding);
}
/**
 * Expose streaming API
 *
 * @param {object} object  Value to serialize
 * @param {object} options  Options, as for hash()
 * @param {object} stream  A stream to write the serializiation to
 * @api public
 */ exports.writeToStream = function(object, options, stream) {
    if (typeof stream === "undefined") {
        stream = options;
        options = {};
    }
    options = applyDefaults(object, options);
    return typeHasher(options, stream).dispatch(object);
};
function typeHasher(options, writeTo, context) {
    context = context || [];
    var write = function(str) {
        if (writeTo.update) {
            return writeTo.update(str, "utf8");
        } else {
            return writeTo.write(str, "utf8");
        }
    };
    return {
        dispatch: function(value) {
            if (options.replacer) {
                value = options.replacer(value);
            }
            var type = typeof value;
            if (value === null) {
                type = "null";
            }
            //console.log("[DEBUG] Dispatch: ", value, "->", type, " -> ", "_" + type);
            return this["_" + type](value);
        },
        _object: function(object) {
            var pattern = /\[object (.*)\]/i;
            var objString = Object.prototype.toString.call(object);
            var objType = pattern.exec(objString);
            if (!objType) {
                objType = "unknown:[" + objString + "]";
            } else {
                objType = objType[1]; // take only the class name
            }
            objType = objType.toLowerCase();
            var objectNumber = null;
            if ((objectNumber = context.indexOf(object)) >= 0) {
                return this.dispatch("[CIRCULAR:" + objectNumber + "]");
            } else {
                context.push(object);
            }
            if (typeof Buffer !== "undefined" && Buffer.isBuffer && Buffer.isBuffer(object)) {
                write("buffer:");
                return write(object);
            }
            if (objType !== "object" && objType !== "function" && objType !== "asyncfunction") {
                if (this["_" + objType]) {
                    this["_" + objType](object);
                } else if (options.ignoreUnknown) {
                    return write("[" + objType + "]");
                } else {
                    throw new Error('Unknown object type "' + objType + '"');
                }
            } else {
                var keys = Object.keys(object);
                if (options.unorderedObjects) {
                    keys = keys.sort();
                }
                // Make sure to incorporate special properties, so
                // Types with different prototypes will produce
                // a different hash and objects derived from
                // different functions (`new Foo`, `new Bar`) will
                // produce different hashes.
                // We never do this for native functions since some
                // seem to break because of that.
                if (options.respectType !== false && !isNativeFunction(object)) {
                    keys.splice(0, 0, "prototype", "__proto__", "constructor");
                }
                if (options.excludeKeys) {
                    keys = keys.filter(function(key) {
                        return !options.excludeKeys(key);
                    });
                }
                write("object:" + keys.length + ":");
                var self = this;
                return keys.forEach(function(key) {
                    self.dispatch(key);
                    write(":");
                    if (!options.excludeValues) {
                        self.dispatch(object[key]);
                    }
                    write(",");
                });
            }
        },
        _array: function(arr, unordered) {
            unordered = typeof unordered !== "undefined" ? unordered : options.unorderedArrays !== false; // default to options.unorderedArrays
            var self = this;
            write("array:" + arr.length + ":");
            if (!unordered || arr.length <= 1) {
                return arr.forEach(function(entry) {
                    return self.dispatch(entry);
                });
            }
            // the unordered case is a little more complicated:
            // since there is no canonical ordering on objects,
            // i.e. {a:1} < {a:2} and {a:1} > {a:2} are both false,
            // we first serialize each entry using a PassThrough stream
            // before sorting.
            // also: we cant use the same context array for all entries
            // since the order of hashing should *not* matter. instead,
            // we keep track of the additions to a copy of the context array
            // and add all of them to the global context array when were done
            var contextAdditions = [];
            var entries = arr.map(function(entry) {
                var strm = new PassThrough();
                var localContext = context.slice(); // make copy
                var hasher = typeHasher(options, strm, localContext);
                hasher.dispatch(entry);
                // take only what was added to localContext and append it to contextAdditions
                contextAdditions = contextAdditions.concat(localContext.slice(context.length));
                return strm.read().toString();
            });
            context = context.concat(contextAdditions);
            entries.sort();
            return this._array(entries, false);
        },
        _date: function(date) {
            return write("date:" + date.toJSON());
        },
        _symbol: function(sym) {
            return write("symbol:" + sym.toString());
        },
        _error: function(err) {
            return write("error:" + err.toString());
        },
        _boolean: function(bool) {
            return write("bool:" + bool.toString());
        },
        _string: function(string) {
            write("string:" + string.length + ":");
            write(string.toString());
        },
        _function: function(fn) {
            write("fn:");
            if (isNativeFunction(fn)) {
                this.dispatch("[native]");
            } else {
                this.dispatch(fn.toString());
            }
            if (options.respectFunctionNames !== false) {
                // Make sure we can still distinguish native functions
                // by their name, otherwise String and Function will
                // have the same hash
                this.dispatch("function-name:" + String(fn.name));
            }
            if (options.respectFunctionProperties) {
                this._object(fn);
            }
        },
        _number: function(number) {
            return write("number:" + number.toString());
        },
        _xml: function(xml) {
            return write("xml:" + xml.toString());
        },
        _null: function() {
            return write("Null");
        },
        _undefined: function() {
            return write("Undefined");
        },
        _regexp: function(regex) {
            return write("regex:" + regex.toString());
        },
        _uint8array: function(arr) {
            write("uint8array:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint8clampedarray: function(arr) {
            write("uint8clampedarray:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int8array: function(arr) {
            write("uint8array:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint16array: function(arr) {
            write("uint16array:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int16array: function(arr) {
            write("uint16array:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _uint32array: function(arr) {
            write("uint32array:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _int32array: function(arr) {
            write("uint32array:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _float32array: function(arr) {
            write("float32array:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _float64array: function(arr) {
            write("float64array:");
            return this.dispatch(Array.prototype.slice.call(arr));
        },
        _arraybuffer: function(arr) {
            write("arraybuffer:");
            return this.dispatch(new Uint8Array(arr));
        },
        _url: function(url) {
            return write("url:" + url.toString(), "utf8");
        },
        _map: function(map) {
            write("map:");
            var arr = Array.from(map);
            return this._array(arr, options.unorderedSets !== false);
        },
        _set: function(set) {
            write("set:");
            var arr = Array.from(set);
            return this._array(arr, options.unorderedSets !== false);
        },
        _file: function(file) {
            write("file:");
            return this.dispatch([
                file.name,
                file.size,
                file.type,
                file.lastModfied
            ]);
        },
        _blob: function() {
            if (options.ignoreUnknown) {
                return write("[blob]");
            }
            throw Error("Hashing Blob objects is currently not supported\n" + "(see https://github.com/puleos/object-hash/issues/26)\n" + 'Use "options.replacer" or "options.ignoreUnknown"\n');
        },
        _domwindow: function() {
            return write("domwindow");
        },
        _bigint: function(number) {
            return write("bigint:" + number.toString());
        },
        /* Node.js standard native objects */ _process: function() {
            return write("process");
        },
        _timer: function() {
            return write("timer");
        },
        _pipe: function() {
            return write("pipe");
        },
        _tcp: function() {
            return write("tcp");
        },
        _udp: function() {
            return write("udp");
        },
        _tty: function() {
            return write("tty");
        },
        _statwatcher: function() {
            return write("statwatcher");
        },
        _securecontext: function() {
            return write("securecontext");
        },
        _connection: function() {
            return write("connection");
        },
        _zlib: function() {
            return write("zlib");
        },
        _context: function() {
            return write("context");
        },
        _nodescript: function() {
            return write("nodescript");
        },
        _httpparser: function() {
            return write("httpparser");
        },
        _dataview: function() {
            return write("dataview");
        },
        _signal: function() {
            return write("signal");
        },
        _fsevent: function() {
            return write("fsevent");
        },
        _tlswrap: function() {
            return write("tlswrap");
        }
    };
}
// Mini-implementation of stream.PassThrough
// We are far from having need for the full implementation, and we can
// make assumptions like "many writes, then only one final read"
// and we can ignore encoding specifics
function PassThrough() {
    return {
        buf: "",
        write: function(b) {
            this.buf += b;
        },
        end: function(b) {
            this.buf += b;
        },
        read: function() {
            return this.buf;
        }
    };
}


/***/ }),

/***/ 79582:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { strict: assert } = __webpack_require__(39491);
const { createHash } = __webpack_require__(6113);
const { format } = __webpack_require__(73837);
const shake256 = __webpack_require__(26460);
let encode;
if (Buffer.isEncoding("base64url")) {
    encode = (input)=>input.toString("base64url");
} else {
    const fromBase64 = (base64)=>base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    encode = (input)=>fromBase64(input.toString("base64"));
}
/** SPECIFICATION
 * Its (_hash) value is the base64url encoding of the left-most half of the hash of the octets of
 * the ASCII representation of the token value, where the hash algorithm used is the hash algorithm
 * used in the alg Header Parameter of the ID Token's JOSE Header. For instance, if the alg is
 * RS256, hash the token value with SHA-256, then take the left-most 128 bits and base64url encode
 * them. The _hash value is a case sensitive string.
 */ /**
 * @name getHash
 * @api private
 *
 * returns the sha length based off the JOSE alg heade value, defaults to sha256
 *
 * @param token {String} token value to generate the hash from
 * @param alg {String} ID Token JOSE header alg value (i.e. RS256, HS384, ES512, PS256)
 * @param [crv] {String} For EdDSA the curve decides what hash algorithm is used. Required for EdDSA
 */ function getHash(alg, crv) {
    switch(alg){
        case "HS256":
        case "RS256":
        case "PS256":
        case "ES256":
        case "ES256K":
            return createHash("sha256");
        case "HS384":
        case "RS384":
        case "PS384":
        case "ES384":
            return createHash("sha384");
        case "HS512":
        case "RS512":
        case "PS512":
        case "ES512":
            return createHash("sha512");
        case "EdDSA":
            switch(crv){
                case "Ed25519":
                    return createHash("sha512");
                case "Ed448":
                    if (!shake256) {
                        throw new TypeError("Ed448 *_hash calculation is not supported in your Node.js runtime version");
                    }
                    return createHash("shake256", {
                        outputLength: 114
                    });
                default:
                    throw new TypeError("unrecognized or invalid EdDSA curve provided");
            }
        default:
            throw new TypeError("unrecognized or invalid JWS algorithm provided");
    }
}
function generate(token, alg, crv) {
    const digest = getHash(alg, crv).update(token).digest();
    return encode(digest.slice(0, digest.length / 2));
}
function validate(names, actual, source, alg, crv) {
    if (typeof names.claim !== "string" || !names.claim) {
        throw new TypeError("names.claim must be a non-empty string");
    }
    if (typeof names.source !== "string" || !names.source) {
        throw new TypeError("names.source must be a non-empty string");
    }
    assert(typeof actual === "string" && actual, `${names.claim} must be a non-empty string`);
    assert(typeof source === "string" && source, `${names.source} must be a non-empty string`);
    let expected;
    let msg;
    try {
        expected = generate(source, alg, crv);
    } catch (err) {
        msg = format("%s could not be validated (%s)", names.claim, err.message);
    }
    msg = msg || format("%s mismatch, expected %s, got: %s", names.claim, expected, actual);
    assert.equal(expected, actual, msg);
}
module.exports = {
    validate,
    generate
};


/***/ }),

/***/ 26460:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const crypto = __webpack_require__(6113);
const [major, minor] = process.version.substring(1).split(".").map((x)=>parseInt(x, 10));
const xofOutputLength = major > 12 || major === 12 && minor >= 8;
const shake256 = xofOutputLength && crypto.getHashes().includes("shake256");
module.exports = shake256;


/***/ }),

/***/ 88273:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { inspect } = __webpack_require__(73837);
const stdhttp = __webpack_require__(13685);
const crypto = __webpack_require__(6113);
const { strict: assert } = __webpack_require__(39491);
const querystring = __webpack_require__(63477);
const url = __webpack_require__(57310);
const jose = __webpack_require__(91017);
const tokenHash = __webpack_require__(79582);
const isKeyObject = __webpack_require__(15484);
const decodeJWT = __webpack_require__(91189);
const base64url = __webpack_require__(86361);
const defaults = __webpack_require__(37767);
const parseWwwAuthenticate = __webpack_require__(55680);
const { assertSigningAlgValuesSupport, assertIssuerConfiguration } = __webpack_require__(62743);
const pick = __webpack_require__(48852);
const isPlainObject = __webpack_require__(32134);
const processResponse = __webpack_require__(27282);
const TokenSet = __webpack_require__(90224);
const { OPError, RPError } = __webpack_require__(28687);
const now = __webpack_require__(75031);
const { random } = __webpack_require__(20356);
const request = __webpack_require__(16010);
const { CLOCK_TOLERANCE } = __webpack_require__(83610);
const { keystores } = __webpack_require__(72145);
const KeyStore = __webpack_require__(24237);
const clone = __webpack_require__(66306);
const { authenticatedPost, resolveResponseType, resolveRedirectUri } = __webpack_require__(61930);
const { queryKeyStore } = __webpack_require__(42921);
const DeviceFlowHandle = __webpack_require__(70320);
const [major, minor] = process.version.slice(1).split(".").map((str)=>parseInt(str, 10));
const rsaPssParams = major >= 17 || major === 16 && minor >= 9;
const retryAttempt = Symbol();
const skipNonceCheck = Symbol();
const skipMaxAgeCheck = Symbol();
function pickCb(input) {
    return pick(input, "access_token", "code", "error_description", "error_uri", "error", "expires_in", "id_token", "iss", "response", "session_state", "state", "token_type");
}
function authorizationHeaderValue(token, tokenType = "Bearer") {
    return `${tokenType} ${token}`;
}
function verifyPresence(payload, jwt, prop) {
    if (payload[prop] === undefined) {
        throw new RPError({
            message: `missing required JWT property ${prop}`,
            jwt
        });
    }
}
function authorizationParams(params) {
    const authParams = {
        client_id: this.client_id,
        scope: "openid",
        response_type: resolveResponseType.call(this),
        redirect_uri: resolveRedirectUri.call(this),
        ...params
    };
    Object.entries(authParams).forEach(([key, value])=>{
        if (value === null || value === undefined) {
            delete authParams[key];
        } else if (key === "claims" && typeof value === "object") {
            authParams[key] = JSON.stringify(value);
        } else if (key === "resource" && Array.isArray(value)) {
            authParams[key] = value;
        } else if (typeof value !== "string") {
            authParams[key] = String(value);
        }
    });
    return authParams;
}
function getKeystore(jwks) {
    if (!isPlainObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some((k)=>!isPlainObject(k) || !("kty" in k))) {
        throw new TypeError("jwks must be a JSON Web Key Set formatted object");
    }
    return KeyStore.fromJWKS(jwks, {
        onlyPrivate: true
    });
}
// if an OP doesnt support client_secret_basic but supports client_secret_post, use it instead
// this is in place to take care of most common pitfalls when first using discovered Issuers without
// the support for default values defined by Discovery 1.0
function checkBasicSupport(client, properties) {
    try {
        const supported = client.issuer.token_endpoint_auth_methods_supported;
        if (!supported.includes(properties.token_endpoint_auth_method)) {
            if (supported.includes("client_secret_post")) {
                properties.token_endpoint_auth_method = "client_secret_post";
            }
        }
    } catch (err) {}
}
function handleCommonMistakes(client, metadata, properties) {
    if (!metadata.token_endpoint_auth_method) {
        // if no explicit value was provided
        checkBasicSupport(client, properties);
    }
    // :fp: c'mon people... RTFM
    if (metadata.redirect_uri) {
        if (metadata.redirect_uris) {
            throw new TypeError("provide a redirect_uri or redirect_uris, not both");
        }
        properties.redirect_uris = [
            metadata.redirect_uri
        ];
        delete properties.redirect_uri;
    }
    if (metadata.response_type) {
        if (metadata.response_types) {
            throw new TypeError("provide a response_type or response_types, not both");
        }
        properties.response_types = [
            metadata.response_type
        ];
        delete properties.response_type;
    }
}
function getDefaultsForEndpoint(endpoint, issuer, properties) {
    if (!issuer[`${endpoint}_endpoint`]) return;
    const tokenEndpointAuthMethod = properties.token_endpoint_auth_method;
    const tokenEndpointAuthSigningAlg = properties.token_endpoint_auth_signing_alg;
    const eam = `${endpoint}_endpoint_auth_method`;
    const easa = `${endpoint}_endpoint_auth_signing_alg`;
    if (properties[eam] === undefined && properties[easa] === undefined) {
        if (tokenEndpointAuthMethod !== undefined) {
            properties[eam] = tokenEndpointAuthMethod;
        }
        if (tokenEndpointAuthSigningAlg !== undefined) {
            properties[easa] = tokenEndpointAuthSigningAlg;
        }
    }
}
class BaseClient {
    #metadata;
    #issuer;
    #aadIssValidation;
    #additionalAuthorizedParties;
    constructor(issuer, aadIssValidation, metadata = {}, jwks, options){
        this.#metadata = new Map();
        this.#issuer = issuer;
        this.#aadIssValidation = aadIssValidation;
        if (typeof metadata.client_id !== "string" || !metadata.client_id) {
            throw new TypeError("client_id is required");
        }
        const properties = {
            grant_types: [
                "authorization_code"
            ],
            id_token_signed_response_alg: "RS256",
            authorization_signed_response_alg: "RS256",
            response_types: [
                "code"
            ],
            token_endpoint_auth_method: "client_secret_basic",
            ...this.fapi() ? {
                grant_types: [
                    "authorization_code",
                    "implicit"
                ],
                id_token_signed_response_alg: "PS256",
                authorization_signed_response_alg: "PS256",
                response_types: [
                    "code id_token"
                ],
                tls_client_certificate_bound_access_tokens: true,
                token_endpoint_auth_method: undefined
            } : undefined,
            ...metadata
        };
        if (this.fapi()) {
            switch(properties.token_endpoint_auth_method){
                case "self_signed_tls_client_auth":
                case "tls_client_auth":
                    break;
                case "private_key_jwt":
                    if (!jwks) {
                        throw new TypeError("jwks is required");
                    }
                    break;
                case undefined:
                    throw new TypeError("token_endpoint_auth_method is required");
                default:
                    throw new TypeError("invalid or unsupported token_endpoint_auth_method");
            }
        }
        handleCommonMistakes(this, metadata, properties);
        assertSigningAlgValuesSupport("token", this.issuer, properties);
        [
            "introspection",
            "revocation"
        ].forEach((endpoint)=>{
            getDefaultsForEndpoint(endpoint, this.issuer, properties);
            assertSigningAlgValuesSupport(endpoint, this.issuer, properties);
        });
        Object.entries(properties).forEach(([key, value])=>{
            this.#metadata.set(key, value);
            if (!this[key]) {
                Object.defineProperty(this, key, {
                    get () {
                        return this.#metadata.get(key);
                    },
                    enumerable: true
                });
            }
        });
        if (jwks !== undefined) {
            const keystore = getKeystore.call(this, jwks);
            keystores.set(this, keystore);
        }
        if (options != null && options.additionalAuthorizedParties) {
            this.#additionalAuthorizedParties = clone(options.additionalAuthorizedParties);
        }
        this[CLOCK_TOLERANCE] = 0;
    }
    authorizationUrl(params = {}) {
        if (!isPlainObject(params)) {
            throw new TypeError("params must be a plain object");
        }
        assertIssuerConfiguration(this.issuer, "authorization_endpoint");
        const target = url.parse(this.issuer.authorization_endpoint, true);
        target.search = null;
        target.query = {
            ...target.query,
            ...authorizationParams.call(this, params)
        };
        return url.format(target);
    }
    authorizationPost(params = {}) {
        if (!isPlainObject(params)) {
            throw new TypeError("params must be a plain object");
        }
        const inputs = authorizationParams.call(this, params);
        const formInputs = Object.keys(inputs).map((name)=>`<input type="hidden" name="${name}" value="${inputs[name]}"/>`).join("\n");
        return `<!DOCTYPE html>
<head>
<title>Requesting Authorization</title>
</head>
<body onload="javascript:document.forms[0].submit()">
<form method="post" action="${this.issuer.authorization_endpoint}">
  ${formInputs}
</form>
</body>
</html>`;
    }
    endSessionUrl(params = {}) {
        assertIssuerConfiguration(this.issuer, "end_session_endpoint");
        const { 0: postLogout, length } = this.post_logout_redirect_uris || [];
        const { post_logout_redirect_uri = length === 1 ? postLogout : undefined } = params;
        let id_token_hint;
        ({ id_token_hint, ...params } = params);
        if (id_token_hint instanceof TokenSet) {
            if (!id_token_hint.id_token) {
                throw new TypeError("id_token not present in TokenSet");
            }
            id_token_hint = id_token_hint.id_token;
        }
        const target = url.parse(this.issuer.end_session_endpoint, true);
        target.search = null;
        defaults(target.query, params, {
            post_logout_redirect_uri,
            client_id: this.client_id
        }, {
            id_token_hint
        });
        Object.entries(target.query).forEach(([key, value])=>{
            if (value === null || value === undefined) {
                delete target.query[key];
            }
        });
        return url.format(target);
    }
    callbackParams(input) {
        const isIncomingMessage = input instanceof stdhttp.IncomingMessage || input && input.method && input.url;
        const isString = typeof input === "string";
        if (!isString && !isIncomingMessage) {
            throw new TypeError("#callbackParams only accepts string urls, http.IncomingMessage or a lookalike");
        }
        if (isIncomingMessage) {
            switch(input.method){
                case "GET":
                    return pickCb(url.parse(input.url, true).query);
                case "POST":
                    if (input.body === undefined) {
                        throw new TypeError("incoming message body missing, include a body parser prior to this method call");
                    }
                    switch(typeof input.body){
                        case "object":
                        case "string":
                            if (Buffer.isBuffer(input.body)) {
                                return pickCb(querystring.parse(input.body.toString("utf-8")));
                            }
                            if (typeof input.body === "string") {
                                return pickCb(querystring.parse(input.body));
                            }
                            return pickCb(input.body);
                        default:
                            throw new TypeError("invalid IncomingMessage body object");
                    }
                default:
                    throw new TypeError("invalid IncomingMessage method");
            }
        } else {
            return pickCb(url.parse(input, true).query);
        }
    }
    async callback(redirectUri, parameters, checks = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {
        let params = pickCb(parameters);
        if (checks.jarm && !("response" in parameters)) {
            throw new RPError({
                message: "expected a JARM response",
                checks,
                params
            });
        } else if ("response" in parameters) {
            const decrypted = await this.decryptJARM(params.response);
            params = await this.validateJARM(decrypted);
        }
        if (this.default_max_age && !checks.max_age) {
            checks.max_age = this.default_max_age;
        }
        if (params.state && !checks.state) {
            throw new TypeError("checks.state argument is missing");
        }
        if (!params.state && checks.state) {
            throw new RPError({
                message: "state missing from the response",
                checks,
                params
            });
        }
        if (checks.state !== params.state) {
            throw new RPError({
                printf: [
                    "state mismatch, expected %s, got: %s",
                    checks.state,
                    params.state
                ],
                checks,
                params
            });
        }
        if ("iss" in params) {
            assertIssuerConfiguration(this.issuer, "issuer");
            if (params.iss !== this.issuer.issuer) {
                throw new RPError({
                    printf: [
                        "iss mismatch, expected %s, got: %s",
                        this.issuer.issuer,
                        params.iss
                    ],
                    params
                });
            }
        } else if (this.issuer.authorization_response_iss_parameter_supported && !("id_token" in params) && !("response" in parameters)) {
            throw new RPError({
                message: "iss missing from the response",
                params
            });
        }
        if (params.error) {
            throw new OPError(params);
        }
        const RESPONSE_TYPE_REQUIRED_PARAMS = {
            code: [
                "code"
            ],
            id_token: [
                "id_token"
            ],
            token: [
                "access_token",
                "token_type"
            ]
        };
        if (checks.response_type) {
            for (const type of checks.response_type.split(" ")){
                if (type === "none") {
                    if (params.code || params.id_token || params.access_token) {
                        throw new RPError({
                            message: 'unexpected params encountered for "none" response',
                            checks,
                            params
                        });
                    }
                } else {
                    for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]){
                        if (!params[param]) {
                            throw new RPError({
                                message: `${param} missing from response`,
                                checks,
                                params
                            });
                        }
                    }
                }
            }
        }
        if (params.id_token) {
            const tokenset = new TokenSet(params);
            await this.decryptIdToken(tokenset);
            await this.validateIdToken(tokenset, checks.nonce, "authorization", checks.max_age, checks.state);
            if (!params.code) {
                return tokenset;
            }
        }
        if (params.code) {
            const tokenset = await this.grant({
                ...exchangeBody,
                grant_type: "authorization_code",
                code: params.code,
                redirect_uri: redirectUri,
                code_verifier: checks.code_verifier
            }, {
                clientAssertionPayload,
                DPoP
            });
            await this.decryptIdToken(tokenset);
            await this.validateIdToken(tokenset, checks.nonce, "token", checks.max_age);
            if (params.session_state) {
                tokenset.session_state = params.session_state;
            }
            return tokenset;
        }
        return new TokenSet(params);
    }
    async oauthCallback(redirectUri, parameters, checks = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {
        let params = pickCb(parameters);
        if (checks.jarm && !("response" in parameters)) {
            throw new RPError({
                message: "expected a JARM response",
                checks,
                params
            });
        } else if ("response" in parameters) {
            const decrypted = await this.decryptJARM(params.response);
            params = await this.validateJARM(decrypted);
        }
        if (params.state && !checks.state) {
            throw new TypeError("checks.state argument is missing");
        }
        if (!params.state && checks.state) {
            throw new RPError({
                message: "state missing from the response",
                checks,
                params
            });
        }
        if (checks.state !== params.state) {
            throw new RPError({
                printf: [
                    "state mismatch, expected %s, got: %s",
                    checks.state,
                    params.state
                ],
                checks,
                params
            });
        }
        if ("iss" in params) {
            assertIssuerConfiguration(this.issuer, "issuer");
            if (params.iss !== this.issuer.issuer) {
                throw new RPError({
                    printf: [
                        "iss mismatch, expected %s, got: %s",
                        this.issuer.issuer,
                        params.iss
                    ],
                    params
                });
            }
        } else if (this.issuer.authorization_response_iss_parameter_supported && !("id_token" in params) && !("response" in parameters)) {
            throw new RPError({
                message: "iss missing from the response",
                params
            });
        }
        if (params.error) {
            throw new OPError(params);
        }
        if (typeof params.id_token === "string" && params.id_token.length) {
            throw new RPError({
                message: "id_token detected in the response, you must use client.callback() instead of client.oauthCallback()",
                params
            });
        }
        delete params.id_token;
        const RESPONSE_TYPE_REQUIRED_PARAMS = {
            code: [
                "code"
            ],
            token: [
                "access_token",
                "token_type"
            ]
        };
        if (checks.response_type) {
            for (const type of checks.response_type.split(" ")){
                if (type === "none") {
                    if (params.code || params.id_token || params.access_token) {
                        throw new RPError({
                            message: 'unexpected params encountered for "none" response',
                            checks,
                            params
                        });
                    }
                }
                if (RESPONSE_TYPE_REQUIRED_PARAMS[type]) {
                    for (const param of RESPONSE_TYPE_REQUIRED_PARAMS[type]){
                        if (!params[param]) {
                            throw new RPError({
                                message: `${param} missing from response`,
                                checks,
                                params
                            });
                        }
                    }
                }
            }
        }
        if (params.code) {
            const tokenset = await this.grant({
                ...exchangeBody,
                grant_type: "authorization_code",
                code: params.code,
                redirect_uri: redirectUri,
                code_verifier: checks.code_verifier
            }, {
                clientAssertionPayload,
                DPoP
            });
            if (typeof tokenset.id_token === "string" && tokenset.id_token.length) {
                throw new RPError({
                    message: "id_token detected in the response, you must use client.callback() instead of client.oauthCallback()",
                    params
                });
            }
            delete tokenset.id_token;
            return tokenset;
        }
        return new TokenSet(params);
    }
    async decryptIdToken(token) {
        if (!this.id_token_encrypted_response_alg) {
            return token;
        }
        let idToken = token;
        if (idToken instanceof TokenSet) {
            if (!idToken.id_token) {
                throw new TypeError("id_token not present in TokenSet");
            }
            idToken = idToken.id_token;
        }
        const expectedAlg = this.id_token_encrypted_response_alg;
        const expectedEnc = this.id_token_encrypted_response_enc;
        const result = await this.decryptJWE(idToken, expectedAlg, expectedEnc);
        if (token instanceof TokenSet) {
            token.id_token = result;
            return token;
        }
        return result;
    }
    async validateJWTUserinfo(body) {
        const expectedAlg = this.userinfo_signed_response_alg;
        return this.validateJWT(body, expectedAlg, []);
    }
    async decryptJARM(response) {
        if (!this.authorization_encrypted_response_alg) {
            return response;
        }
        const expectedAlg = this.authorization_encrypted_response_alg;
        const expectedEnc = this.authorization_encrypted_response_enc;
        return this.decryptJWE(response, expectedAlg, expectedEnc);
    }
    async decryptJWTUserinfo(body) {
        if (!this.userinfo_encrypted_response_alg) {
            return body;
        }
        const expectedAlg = this.userinfo_encrypted_response_alg;
        const expectedEnc = this.userinfo_encrypted_response_enc;
        return this.decryptJWE(body, expectedAlg, expectedEnc);
    }
    async decryptJWE(jwe, expectedAlg, expectedEnc = "A128CBC-HS256") {
        const header = JSON.parse(base64url.decode(jwe.split(".")[0]));
        if (header.alg !== expectedAlg) {
            throw new RPError({
                printf: [
                    "unexpected JWE alg received, expected %s, got: %s",
                    expectedAlg,
                    header.alg
                ],
                jwt: jwe
            });
        }
        if (header.enc !== expectedEnc) {
            throw new RPError({
                printf: [
                    "unexpected JWE enc received, expected %s, got: %s",
                    expectedEnc,
                    header.enc
                ],
                jwt: jwe
            });
        }
        const getPlaintext = (result)=>new TextDecoder().decode(result.plaintext);
        let plaintext;
        if (expectedAlg.match(/^(?:RSA|ECDH)/)) {
            const keystore = await keystores.get(this);
            for (const { keyObject: key } of keystore.all({
                ...jose.decodeProtectedHeader(jwe),
                use: "enc"
            })){
                plaintext = await jose.compactDecrypt(jwe, key).then(getPlaintext, ()=>{});
                if (plaintext) break;
            }
        } else {
            plaintext = await jose.compactDecrypt(jwe, this.secretForAlg(expectedAlg === "dir" ? expectedEnc : expectedAlg)).then(getPlaintext, ()=>{});
        }
        if (!plaintext) {
            throw new RPError({
                message: "failed to decrypt JWE",
                jwt: jwe
            });
        }
        return plaintext;
    }
    async validateIdToken(tokenSet, nonce, returnedBy, maxAge, state) {
        let idToken = tokenSet;
        const expectedAlg = this.id_token_signed_response_alg;
        const isTokenSet = idToken instanceof TokenSet;
        if (isTokenSet) {
            if (!idToken.id_token) {
                throw new TypeError("id_token not present in TokenSet");
            }
            idToken = idToken.id_token;
        }
        idToken = String(idToken);
        const timestamp = now();
        const { protected: header, payload, key } = await this.validateJWT(idToken, expectedAlg);
        if (typeof maxAge === "number" || maxAge !== skipMaxAgeCheck && this.require_auth_time) {
            if (!payload.auth_time) {
                throw new RPError({
                    message: "missing required JWT property auth_time",
                    jwt: idToken
                });
            }
            if (typeof payload.auth_time !== "number") {
                throw new RPError({
                    message: "JWT auth_time claim must be a JSON numeric value",
                    jwt: idToken
                });
            }
        }
        if (typeof maxAge === "number" && payload.auth_time + maxAge < timestamp - this[CLOCK_TOLERANCE]) {
            throw new RPError({
                printf: [
                    "too much time has elapsed since the last End-User authentication, max_age %i, auth_time: %i, now %i",
                    maxAge,
                    payload.auth_time,
                    timestamp - this[CLOCK_TOLERANCE]
                ],
                now: timestamp,
                tolerance: this[CLOCK_TOLERANCE],
                auth_time: payload.auth_time,
                jwt: idToken
            });
        }
        if (nonce !== skipNonceCheck && (payload.nonce || nonce !== undefined) && payload.nonce !== nonce) {
            throw new RPError({
                printf: [
                    "nonce mismatch, expected %s, got: %s",
                    nonce,
                    payload.nonce
                ],
                jwt: idToken
            });
        }
        if (returnedBy === "authorization") {
            if (!payload.at_hash && tokenSet.access_token) {
                throw new RPError({
                    message: "missing required property at_hash",
                    jwt: idToken
                });
            }
            if (!payload.c_hash && tokenSet.code) {
                throw new RPError({
                    message: "missing required property c_hash",
                    jwt: idToken
                });
            }
            if (this.fapi()) {
                if (!payload.s_hash && (tokenSet.state || state)) {
                    throw new RPError({
                        message: "missing required property s_hash",
                        jwt: idToken
                    });
                }
            }
            if (payload.s_hash) {
                if (!state) {
                    throw new TypeError('cannot verify s_hash, "checks.state" property not provided');
                }
                try {
                    tokenHash.validate({
                        claim: "s_hash",
                        source: "state"
                    }, payload.s_hash, state, header.alg, key.jwk && key.jwk.crv);
                } catch (err) {
                    throw new RPError({
                        message: err.message,
                        jwt: idToken
                    });
                }
            }
        }
        if (this.fapi() && payload.iat < timestamp - 3600) {
            throw new RPError({
                printf: [
                    "JWT issued too far in the past, now %i, iat %i",
                    timestamp,
                    payload.iat
                ],
                now: timestamp,
                tolerance: this[CLOCK_TOLERANCE],
                iat: payload.iat,
                jwt: idToken
            });
        }
        if (tokenSet.access_token && payload.at_hash !== undefined) {
            try {
                tokenHash.validate({
                    claim: "at_hash",
                    source: "access_token"
                }, payload.at_hash, tokenSet.access_token, header.alg, key.jwk && key.jwk.crv);
            } catch (err) {
                throw new RPError({
                    message: err.message,
                    jwt: idToken
                });
            }
        }
        if (tokenSet.code && payload.c_hash !== undefined) {
            try {
                tokenHash.validate({
                    claim: "c_hash",
                    source: "code"
                }, payload.c_hash, tokenSet.code, header.alg, key.jwk && key.jwk.crv);
            } catch (err) {
                throw new RPError({
                    message: err.message,
                    jwt: idToken
                });
            }
        }
        return tokenSet;
    }
    async validateJWT(jwt, expectedAlg, required = [
        "iss",
        "sub",
        "aud",
        "exp",
        "iat"
    ]) {
        const isSelfIssued = this.issuer.issuer === "https://self-issued.me";
        const timestamp = now();
        let header;
        let payload;
        try {
            ({ header, payload } = decodeJWT(jwt, {
                complete: true
            }));
        } catch (err) {
            throw new RPError({
                printf: [
                    "failed to decode JWT (%s: %s)",
                    err.name,
                    err.message
                ],
                jwt
            });
        }
        if (header.alg !== expectedAlg) {
            throw new RPError({
                printf: [
                    "unexpected JWT alg received, expected %s, got: %s",
                    expectedAlg,
                    header.alg
                ],
                jwt
            });
        }
        if (isSelfIssued) {
            required = [
                ...required,
                "sub_jwk"
            ];
        }
        required.forEach(verifyPresence.bind(undefined, payload, jwt));
        if (payload.iss !== undefined) {
            let expectedIss = this.issuer.issuer;
            if (this.#aadIssValidation) {
                expectedIss = this.issuer.issuer.replace("{tenantid}", payload.tid);
            }
            if (payload.iss !== expectedIss) {
                throw new RPError({
                    printf: [
                        "unexpected iss value, expected %s, got: %s",
                        expectedIss,
                        payload.iss
                    ],
                    jwt
                });
            }
        }
        if (payload.iat !== undefined) {
            if (typeof payload.iat !== "number") {
                throw new RPError({
                    message: "JWT iat claim must be a JSON numeric value",
                    jwt
                });
            }
        }
        if (payload.nbf !== undefined) {
            if (typeof payload.nbf !== "number") {
                throw new RPError({
                    message: "JWT nbf claim must be a JSON numeric value",
                    jwt
                });
            }
            if (payload.nbf > timestamp + this[CLOCK_TOLERANCE]) {
                throw new RPError({
                    printf: [
                        "JWT not active yet, now %i, nbf %i",
                        timestamp + this[CLOCK_TOLERANCE],
                        payload.nbf
                    ],
                    now: timestamp,
                    tolerance: this[CLOCK_TOLERANCE],
                    nbf: payload.nbf,
                    jwt
                });
            }
        }
        if (payload.exp !== undefined) {
            if (typeof payload.exp !== "number") {
                throw new RPError({
                    message: "JWT exp claim must be a JSON numeric value",
                    jwt
                });
            }
            if (timestamp - this[CLOCK_TOLERANCE] >= payload.exp) {
                throw new RPError({
                    printf: [
                        "JWT expired, now %i, exp %i",
                        timestamp - this[CLOCK_TOLERANCE],
                        payload.exp
                    ],
                    now: timestamp,
                    tolerance: this[CLOCK_TOLERANCE],
                    exp: payload.exp,
                    jwt
                });
            }
        }
        if (payload.aud !== undefined) {
            if (Array.isArray(payload.aud)) {
                if (payload.aud.length > 1 && !payload.azp) {
                    throw new RPError({
                        message: "missing required JWT property azp",
                        jwt
                    });
                }
                if (!payload.aud.includes(this.client_id)) {
                    throw new RPError({
                        printf: [
                            "aud is missing the client_id, expected %s to be included in %j",
                            this.client_id,
                            payload.aud
                        ],
                        jwt
                    });
                }
            } else if (payload.aud !== this.client_id) {
                throw new RPError({
                    printf: [
                        "aud mismatch, expected %s, got: %s",
                        this.client_id,
                        payload.aud
                    ],
                    jwt
                });
            }
        }
        if (payload.azp !== undefined) {
            let additionalAuthorizedParties = this.#additionalAuthorizedParties;
            if (typeof additionalAuthorizedParties === "string") {
                additionalAuthorizedParties = [
                    this.client_id,
                    additionalAuthorizedParties
                ];
            } else if (Array.isArray(additionalAuthorizedParties)) {
                additionalAuthorizedParties = [
                    this.client_id,
                    ...additionalAuthorizedParties
                ];
            } else {
                additionalAuthorizedParties = [
                    this.client_id
                ];
            }
            if (!additionalAuthorizedParties.includes(payload.azp)) {
                throw new RPError({
                    printf: [
                        "azp mismatch, got: %s",
                        payload.azp
                    ],
                    jwt
                });
            }
        }
        let keys;
        if (isSelfIssued) {
            try {
                assert(isPlainObject(payload.sub_jwk));
                const key = await jose.importJWK(payload.sub_jwk, header.alg);
                assert.equal(key.type, "public");
                keys = [
                    {
                        keyObject: key
                    }
                ];
            } catch (err) {
                throw new RPError({
                    message: "failed to use sub_jwk claim as an asymmetric JSON Web Key",
                    jwt
                });
            }
            if (await jose.calculateJwkThumbprint(payload.sub_jwk) !== payload.sub) {
                throw new RPError({
                    message: "failed to match the subject with sub_jwk",
                    jwt
                });
            }
        } else if (header.alg.startsWith("HS")) {
            keys = [
                this.secretForAlg(header.alg)
            ];
        } else if (header.alg !== "none") {
            keys = await queryKeyStore.call(this.issuer, {
                ...header,
                use: "sig"
            });
        }
        if (!keys && header.alg === "none") {
            return {
                protected: header,
                payload
            };
        }
        for (const key of keys){
            const verified = await jose.compactVerify(jwt, key instanceof Uint8Array ? key : key.keyObject).catch(()=>{});
            if (verified) {
                return {
                    payload,
                    protected: verified.protectedHeader,
                    key
                };
            }
        }
        throw new RPError({
            message: "failed to validate JWT signature",
            jwt
        });
    }
    async refresh(refreshToken, { exchangeBody, clientAssertionPayload, DPoP } = {}) {
        let token = refreshToken;
        if (token instanceof TokenSet) {
            if (!token.refresh_token) {
                throw new TypeError("refresh_token not present in TokenSet");
            }
            token = token.refresh_token;
        }
        const tokenset = await this.grant({
            ...exchangeBody,
            grant_type: "refresh_token",
            refresh_token: String(token)
        }, {
            clientAssertionPayload,
            DPoP
        });
        if (tokenset.id_token) {
            await this.decryptIdToken(tokenset);
            await this.validateIdToken(tokenset, skipNonceCheck, "token", skipMaxAgeCheck);
            if (refreshToken instanceof TokenSet && refreshToken.id_token) {
                const expectedSub = refreshToken.claims().sub;
                const actualSub = tokenset.claims().sub;
                if (actualSub !== expectedSub) {
                    throw new RPError({
                        printf: [
                            "sub mismatch, expected %s, got: %s",
                            expectedSub,
                            actualSub
                        ],
                        jwt: tokenset.id_token
                    });
                }
            }
        }
        return tokenset;
    }
    async requestResource(resourceUrl, accessToken, { method, headers, body, DPoP, tokenType = DPoP ? "DPoP" : accessToken instanceof TokenSet ? accessToken.token_type : "Bearer" } = {}, retry) {
        if (accessToken instanceof TokenSet) {
            if (!accessToken.access_token) {
                throw new TypeError("access_token not present in TokenSet");
            }
            accessToken = accessToken.access_token;
        }
        if (!accessToken) {
            throw new TypeError("no access token provided");
        } else if (typeof accessToken !== "string") {
            throw new TypeError("invalid access token provided");
        }
        const requestOpts = {
            headers: {
                Authorization: authorizationHeaderValue(accessToken, tokenType),
                ...headers
            },
            body
        };
        const mTLS = !!this.tls_client_certificate_bound_access_tokens;
        const response = await request.call(this, {
            ...requestOpts,
            responseType: "buffer",
            method,
            url: resourceUrl
        }, {
            accessToken,
            mTLS,
            DPoP
        });
        const wwwAuthenticate = response.headers["www-authenticate"];
        if (retry !== retryAttempt && wwwAuthenticate && wwwAuthenticate.toLowerCase().startsWith("dpop ") && parseWwwAuthenticate(wwwAuthenticate).error === "use_dpop_nonce") {
            return this.requestResource(resourceUrl, accessToken, {
                method,
                headers,
                body,
                DPoP,
                tokenType
            });
        }
        return response;
    }
    async userinfo(accessToken, { method = "GET", via = "header", tokenType, params, DPoP } = {}) {
        assertIssuerConfiguration(this.issuer, "userinfo_endpoint");
        const options = {
            tokenType,
            method: String(method).toUpperCase(),
            DPoP
        };
        if (options.method !== "GET" && options.method !== "POST") {
            throw new TypeError("#userinfo() method can only be POST or a GET");
        }
        if (via === "body" && options.method !== "POST") {
            throw new TypeError("can only send body on POST");
        }
        const jwt = !!(this.userinfo_signed_response_alg || this.userinfo_encrypted_response_alg);
        if (jwt) {
            options.headers = {
                Accept: "application/jwt"
            };
        } else {
            options.headers = {
                Accept: "application/json"
            };
        }
        const mTLS = !!this.tls_client_certificate_bound_access_tokens;
        let targetUrl;
        if (mTLS && this.issuer.mtls_endpoint_aliases) {
            targetUrl = this.issuer.mtls_endpoint_aliases.userinfo_endpoint;
        }
        targetUrl = new url.URL(targetUrl || this.issuer.userinfo_endpoint);
        if (via === "body") {
            options.headers.Authorization = undefined;
            options.headers["Content-Type"] = "application/x-www-form-urlencoded";
            options.body = new url.URLSearchParams();
            options.body.append("access_token", accessToken instanceof TokenSet ? accessToken.access_token : accessToken);
        }
        // handle additional parameters, GET via querystring, POST via urlencoded body
        if (params) {
            if (options.method === "GET") {
                Object.entries(params).forEach(([key, value])=>{
                    targetUrl.searchParams.append(key, value);
                });
            } else if (options.body) {
                // POST && via body
                Object.entries(params).forEach(([key, value])=>{
                    options.body.append(key, value);
                });
            } else {
                // POST && via header
                options.body = new url.URLSearchParams();
                options.headers["Content-Type"] = "application/x-www-form-urlencoded";
                Object.entries(params).forEach(([key, value])=>{
                    options.body.append(key, value);
                });
            }
        }
        if (options.body) {
            options.body = options.body.toString();
        }
        const response = await this.requestResource(targetUrl, accessToken, options);
        let parsed = processResponse(response, {
            bearer: true
        });
        if (jwt) {
            if (!/^application\/jwt/.test(response.headers["content-type"])) {
                throw new RPError({
                    message: "expected application/jwt response from the userinfo_endpoint",
                    response
                });
            }
            const body = response.body.toString();
            const userinfo = await this.decryptJWTUserinfo(body);
            if (!this.userinfo_signed_response_alg) {
                try {
                    parsed = JSON.parse(userinfo);
                    assert(isPlainObject(parsed));
                } catch (err) {
                    throw new RPError({
                        message: "failed to parse userinfo JWE payload as JSON",
                        jwt: userinfo
                    });
                }
            } else {
                ({ payload: parsed } = await this.validateJWTUserinfo(userinfo));
            }
        } else {
            try {
                parsed = JSON.parse(response.body);
            } catch (err) {
                Object.defineProperty(err, "response", {
                    value: response
                });
                throw err;
            }
        }
        if (accessToken instanceof TokenSet && accessToken.id_token) {
            const expectedSub = accessToken.claims().sub;
            if (parsed.sub !== expectedSub) {
                throw new RPError({
                    printf: [
                        "userinfo sub mismatch, expected %s, got: %s",
                        expectedSub,
                        parsed.sub
                    ],
                    body: parsed,
                    jwt: accessToken.id_token
                });
            }
        }
        return parsed;
    }
    encryptionSecret(len) {
        const hash = len <= 256 ? "sha256" : len <= 384 ? "sha384" : len <= 512 ? "sha512" : false;
        if (!hash) {
            throw new Error("unsupported symmetric encryption key derivation");
        }
        return crypto.createHash(hash).update(this.client_secret).digest().slice(0, len / 8);
    }
    secretForAlg(alg) {
        if (!this.client_secret) {
            throw new TypeError("client_secret is required");
        }
        if (/^A(\d{3})(?:GCM)?KW$/.test(alg)) {
            return this.encryptionSecret(parseInt(RegExp.$1, 10));
        }
        if (/^A(\d{3})(?:GCM|CBC-HS(\d{3}))$/.test(alg)) {
            return this.encryptionSecret(parseInt(RegExp.$2 || RegExp.$1, 10));
        }
        return new TextEncoder().encode(this.client_secret);
    }
    async grant(body, { clientAssertionPayload, DPoP } = {}, retry) {
        assertIssuerConfiguration(this.issuer, "token_endpoint");
        const response = await authenticatedPost.call(this, "token", {
            form: body,
            responseType: "json"
        }, {
            clientAssertionPayload,
            DPoP
        });
        let responseBody;
        try {
            responseBody = processResponse(response);
        } catch (err) {
            if (retry !== retryAttempt && err instanceof OPError && err.error === "use_dpop_nonce") {
                return this.grant(body, {
                    clientAssertionPayload,
                    DPoP
                }, retryAttempt);
            }
            throw err;
        }
        return new TokenSet(responseBody);
    }
    async deviceAuthorization(params = {}, { exchangeBody, clientAssertionPayload, DPoP } = {}) {
        assertIssuerConfiguration(this.issuer, "device_authorization_endpoint");
        assertIssuerConfiguration(this.issuer, "token_endpoint");
        const body = authorizationParams.call(this, {
            client_id: this.client_id,
            redirect_uri: null,
            response_type: null,
            ...params
        });
        const response = await authenticatedPost.call(this, "device_authorization", {
            responseType: "json",
            form: body
        }, {
            clientAssertionPayload,
            endpointAuthMethod: "token"
        });
        const responseBody = processResponse(response);
        return new DeviceFlowHandle({
            client: this,
            exchangeBody,
            clientAssertionPayload,
            response: responseBody,
            maxAge: params.max_age,
            DPoP
        });
    }
    async revoke(token, hint, { revokeBody, clientAssertionPayload } = {}) {
        assertIssuerConfiguration(this.issuer, "revocation_endpoint");
        if (hint !== undefined && typeof hint !== "string") {
            throw new TypeError("hint must be a string");
        }
        const form = {
            ...revokeBody,
            token
        };
        if (hint) {
            form.token_type_hint = hint;
        }
        const response = await authenticatedPost.call(this, "revocation", {
            form
        }, {
            clientAssertionPayload
        });
        processResponse(response, {
            body: false
        });
    }
    async introspect(token, hint, { introspectBody, clientAssertionPayload } = {}) {
        assertIssuerConfiguration(this.issuer, "introspection_endpoint");
        if (hint !== undefined && typeof hint !== "string") {
            throw new TypeError("hint must be a string");
        }
        const form = {
            ...introspectBody,
            token
        };
        if (hint) {
            form.token_type_hint = hint;
        }
        const response = await authenticatedPost.call(this, "introspection", {
            form,
            responseType: "json"
        }, {
            clientAssertionPayload
        });
        const responseBody = processResponse(response);
        return responseBody;
    }
    static async register(metadata, options = {}) {
        const { initialAccessToken, jwks, ...clientOptions } = options;
        assertIssuerConfiguration(this.issuer, "registration_endpoint");
        if (jwks !== undefined && !(metadata.jwks || metadata.jwks_uri)) {
            const keystore = await getKeystore.call(this, jwks);
            metadata.jwks = keystore.toJWKS();
        }
        const response = await request.call(this, {
            headers: {
                Accept: "application/json",
                ...initialAccessToken ? {
                    Authorization: authorizationHeaderValue(initialAccessToken)
                } : undefined
            },
            responseType: "json",
            json: metadata,
            url: this.issuer.registration_endpoint,
            method: "POST"
        });
        const responseBody = processResponse(response, {
            statusCode: 201,
            bearer: true
        });
        return new this(responseBody, jwks, clientOptions);
    }
    get metadata() {
        return clone(Object.fromEntries(this.#metadata.entries()));
    }
    static async fromUri(registrationClientUri, registrationAccessToken, jwks, clientOptions) {
        const response = await request.call(this, {
            method: "GET",
            url: registrationClientUri,
            responseType: "json",
            headers: {
                Authorization: authorizationHeaderValue(registrationAccessToken),
                Accept: "application/json"
            }
        });
        const responseBody = processResponse(response, {
            bearer: true
        });
        return new this(responseBody, jwks, clientOptions);
    }
    async requestObject(requestObject = {}, { sign: signingAlgorithm = this.request_object_signing_alg || "none", encrypt: { alg: eKeyManagement = this.request_object_encryption_alg, enc: eContentEncryption = this.request_object_encryption_enc || "A128CBC-HS256" } = {} } = {}) {
        if (!isPlainObject(requestObject)) {
            throw new TypeError("requestObject must be a plain object");
        }
        let signed;
        let key;
        const unix = now();
        const header = {
            alg: signingAlgorithm,
            typ: "oauth-authz-req+jwt"
        };
        const payload = JSON.stringify(defaults({}, requestObject, {
            iss: this.client_id,
            aud: this.issuer.issuer,
            client_id: this.client_id,
            jti: random(),
            iat: unix,
            exp: unix + 300,
            ...this.fapi() ? {
                nbf: unix
            } : undefined
        }));
        if (signingAlgorithm === "none") {
            signed = [
                base64url.encode(JSON.stringify(header)),
                base64url.encode(payload),
                ""
            ].join(".");
        } else {
            const symmetric = signingAlgorithm.startsWith("HS");
            if (symmetric) {
                key = this.secretForAlg(signingAlgorithm);
            } else {
                const keystore = await keystores.get(this);
                if (!keystore) {
                    throw new TypeError(`no keystore present for client, cannot sign using alg ${signingAlgorithm}`);
                }
                key = keystore.get({
                    alg: signingAlgorithm,
                    use: "sig"
                });
                if (!key) {
                    throw new TypeError(`no key to sign with found for alg ${signingAlgorithm}`);
                }
            }
            signed = await new jose.CompactSign(new TextEncoder().encode(payload)).setProtectedHeader({
                ...header,
                kid: symmetric ? undefined : key.jwk.kid
            }).sign(symmetric ? key : key.keyObject);
        }
        if (!eKeyManagement) {
            return signed;
        }
        const fields = {
            alg: eKeyManagement,
            enc: eContentEncryption,
            cty: "oauth-authz-req+jwt"
        };
        if (fields.alg.match(/^(RSA|ECDH)/)) {
            [key] = await queryKeyStore.call(this.issuer, {
                alg: fields.alg,
                use: "enc"
            }, {
                allowMulti: true
            });
        } else {
            key = this.secretForAlg(fields.alg === "dir" ? fields.enc : fields.alg);
        }
        return new jose.CompactEncrypt(new TextEncoder().encode(signed)).setProtectedHeader({
            ...fields,
            kid: key instanceof Uint8Array ? undefined : key.jwk.kid
        }).encrypt(key instanceof Uint8Array ? key : key.keyObject);
    }
    async pushedAuthorizationRequest(params = {}, { clientAssertionPayload } = {}) {
        assertIssuerConfiguration(this.issuer, "pushed_authorization_request_endpoint");
        const body = {
            ..."request" in params ? params : authorizationParams.call(this, params),
            client_id: this.client_id
        };
        const response = await authenticatedPost.call(this, "pushed_authorization_request", {
            responseType: "json",
            form: body
        }, {
            clientAssertionPayload,
            endpointAuthMethod: "token"
        });
        const responseBody = processResponse(response, {
            statusCode: 201
        });
        if (!("expires_in" in responseBody)) {
            throw new RPError({
                message: "expected expires_in in Pushed Authorization Successful Response",
                response
            });
        }
        if (typeof responseBody.expires_in !== "number") {
            throw new RPError({
                message: "invalid expires_in value in Pushed Authorization Successful Response",
                response
            });
        }
        if (!("request_uri" in responseBody)) {
            throw new RPError({
                message: "expected request_uri in Pushed Authorization Successful Response",
                response
            });
        }
        if (typeof responseBody.request_uri !== "string") {
            throw new RPError({
                message: "invalid request_uri value in Pushed Authorization Successful Response",
                response
            });
        }
        return responseBody;
    }
    get issuer() {
        return this.#issuer;
    }
    /* istanbul ignore next */ [inspect.custom]() {
        return `${this.constructor.name} ${inspect(this.metadata, {
            depth: Infinity,
            colors: process.stdout.isTTY,
            compact: false,
            sorted: true
        })}`;
    }
    fapi() {
        return this.constructor.name === "FAPI1Client";
    }
    async validateJARM(response) {
        const expectedAlg = this.authorization_signed_response_alg;
        const { payload } = await this.validateJWT(response, expectedAlg, [
            "iss",
            "exp",
            "aud"
        ]);
        return pickCb(payload);
    }
}
const RSPS = /^(?:RS|PS)(?:256|384|512)$/;
function determineRsaAlgorithm(privateKey, privateKeyInput, valuesSupported) {
    if (typeof privateKeyInput === "object" && typeof privateKeyInput.key === "object" && privateKeyInput.key.alg) {
        return privateKeyInput.key.alg;
    }
    if (Array.isArray(valuesSupported)) {
        let candidates = valuesSupported.filter(RegExp.prototype.test.bind(RSPS));
        if (privateKey.asymmetricKeyType === "rsa-pss") {
            candidates = candidates.filter((value)=>value.startsWith("PS"));
        }
        return [
            "PS256",
            "PS384",
            "PS512",
            "RS256",
            "RS384",
            "RS384"
        ].find((preferred)=>candidates.includes(preferred));
    }
    return "PS256";
}
const p256 = Buffer.from([
    42,
    134,
    72,
    206,
    61,
    3,
    1,
    7
]);
const p384 = Buffer.from([
    43,
    129,
    4,
    0,
    34
]);
const p521 = Buffer.from([
    43,
    129,
    4,
    0,
    35
]);
const secp256k1 = Buffer.from([
    43,
    129,
    4,
    0,
    10
]);
function determineEcAlgorithm(privateKey, privateKeyInput) {
    // If input was a JWK
    switch(typeof privateKeyInput === "object" && typeof privateKeyInput.key === "object" && privateKeyInput.key.crv){
        case "P-256":
            return "ES256";
        case "secp256k1":
            return "ES256K";
        case "P-384":
            return "ES384";
        case "P-512":
            return "ES512";
        default:
            break;
    }
    const buf = privateKey.export({
        format: "der",
        type: "pkcs8"
    });
    const i = buf[1] < 128 ? 17 : 18;
    const len = buf[i];
    const curveOid = buf.slice(i + 1, i + 1 + len);
    if (curveOid.equals(p256)) {
        return "ES256";
    }
    if (curveOid.equals(p384)) {
        return "ES384";
    }
    if (curveOid.equals(p521)) {
        return "ES512";
    }
    if (curveOid.equals(secp256k1)) {
        return "ES256K";
    }
    throw new TypeError("unsupported DPoP private key curve");
}
const jwkCache = new WeakMap();
async function getJwk(privateKey, privateKeyInput) {
    if (typeof privateKeyInput === "object" && typeof privateKeyInput.key === "object" && privateKeyInput.key.crv) {
        return pick(privateKeyInput.key, "kty", "crv", "x", "y", "e", "n");
    }
    if (jwkCache.has(privateKeyInput)) {
        return jwkCache.get(privateKeyInput);
    }
    const jwk = pick(await jose.exportJWK(privateKey), "kty", "crv", "x", "y", "e", "n");
    if (isKeyObject(privateKeyInput)) {
        jwkCache.set(privateKeyInput, jwk);
    }
    return jwk;
}
/**
 * @name dpopProof
 * @api private
 */ async function dpopProof(payload, privateKeyInput, accessToken) {
    if (!isPlainObject(payload)) {
        throw new TypeError("payload must be a plain object");
    }
    let privateKey;
    if (isKeyObject(privateKeyInput)) {
        privateKey = privateKeyInput;
    } else {
        privateKey = crypto.createPrivateKey(privateKeyInput);
    }
    if (privateKey.type !== "private") {
        throw new TypeError('"DPoP" option must be a private key');
    }
    let alg;
    switch(privateKey.asymmetricKeyType){
        case "ed25519":
        case "ed448":
            alg = "EdDSA";
            break;
        case "ec":
            alg = determineEcAlgorithm(privateKey, privateKeyInput);
            break;
        case "rsa":
        case rsaPssParams && "rsa-pss":
            alg = determineRsaAlgorithm(privateKey, privateKeyInput, this.issuer.dpop_signing_alg_values_supported);
            break;
        default:
            throw new TypeError("unsupported DPoP private key asymmetric key type");
    }
    if (!alg) {
        throw new TypeError("could not determine DPoP JWS Algorithm");
    }
    return new jose.SignJWT({
        ath: accessToken ? base64url.encode(crypto.createHash("sha256").update(accessToken).digest()) : undefined,
        ...payload
    }).setProtectedHeader({
        alg,
        typ: "dpop+jwt",
        jwk: await getJwk(privateKey, privateKeyInput)
    }).setIssuedAt().setJti(random()).sign(privateKey);
}
Object.defineProperty(BaseClient.prototype, "dpopProof", {
    enumerable: true,
    configurable: true,
    value (...args) {
        process.emitWarning("The DPoP APIs implements an IETF draft (https://www.ietf.org/archive/id/draft-ietf-oauth-dpop-04.html). Breaking draft implementations are included as minor versions of the openid-client library, therefore, the ~ semver operator should be used and close attention be payed to library changelog as well as the drafts themselves.", "DraftWarning");
        Object.defineProperty(BaseClient.prototype, "dpopProof", {
            enumerable: true,
            configurable: true,
            value: dpopProof
        });
        return this.dpopProof(...args);
    }
});
module.exports = (issuer, aadIssValidation = false)=>class Client extends BaseClient {
        constructor(...args){
            super(issuer, aadIssValidation, ...args);
        }
        static get issuer() {
            return issuer;
        }
    };
module.exports.BaseClient = BaseClient;


/***/ }),

/***/ 70320:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { inspect } = __webpack_require__(73837);
const { RPError, OPError } = __webpack_require__(28687);
const now = __webpack_require__(75031);
class DeviceFlowHandle {
    #aborted;
    #client;
    #clientAssertionPayload;
    #DPoP;
    #exchangeBody;
    #expires_at;
    #interval;
    #maxAge;
    #response;
    constructor({ client, exchangeBody, clientAssertionPayload, response, maxAge, DPoP }){
        [
            "verification_uri",
            "user_code",
            "device_code"
        ].forEach((prop)=>{
            if (typeof response[prop] !== "string" || !response[prop]) {
                throw new RPError(`expected ${prop} string to be returned by Device Authorization Response, got %j`, response[prop]);
            }
        });
        if (!Number.isSafeInteger(response.expires_in)) {
            throw new RPError("expected expires_in number to be returned by Device Authorization Response, got %j", response.expires_in);
        }
        this.#expires_at = now() + response.expires_in;
        this.#client = client;
        this.#DPoP = DPoP;
        this.#maxAge = maxAge;
        this.#exchangeBody = exchangeBody;
        this.#clientAssertionPayload = clientAssertionPayload;
        this.#response = response;
        this.#interval = response.interval * 1000 || 5000;
    }
    abort() {
        this.#aborted = true;
    }
    async poll({ signal } = {}) {
        if (signal && signal.aborted || this.#aborted) {
            throw new RPError("polling aborted");
        }
        if (this.expired()) {
            throw new RPError("the device code %j has expired and the device authorization session has concluded", this.device_code);
        }
        await new Promise((resolve)=>setTimeout(resolve, this.#interval));
        let tokenset;
        try {
            tokenset = await this.#client.grant({
                ...this.#exchangeBody,
                grant_type: "urn:ietf:params:oauth:grant-type:device_code",
                device_code: this.device_code
            }, {
                clientAssertionPayload: this.#clientAssertionPayload,
                DPoP: this.#DPoP
            });
        } catch (err) {
            switch(err instanceof OPError && err.error){
                case "slow_down":
                    this.#interval += 5000;
                case "authorization_pending":
                    return this.poll({
                        signal
                    });
                default:
                    throw err;
            }
        }
        if ("id_token" in tokenset) {
            await this.#client.decryptIdToken(tokenset);
            await this.#client.validateIdToken(tokenset, undefined, "token", this.#maxAge);
        }
        return tokenset;
    }
    get device_code() {
        return this.#response.device_code;
    }
    get user_code() {
        return this.#response.user_code;
    }
    get verification_uri() {
        return this.#response.verification_uri;
    }
    get verification_uri_complete() {
        return this.#response.verification_uri_complete;
    }
    get expires_in() {
        return Math.max.apply(null, [
            this.#expires_at - now(),
            0
        ]);
    }
    expired() {
        return this.expires_in === 0;
    }
    /* istanbul ignore next */ [inspect.custom]() {
        return `${this.constructor.name} ${inspect(this.#response, {
            depth: Infinity,
            colors: process.stdout.isTTY,
            compact: false,
            sorted: true
        })}`;
    }
}
module.exports = DeviceFlowHandle;


/***/ }),

/***/ 28687:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { format } = __webpack_require__(73837);
class OPError extends Error {
    constructor({ error_description, error, error_uri, session_state, state, scope }, response){
        super(!error_description ? error : `${error} (${error_description})`);
        Object.assign(this, {
            error
        }, error_description && {
            error_description
        }, error_uri && {
            error_uri
        }, state && {
            state
        }, scope && {
            scope
        }, session_state && {
            session_state
        });
        if (response) {
            Object.defineProperty(this, "response", {
                value: response
            });
        }
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
}
class RPError extends Error {
    constructor(...args){
        if (typeof args[0] === "string") {
            super(format(...args));
        } else {
            const { message, printf, response, ...rest } = args[0];
            if (printf) {
                super(format(...printf));
            } else {
                super(message);
            }
            Object.assign(this, rest);
            if (response) {
                Object.defineProperty(this, "response", {
                    value: response
                });
            }
        }
        this.name = this.constructor.name;
        Error.captureStackTrace(this, this.constructor);
    }
}
module.exports = {
    OPError,
    RPError
};


/***/ }),

/***/ 62743:
/***/ ((module) => {

"use strict";

function assertSigningAlgValuesSupport(endpoint, issuer, properties) {
    if (!issuer[`${endpoint}_endpoint`]) return;
    const eam = `${endpoint}_endpoint_auth_method`;
    const easa = `${endpoint}_endpoint_auth_signing_alg`;
    const easavs = `${endpoint}_endpoint_auth_signing_alg_values_supported`;
    if (properties[eam] && properties[eam].endsWith("_jwt") && !properties[easa] && !issuer[easavs]) {
        throw new TypeError(`${easavs} must be configured on the issuer if ${easa} is not defined on a client`);
    }
}
function assertIssuerConfiguration(issuer, endpoint) {
    if (!issuer[endpoint]) {
        throw new TypeError(`${endpoint} must be configured on the issuer`);
    }
}
module.exports = {
    assertSigningAlgValuesSupport,
    assertIssuerConfiguration
};


/***/ }),

/***/ 86361:
/***/ ((module) => {

"use strict";

let encode;
if (Buffer.isEncoding("base64url")) {
    encode = (input, encoding = "utf8")=>Buffer.from(input, encoding).toString("base64url");
} else {
    const fromBase64 = (base64)=>base64.replace(/=/g, "").replace(/\+/g, "-").replace(/\//g, "_");
    encode = (input, encoding = "utf8")=>fromBase64(Buffer.from(input, encoding).toString("base64"));
}
const decode = (input)=>Buffer.from(input, "base64");
module.exports.decode = decode;
module.exports.encode = encode;


/***/ }),

/***/ 61930:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const jose = __webpack_require__(91017);
const { RPError } = __webpack_require__(28687);
const { assertIssuerConfiguration } = __webpack_require__(62743);
const { random } = __webpack_require__(20356);
const now = __webpack_require__(75031);
const request = __webpack_require__(16010);
const { keystores } = __webpack_require__(72145);
const merge = __webpack_require__(95239);
const formUrlEncode = (value)=>encodeURIComponent(value).replace(/%20/g, "+");
async function clientAssertion(endpoint, payload) {
    let alg = this[`${endpoint}_endpoint_auth_signing_alg`];
    if (!alg) {
        assertIssuerConfiguration(this.issuer, `${endpoint}_endpoint_auth_signing_alg_values_supported`);
    }
    if (this[`${endpoint}_endpoint_auth_method`] === "client_secret_jwt") {
        if (!alg) {
            const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];
            alg = Array.isArray(supported) && supported.find((signAlg)=>/^HS(?:256|384|512)/.test(signAlg));
        }
        if (!alg) {
            throw new RPError(`failed to determine a JWS Algorithm to use for ${this[`${endpoint}_endpoint_auth_method`]} Client Assertion`);
        }
        return new jose.CompactSign(Buffer.from(JSON.stringify(payload))).setProtectedHeader({
            alg
        }).sign(this.secretForAlg(alg));
    }
    const keystore = await keystores.get(this);
    if (!keystore) {
        throw new TypeError("no client jwks provided for signing a client assertion with");
    }
    if (!alg) {
        const supported = this.issuer[`${endpoint}_endpoint_auth_signing_alg_values_supported`];
        alg = Array.isArray(supported) && supported.find((signAlg)=>keystore.get({
                alg: signAlg,
                use: "sig"
            }));
    }
    if (!alg) {
        throw new RPError(`failed to determine a JWS Algorithm to use for ${this[`${endpoint}_endpoint_auth_method`]} Client Assertion`);
    }
    const key = keystore.get({
        alg,
        use: "sig"
    });
    if (!key) {
        throw new RPError(`no key found in client jwks to sign a client assertion with using alg ${alg}`);
    }
    return new jose.CompactSign(Buffer.from(JSON.stringify(payload))).setProtectedHeader({
        alg,
        kid: key.jwk && key.jwk.kid
    }).sign(key.keyObject);
}
async function authFor(endpoint, { clientAssertionPayload } = {}) {
    const authMethod = this[`${endpoint}_endpoint_auth_method`];
    switch(authMethod){
        case "self_signed_tls_client_auth":
        case "tls_client_auth":
        case "none":
            return {
                form: {
                    client_id: this.client_id
                }
            };
        case "client_secret_post":
            if (typeof this.client_secret !== "string") {
                throw new TypeError("client_secret_post client authentication method requires a client_secret");
            }
            return {
                form: {
                    client_id: this.client_id,
                    client_secret: this.client_secret
                }
            };
        case "private_key_jwt":
        case "client_secret_jwt":
            {
                const timestamp = now();
                const audience = [
                    ...new Set([
                        this.issuer.issuer,
                        this.issuer.token_endpoint
                    ].filter(Boolean))
                ];
                const assertion = await clientAssertion.call(this, endpoint, {
                    iat: timestamp,
                    exp: timestamp + 60,
                    jti: random(),
                    iss: this.client_id,
                    sub: this.client_id,
                    aud: audience,
                    ...clientAssertionPayload
                });
                return {
                    form: {
                        client_id: this.client_id,
                        client_assertion: assertion,
                        client_assertion_type: "urn:ietf:params:oauth:client-assertion-type:jwt-bearer"
                    }
                };
            }
        case "client_secret_basic":
            {
                // This is correct behaviour, see https://tools.ietf.org/html/rfc6749#section-2.3.1 and the
                // related appendix. (also https://github.com/panva/node-openid-client/pull/91)
                // > The client identifier is encoded using the
                // > "application/x-www-form-urlencoded" encoding algorithm per
                // > Appendix B, and the encoded value is used as the username; the client
                // > password is encoded using the same algorithm and used as the
                // > password.
                if (typeof this.client_secret !== "string") {
                    throw new TypeError("client_secret_basic client authentication method requires a client_secret");
                }
                const encoded = `${formUrlEncode(this.client_id)}:${formUrlEncode(this.client_secret)}`;
                const value = Buffer.from(encoded).toString("base64");
                return {
                    headers: {
                        Authorization: `Basic ${value}`
                    }
                };
            }
        default:
            {
                throw new TypeError(`missing, or unsupported, ${endpoint}_endpoint_auth_method`);
            }
    }
}
function resolveResponseType() {
    const { length, 0: value } = this.response_types;
    if (length === 1) {
        return value;
    }
    return undefined;
}
function resolveRedirectUri() {
    const { length, 0: value } = this.redirect_uris || [];
    if (length === 1) {
        return value;
    }
    return undefined;
}
async function authenticatedPost(endpoint, opts, { clientAssertionPayload, endpointAuthMethod = endpoint, DPoP } = {}) {
    const auth = await authFor.call(this, endpointAuthMethod, {
        clientAssertionPayload
    });
    const requestOpts = merge(opts, auth);
    const mTLS = this[`${endpointAuthMethod}_endpoint_auth_method`].includes("tls_client_auth") || endpoint === "token" && this.tls_client_certificate_bound_access_tokens;
    let targetUrl;
    if (mTLS && this.issuer.mtls_endpoint_aliases) {
        targetUrl = this.issuer.mtls_endpoint_aliases[`${endpoint}_endpoint`];
    }
    targetUrl = targetUrl || this.issuer[`${endpoint}_endpoint`];
    if ("form" in requestOpts) {
        for (const [key, value] of Object.entries(requestOpts.form)){
            if (typeof value === "undefined") {
                delete requestOpts.form[key];
            }
        }
    }
    return request.call(this, {
        ...requestOpts,
        method: "POST",
        url: targetUrl,
        headers: {
            ...endpoint !== "revocation" ? {
                Accept: "application/json"
            } : undefined,
            ...requestOpts.headers
        }
    }, {
        mTLS,
        DPoP
    });
}
module.exports = {
    resolveResponseType,
    resolveRedirectUri,
    authFor,
    authenticatedPost
};


/***/ }),

/***/ 83610:
/***/ ((module) => {

"use strict";

const HTTP_OPTIONS = Symbol();
const CLOCK_TOLERANCE = Symbol();
module.exports = {
    CLOCK_TOLERANCE,
    HTTP_OPTIONS
};


/***/ }),

/***/ 91189:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const base64url = __webpack_require__(86361);
module.exports = (token)=>{
    if (typeof token !== "string" || !token) {
        throw new TypeError("JWT must be a string");
    }
    const { 0: header, 1: payload, 2: signature, length } = token.split(".");
    if (length === 5) {
        throw new TypeError("encrypted JWTs cannot be decoded");
    }
    if (length !== 3) {
        throw new Error("JWTs must have three components");
    }
    try {
        return {
            header: JSON.parse(base64url.decode(header)),
            payload: JSON.parse(base64url.decode(payload)),
            signature
        };
    } catch (err) {
        throw new Error("JWT is malformed");
    }
};


/***/ }),

/***/ 66306:
/***/ ((module) => {

"use strict";

module.exports = globalThis.structuredClone || ((obj)=>JSON.parse(JSON.stringify(obj)));


/***/ }),

/***/ 37767:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const isPlainObject = __webpack_require__(32134);
function defaults(deep, target, ...sources) {
    for (const source of sources){
        if (!isPlainObject(source)) {
            continue;
        }
        for (const [key, value] of Object.entries(source)){
            /* istanbul ignore if */ if (key === "__proto__" || key === "constructor") {
                continue;
            }
            if (typeof target[key] === "undefined" && typeof value !== "undefined") {
                target[key] = value;
            }
            if (deep && isPlainObject(target[key]) && isPlainObject(value)) {
                defaults(true, target[key], value);
            }
        }
    }
    return target;
}
module.exports = defaults.bind(undefined, false);
module.exports.deep = defaults.bind(undefined, true);


/***/ }),

/***/ 20356:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { createHash, randomBytes } = __webpack_require__(6113);
const base64url = __webpack_require__(86361);
const random = (bytes = 32)=>base64url.encode(randomBytes(bytes));
module.exports = {
    random,
    state: random,
    nonce: random,
    codeVerifier: random,
    codeChallenge: (codeVerifier)=>base64url.encode(createHash("sha256").update(codeVerifier).digest())
};


/***/ }),

/***/ 15484:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const util = __webpack_require__(73837);
const crypto = __webpack_require__(6113);
module.exports = util.types.isKeyObject || ((obj)=>obj && obj instanceof crypto.KeyObject);


/***/ }),

/***/ 32134:
/***/ ((module) => {

"use strict";

module.exports = (a)=>!!a && a.constructor === Object;


/***/ }),

/***/ 42921:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const objectHash = __webpack_require__(14256);
const LRU = __webpack_require__(96442);
const { RPError } = __webpack_require__(28687);
const { assertIssuerConfiguration } = __webpack_require__(62743);
const KeyStore = __webpack_require__(24237);
const { keystores } = __webpack_require__(72145);
const processResponse = __webpack_require__(27282);
const request = __webpack_require__(16010);
const inFlight = new WeakMap();
const caches = new WeakMap();
const lrus = (ctx)=>{
    if (!caches.has(ctx)) {
        caches.set(ctx, new LRU({
            max: 100
        }));
    }
    return caches.get(ctx);
};
async function getKeyStore(reload = false) {
    assertIssuerConfiguration(this, "jwks_uri");
    const keystore = keystores.get(this);
    const cache = lrus(this);
    if (reload || !keystore) {
        if (inFlight.has(this)) {
            return inFlight.get(this);
        }
        cache.reset();
        inFlight.set(this, (async ()=>{
            const response = await request.call(this, {
                method: "GET",
                responseType: "json",
                url: this.jwks_uri,
                headers: {
                    Accept: "application/json, application/jwk-set+json"
                }
            }).finally(()=>{
                inFlight.delete(this);
            });
            const jwks = processResponse(response);
            const joseKeyStore = KeyStore.fromJWKS(jwks, {
                onlyPublic: true
            });
            cache.set("throttle", true, 60 * 1000);
            keystores.set(this, joseKeyStore);
            return joseKeyStore;
        })());
        return inFlight.get(this);
    }
    return keystore;
}
async function queryKeyStore({ kid, kty, alg, use }, { allowMulti = false } = {}) {
    const cache = lrus(this);
    const def = {
        kid,
        kty,
        alg,
        use
    };
    const defHash = objectHash(def, {
        algorithm: "sha256",
        ignoreUnknown: true,
        unorderedArrays: true,
        unorderedSets: true
    });
    // refresh keystore on every unknown key but also only upto once every minute
    const freshJwksUri = cache.get(defHash) || cache.get("throttle");
    const keystore = await getKeyStore.call(this, !freshJwksUri);
    const keys = keystore.all(def);
    delete def.use;
    if (keys.length === 0) {
        throw new RPError({
            printf: [
                "no valid key found in issuer's jwks_uri for key parameters %j",
                def
            ],
            jwks: keystore
        });
    }
    if (!allowMulti && keys.length > 1 && !kid) {
        throw new RPError({
            printf: [
                "multiple matching keys found in issuer's jwks_uri for key parameters %j, kid must be provided in this case",
                def
            ],
            jwks: keystore
        });
    }
    cache.set(defHash, true);
    return keys;
}
module.exports.queryKeyStore = queryKeyStore;
module.exports.keystore = getKeyStore;


/***/ }),

/***/ 24237:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const jose = __webpack_require__(91017);
const clone = __webpack_require__(66306);
const isPlainObject = __webpack_require__(32134);
const isKeyObject = __webpack_require__(15484);
const internal = Symbol();
function fauxAlg(kty) {
    switch(kty){
        case "RSA":
            return "RSA-OAEP";
        case "EC":
            return "ECDH-ES";
        case "OKP":
            return "ECDH-ES";
        case "oct":
            return "HS256";
        default:
            return undefined;
    }
}
const keyscore = (key, { alg, use })=>{
    let score = 0;
    if (alg && key.alg) {
        score++;
    }
    if (use && key.use) {
        score++;
    }
    return score;
};
function getKtyFromAlg(alg) {
    switch(typeof alg === "string" && alg.slice(0, 2)){
        case "RS":
        case "PS":
            return "RSA";
        case "ES":
            return "EC";
        case "Ed":
            return "OKP";
        default:
            return undefined;
    }
}
function getAlgorithms(use, alg, kty, crv) {
    // Ed25519, Ed448, and secp256k1 always have "alg"
    // OKP always has use
    if (alg) {
        return new Set([
            alg
        ]);
    }
    switch(kty){
        case "EC":
            {
                let algs = [];
                if (use === "enc" || use === undefined) {
                    algs = algs.concat([
                        "ECDH-ES",
                        "ECDH-ES+A128KW",
                        "ECDH-ES+A192KW",
                        "ECDH-ES+A256KW"
                    ]);
                }
                if (use === "sig" || use === undefined) {
                    algs = algs.concat([
                        `ES${crv.slice(-3)}`.replace("21", "12")
                    ]);
                }
                return new Set(algs);
            }
        case "OKP":
            {
                return new Set([
                    "ECDH-ES",
                    "ECDH-ES+A128KW",
                    "ECDH-ES+A192KW",
                    "ECDH-ES+A256KW"
                ]);
            }
        case "RSA":
            {
                let algs = [];
                if (use === "enc" || use === undefined) {
                    algs = algs.concat([
                        "RSA-OAEP",
                        "RSA-OAEP-256",
                        "RSA-OAEP-384",
                        "RSA-OAEP-512",
                        "RSA1_5"
                    ]);
                }
                if (use === "sig" || use === undefined) {
                    algs = algs.concat([
                        "PS256",
                        "PS384",
                        "PS512",
                        "RS256",
                        "RS384",
                        "RS512"
                    ]);
                }
                return new Set(algs);
            }
        default:
            throw new Error("unreachable");
    }
}
module.exports = class KeyStore {
    #keys;
    constructor(i, keys){
        if (i !== internal) throw new Error("invalid constructor call");
        this.#keys = keys;
    }
    toJWKS() {
        return {
            keys: this.map(({ jwk: { d, p, q, dp, dq, qi, ...jwk } })=>jwk)
        };
    }
    all({ alg, kid, use } = {}) {
        if (!use || !alg) {
            throw new Error();
        }
        const kty = getKtyFromAlg(alg);
        const search = {
            alg,
            use
        };
        return this.filter((key)=>{
            let candidate = true;
            if (candidate && kty !== undefined && key.jwk.kty !== kty) {
                candidate = false;
            }
            if (candidate && kid !== undefined && key.jwk.kid !== kid) {
                candidate = false;
            }
            if (candidate && use !== undefined && key.jwk.use !== undefined && key.jwk.use !== use) {
                candidate = false;
            }
            if (candidate && key.jwk.alg && key.jwk.alg !== alg) {
                candidate = false;
            } else if (!key.algorithms.has(alg)) {
                candidate = false;
            }
            return candidate;
        }).sort((first, second)=>keyscore(second, search) - keyscore(first, search));
    }
    get(...args) {
        return this.all(...args)[0];
    }
    static async fromJWKS(jwks, { onlyPublic = false, onlyPrivate = false } = {}) {
        if (!isPlainObject(jwks) || !Array.isArray(jwks.keys) || jwks.keys.some((k)=>!isPlainObject(k) || !("kty" in k))) {
            throw new TypeError("jwks must be a JSON Web Key Set formatted object");
        }
        const keys = [];
        for (let jwk of jwks.keys){
            jwk = clone(jwk);
            const { kty, kid, crv } = jwk;
            let { alg, use } = jwk;
            if (typeof kty !== "string" || !kty) {
                continue;
            }
            if (use !== undefined && use !== "sig" && use !== "enc") {
                continue;
            }
            if (typeof alg !== "string" && alg !== undefined) {
                continue;
            }
            if (typeof kid !== "string" && kid !== undefined) {
                continue;
            }
            if (kty === "EC" && use === "sig") {
                switch(crv){
                    case "P-256":
                        alg = "ES256";
                        break;
                    case "P-384":
                        alg = "ES384";
                        break;
                    case "P-521":
                        alg = "ES512";
                        break;
                    default:
                        break;
                }
            }
            if (crv === "secp256k1") {
                use = "sig";
                alg = "ES256K";
            }
            if (kty === "OKP") {
                switch(crv){
                    case "Ed25519":
                    case "Ed448":
                        use = "sig";
                        alg = "EdDSA";
                        break;
                    case "X25519":
                    case "X448":
                        use = "enc";
                        break;
                    default:
                        break;
                }
            }
            if (alg && !use) {
                switch(true){
                    case alg.startsWith("ECDH"):
                        use = "enc";
                        break;
                    case alg.startsWith("RSA"):
                        use = "enc";
                        break;
                    default:
                        break;
                }
            }
            const keyObject = await jose.importJWK(jwk, alg || fauxAlg(jwk.kty)).catch(()=>{});
            if (!keyObject) continue;
            if (keyObject instanceof Uint8Array || keyObject.type === "secret") {
                if (onlyPrivate) {
                    throw new Error("jwks must only contain private keys");
                }
                continue;
            }
            if (!isKeyObject(keyObject)) {
                throw new Error("what?!");
            }
            if (onlyPrivate && keyObject.type !== "private") {
                throw new Error("jwks must only contain private keys");
            }
            if (onlyPublic && keyObject.type !== "public") {
                continue;
            }
            if (kty === "RSA" && keyObject.asymmetricKeySize < 2048) {
                continue;
            }
            keys.push({
                jwk: {
                    ...jwk,
                    alg,
                    use
                },
                keyObject,
                get algorithms () {
                    Object.defineProperty(this, "algorithms", {
                        value: getAlgorithms(this.jwk.use, this.jwk.alg, this.jwk.kty, this.jwk.crv),
                        enumerable: true,
                        configurable: false
                    });
                    return this.algorithms;
                }
            });
        }
        return new this(internal, keys);
    }
    filter(...args) {
        return this.#keys.filter(...args);
    }
    find(...args) {
        return this.#keys.find(...args);
    }
    every(...args) {
        return this.#keys.every(...args);
    }
    some(...args) {
        return this.#keys.some(...args);
    }
    map(...args) {
        return this.#keys.map(...args);
    }
    forEach(...args) {
        return this.#keys.forEach(...args);
    }
    reduce(...args) {
        return this.#keys.reduce(...args);
    }
    sort(...args) {
        return this.#keys.sort(...args);
    }
    *[Symbol.iterator]() {
        for (const key of this.#keys){
            yield key;
        }
    }
};


/***/ }),

/***/ 95239:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const isPlainObject = __webpack_require__(32134);
function merge(target, ...sources) {
    for (const source of sources){
        if (!isPlainObject(source)) {
            continue;
        }
        for (const [key, value] of Object.entries(source)){
            /* istanbul ignore if */ if (key === "__proto__" || key === "constructor") {
                continue;
            }
            if (isPlainObject(target[key]) && isPlainObject(value)) {
                target[key] = merge(target[key], value);
            } else if (typeof value !== "undefined") {
                target[key] = value;
            }
        }
    }
    return target;
}
module.exports = merge;


/***/ }),

/***/ 48852:
/***/ ((module) => {

"use strict";

module.exports = function pick(object, ...paths) {
    const obj = {};
    for (const path of paths){
        if (object[path] !== undefined) {
            obj[path] = object[path];
        }
    }
    return obj;
};


/***/ }),

/***/ 27282:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { STATUS_CODES } = __webpack_require__(13685);
const { format } = __webpack_require__(73837);
const { OPError } = __webpack_require__(28687);
const parseWwwAuthenticate = __webpack_require__(55680);
const throwAuthenticateErrors = (response)=>{
    const params = parseWwwAuthenticate(response.headers["www-authenticate"]);
    if (params.error) {
        throw new OPError(params, response);
    }
};
const isStandardBodyError = (response)=>{
    let result = false;
    try {
        let jsonbody;
        if (typeof response.body !== "object" || Buffer.isBuffer(response.body)) {
            jsonbody = JSON.parse(response.body);
        } else {
            jsonbody = response.body;
        }
        result = typeof jsonbody.error === "string" && jsonbody.error.length;
        if (result) Object.defineProperty(response, "body", {
            value: jsonbody,
            configurable: true
        });
    } catch (err) {}
    return result;
};
function processResponse(response, { statusCode = 200, body = true, bearer = false } = {}) {
    if (response.statusCode !== statusCode) {
        if (bearer) {
            throwAuthenticateErrors(response);
        }
        if (isStandardBodyError(response)) {
            throw new OPError(response.body, response);
        }
        throw new OPError({
            error: format("expected %i %s, got: %i %s", statusCode, STATUS_CODES[statusCode], response.statusCode, STATUS_CODES[response.statusCode])
        }, response);
    }
    if (body && !response.body) {
        throw new OPError({
            error: format("expected %i %s with body but no body was returned", statusCode, STATUS_CODES[statusCode])
        }, response);
    }
    return response.body;
}
module.exports = processResponse;


/***/ }),

/***/ 16010:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const assert = __webpack_require__(39491);
const querystring = __webpack_require__(63477);
const http = __webpack_require__(13685);
const https = __webpack_require__(95687);
const { once } = __webpack_require__(82361);
const { URL } = __webpack_require__(57310);
const LRU = __webpack_require__(96442);
const pkg = __webpack_require__(84659);
const { RPError } = __webpack_require__(28687);
const pick = __webpack_require__(48852);
const { deep: defaultsDeep } = __webpack_require__(37767);
const { HTTP_OPTIONS } = __webpack_require__(83610);
let DEFAULT_HTTP_OPTIONS;
const NQCHAR = /^[\x21\x23-\x5B\x5D-\x7E]+$/;
const allowed = [
    "agent",
    "ca",
    "cert",
    "crl",
    "headers",
    "key",
    "lookup",
    "passphrase",
    "pfx",
    "timeout"
];
const setDefaults = (props, options)=>{
    DEFAULT_HTTP_OPTIONS = defaultsDeep({}, props.length ? pick(options, ...props) : options, DEFAULT_HTTP_OPTIONS);
};
setDefaults([], {
    headers: {
        "User-Agent": `${pkg.name}/${pkg.version} (${pkg.homepage})`
    },
    timeout: 3500
});
function send(req, body, contentType) {
    if (contentType) {
        req.removeHeader("content-type");
        req.setHeader("content-type", contentType);
    }
    if (body) {
        req.removeHeader("content-length");
        req.setHeader("content-length", Buffer.byteLength(body));
        req.write(body);
    }
    req.end();
}
const nonces = new LRU({
    max: 100
});
module.exports = async function request(options, { accessToken, mTLS = false, DPoP } = {}) {
    let url;
    try {
        url = new URL(options.url);
        delete options.url;
        assert(/^(https?:)$/.test(url.protocol));
    } catch (err) {
        throw new TypeError("only valid absolute URLs can be requested");
    }
    const optsFn = this[HTTP_OPTIONS];
    let opts = options;
    const nonceKey = `${url.origin}${url.pathname}`;
    if (DPoP && "dpopProof" in this) {
        opts.headers = opts.headers || {};
        opts.headers.DPoP = await this.dpopProof({
            htu: `${url.origin}${url.pathname}`,
            htm: options.method,
            nonce: nonces.get(nonceKey)
        }, DPoP, accessToken);
    }
    let userOptions;
    if (optsFn) {
        userOptions = pick(optsFn.call(this, url, defaultsDeep({}, opts, DEFAULT_HTTP_OPTIONS)), ...allowed);
    }
    opts = defaultsDeep({}, userOptions, opts, DEFAULT_HTTP_OPTIONS);
    if (mTLS && !opts.pfx && !(opts.key && opts.cert)) {
        throw new TypeError("mutual-TLS certificate and key not set");
    }
    if (opts.searchParams) {
        for (const [key, value] of Object.entries(opts.searchParams)){
            url.searchParams.delete(key);
            url.searchParams.set(key, value);
        }
    }
    let responseType;
    let form;
    let json;
    let body;
    ({ form, responseType, json, body, ...opts } = opts);
    for (const [key, value] of Object.entries(opts.headers || {})){
        if (value === undefined) {
            delete opts.headers[key];
        }
    }
    let response;
    const req = (url.protocol === "https:" ? https.request : http.request)(url.href, opts);
    return (async ()=>{
        if (json) {
            send(req, JSON.stringify(json), "application/json");
        } else if (form) {
            send(req, querystring.stringify(form), "application/x-www-form-urlencoded");
        } else if (body) {
            send(req, body);
        } else {
            send(req);
        }
        [response] = await Promise.race([
            once(req, "response"),
            once(req, "timeout")
        ]);
        // timeout reached
        if (!response) {
            req.destroy();
            throw new RPError(`outgoing request timed out after ${opts.timeout}ms`);
        }
        const parts = [];
        for await (const part of response){
            parts.push(part);
        }
        if (parts.length) {
            switch(responseType){
                case "json":
                    {
                        Object.defineProperty(response, "body", {
                            get () {
                                let value = Buffer.concat(parts);
                                try {
                                    value = JSON.parse(value);
                                } catch (err) {
                                    Object.defineProperty(err, "response", {
                                        value: response
                                    });
                                    throw err;
                                } finally{
                                    Object.defineProperty(response, "body", {
                                        value,
                                        configurable: true
                                    });
                                }
                                return value;
                            },
                            configurable: true
                        });
                        break;
                    }
                case undefined:
                case "buffer":
                    {
                        Object.defineProperty(response, "body", {
                            get () {
                                const value = Buffer.concat(parts);
                                Object.defineProperty(response, "body", {
                                    value,
                                    configurable: true
                                });
                                return value;
                            },
                            configurable: true
                        });
                        break;
                    }
                default:
                    throw new TypeError("unsupported responseType request option");
            }
        }
        return response;
    })().catch((err)=>{
        if (response) Object.defineProperty(err, "response", {
            value: response
        });
        throw err;
    }).finally(()=>{
        const dpopNonce = response && response.headers["dpop-nonce"];
        if (dpopNonce && NQCHAR.test(dpopNonce)) {
            nonces.set(nonceKey, dpopNonce);
        }
    });
};
module.exports.setDefaults = setDefaults.bind(undefined, allowed);


/***/ }),

/***/ 75031:
/***/ ((module) => {

"use strict";

module.exports = ()=>Math.floor(Date.now() / 1000);


/***/ }),

/***/ 72145:
/***/ ((module) => {

"use strict";

module.exports.keystores = new WeakMap();


/***/ }),

/***/ 19361:
/***/ ((module) => {

"use strict";
// Credit: https://github.com/rohe/pyoidc/blob/master/src/oic/utils/webfinger.py
// -- Normalization --
// A string of any other type is interpreted as a URI either the form of scheme
// "://" authority path-abempty [ "?" query ] [ "#" fragment ] or authority
// path-abempty [ "?" query ] [ "#" fragment ] per RFC 3986 [RFC3986] and is
// normalized according to the following rules:
//
// If the user input Identifier does not have an RFC 3986 [RFC3986] scheme
// portion, the string is interpreted as [userinfo "@"] host [":" port]
// path-abempty [ "?" query ] [ "#" fragment ] per RFC 3986 [RFC3986].
// If the userinfo component is present and all of the path component, query
// component, and port component are empty, the acct scheme is assumed. In this
// case, the normalized URI is formed by prefixing acct: to the string as the
// scheme. Per the 'acct' URI Scheme [ID.ietfappsawgaccturi], if there is an
// at-sign character ('@') in the userinfo component, it needs to be
// percent-encoded as described in RFC 3986 [RFC3986].
// For all other inputs without a scheme portion, the https scheme is assumed,
// and the normalized URI is formed by prefixing https:// to the string as the
// scheme.
// If the resulting URI contains a fragment portion, it MUST be stripped off
// together with the fragment delimiter character "#".
// The WebFinger [ID.ietfappsawgwebfinger] Resource in this case is the
// resulting URI, and the WebFinger Host is the authority component.
//
// Note: Since the definition of authority in RFC 3986 [RFC3986] is
// [ userinfo "@" ] host [ ":" port ], it is legal to have a user input
// identifier like userinfo@host:port, e.g., alice@example.com:8080.

const PORT = /^\d+$/;
function hasScheme(input) {
    if (input.includes("://")) return true;
    const authority = input.replace(/(\/|\?)/g, "#").split("#")[0];
    if (authority.includes(":")) {
        const index = authority.indexOf(":");
        const hostOrPort = authority.slice(index + 1);
        if (!PORT.test(hostOrPort)) {
            return true;
        }
    }
    return false;
}
function acctSchemeAssumed(input) {
    if (!input.includes("@")) return false;
    const parts = input.split("@");
    const host = parts[parts.length - 1];
    return !(host.includes(":") || host.includes("/") || host.includes("?"));
}
function normalize(input) {
    if (typeof input !== "string") {
        throw new TypeError("input must be a string");
    }
    let output;
    if (hasScheme(input)) {
        output = input;
    } else if (acctSchemeAssumed(input)) {
        output = `acct:${input}`;
    } else {
        output = `https://${input}`;
    }
    return output.split("#")[0];
}
module.exports = normalize;


/***/ }),

/***/ 55680:
/***/ ((module) => {

"use strict";

const REGEXP = /(\w+)=("[^"]*")/g;
module.exports = (wwwAuthenticate)=>{
    const params = {};
    try {
        while(REGEXP.exec(wwwAuthenticate) !== null){
            if (RegExp.$1 && RegExp.$2) {
                params[RegExp.$1] = RegExp.$2.slice(1, -1);
            }
        }
    } catch (err) {}
    return params;
};


/***/ }),

/***/ 32698:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const Issuer = __webpack_require__(83334);
const { OPError, RPError } = __webpack_require__(28687);
const Strategy = __webpack_require__(92186);
const TokenSet = __webpack_require__(90224);
const { CLOCK_TOLERANCE, HTTP_OPTIONS } = __webpack_require__(83610);
const generators = __webpack_require__(20356);
const { setDefaults } = __webpack_require__(16010);
module.exports = {
    Issuer,
    Strategy,
    TokenSet,
    errors: {
        OPError,
        RPError
    },
    custom: {
        setHttpOptionsDefaults: setDefaults,
        http_options: HTTP_OPTIONS,
        clock_tolerance: CLOCK_TOLERANCE
    },
    generators
};


/***/ }),

/***/ 83334:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const { inspect } = __webpack_require__(73837);
const url = __webpack_require__(57310);
const { RPError } = __webpack_require__(28687);
const getClient = __webpack_require__(88273);
const registry = __webpack_require__(34498);
const processResponse = __webpack_require__(27282);
const webfingerNormalize = __webpack_require__(19361);
const request = __webpack_require__(16010);
const clone = __webpack_require__(66306);
const { keystore } = __webpack_require__(42921);
const AAD_MULTITENANT_DISCOVERY = [
    "https://login.microsoftonline.com/common/.well-known/openid-configuration",
    "https://login.microsoftonline.com/common/v2.0/.well-known/openid-configuration",
    "https://login.microsoftonline.com/organizations/v2.0/.well-known/openid-configuration",
    "https://login.microsoftonline.com/consumers/v2.0/.well-known/openid-configuration"
];
const AAD_MULTITENANT = Symbol();
const ISSUER_DEFAULTS = {
    claim_types_supported: [
        "normal"
    ],
    claims_parameter_supported: false,
    grant_types_supported: [
        "authorization_code",
        "implicit"
    ],
    request_parameter_supported: false,
    request_uri_parameter_supported: true,
    require_request_uri_registration: false,
    response_modes_supported: [
        "query",
        "fragment"
    ],
    token_endpoint_auth_methods_supported: [
        "client_secret_basic"
    ]
};
class Issuer {
    #metadata;
    constructor(meta = {}){
        const aadIssValidation = meta[AAD_MULTITENANT];
        delete meta[AAD_MULTITENANT];
        [
            "introspection",
            "revocation"
        ].forEach((endpoint)=>{
            // if intro/revocation endpoint auth specific meta is missing use the token ones if they
            // are defined
            if (meta[`${endpoint}_endpoint`] && meta[`${endpoint}_endpoint_auth_methods_supported`] === undefined && meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] === undefined) {
                if (meta.token_endpoint_auth_methods_supported) {
                    meta[`${endpoint}_endpoint_auth_methods_supported`] = meta.token_endpoint_auth_methods_supported;
                }
                if (meta.token_endpoint_auth_signing_alg_values_supported) {
                    meta[`${endpoint}_endpoint_auth_signing_alg_values_supported`] = meta.token_endpoint_auth_signing_alg_values_supported;
                }
            }
        });
        this.#metadata = new Map();
        Object.entries(meta).forEach(([key, value])=>{
            this.#metadata.set(key, value);
            if (!this[key]) {
                Object.defineProperty(this, key, {
                    get () {
                        return this.#metadata.get(key);
                    },
                    enumerable: true
                });
            }
        });
        registry.set(this.issuer, this);
        const Client = getClient(this, aadIssValidation);
        Object.defineProperties(this, {
            Client: {
                value: Client,
                enumerable: true
            },
            FAPI1Client: {
                value: class FAPI1Client extends Client {
                },
                enumerable: true
            }
        });
    }
    get metadata() {
        return clone(Object.fromEntries(this.#metadata.entries()));
    }
    static async webfinger(input) {
        const resource = webfingerNormalize(input);
        const { host } = url.parse(resource);
        const webfingerUrl = `https://${host}/.well-known/webfinger`;
        const response = await request.call(this, {
            method: "GET",
            url: webfingerUrl,
            responseType: "json",
            searchParams: {
                resource,
                rel: "http://openid.net/specs/connect/1.0/issuer"
            },
            headers: {
                Accept: "application/json"
            }
        });
        const body = processResponse(response);
        const location = Array.isArray(body.links) && body.links.find((link)=>typeof link === "object" && link.rel === "http://openid.net/specs/connect/1.0/issuer" && link.href);
        if (!location) {
            throw new RPError({
                message: "no issuer found in webfinger response",
                body
            });
        }
        if (typeof location.href !== "string" || !location.href.startsWith("https://")) {
            throw new RPError({
                printf: [
                    "invalid issuer location %s",
                    location.href
                ],
                body
            });
        }
        const expectedIssuer = location.href;
        if (registry.has(expectedIssuer)) {
            return registry.get(expectedIssuer);
        }
        const issuer = await this.discover(expectedIssuer);
        if (issuer.issuer !== expectedIssuer) {
            registry.del(issuer.issuer);
            throw new RPError("discovered issuer mismatch, expected %s, got: %s", expectedIssuer, issuer.issuer);
        }
        return issuer;
    }
    static async discover(uri) {
        const parsed = url.parse(uri);
        if (parsed.pathname.includes("/.well-known/")) {
            const response = await request.call(this, {
                method: "GET",
                responseType: "json",
                url: uri,
                headers: {
                    Accept: "application/json"
                }
            });
            const body = processResponse(response);
            return new Issuer({
                ...ISSUER_DEFAULTS,
                ...body,
                [AAD_MULTITENANT]: !!AAD_MULTITENANT_DISCOVERY.find((discoveryURL)=>uri.startsWith(discoveryURL))
            });
        }
        let pathname;
        if (parsed.pathname.endsWith("/")) {
            pathname = `${parsed.pathname}.well-known/openid-configuration`;
        } else {
            pathname = `${parsed.pathname}/.well-known/openid-configuration`;
        }
        const wellKnownUri = url.format({
            ...parsed,
            pathname
        });
        const response = await request.call(this, {
            method: "GET",
            responseType: "json",
            url: wellKnownUri,
            headers: {
                Accept: "application/json"
            }
        });
        const body = processResponse(response);
        return new Issuer({
            ...ISSUER_DEFAULTS,
            ...body,
            [AAD_MULTITENANT]: !!AAD_MULTITENANT_DISCOVERY.find((discoveryURL)=>wellKnownUri.startsWith(discoveryURL))
        });
    }
    async reloadJwksUri() {
        await keystore.call(this, true);
    }
    /* istanbul ignore next */ [inspect.custom]() {
        return `${this.constructor.name} ${inspect(this.metadata, {
            depth: Infinity,
            colors: process.stdout.isTTY,
            compact: false,
            sorted: true
        })}`;
    }
}
module.exports = Issuer;


/***/ }),

/***/ 34498:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const LRU = __webpack_require__(96442);
module.exports = new LRU({
    max: 100
});


/***/ }),

/***/ 92186:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const url = __webpack_require__(57310);
const { format } = __webpack_require__(73837);
const cloneDeep = __webpack_require__(66306);
const { RPError, OPError } = __webpack_require__(28687);
const { BaseClient } = __webpack_require__(88273);
const { random, codeChallenge } = __webpack_require__(20356);
const pick = __webpack_require__(48852);
const { resolveResponseType, resolveRedirectUri } = __webpack_require__(61930);
function verified(err, user, info = {}) {
    if (err) {
        this.error(err);
    } else if (!user) {
        this.fail(info);
    } else {
        this.success(user, info);
    }
}
function OpenIDConnectStrategy({ client, params = {}, passReqToCallback = false, sessionKey, usePKCE = true, extras = {} } = {}, verify) {
    if (!(client instanceof BaseClient)) {
        throw new TypeError("client must be an instance of openid-client Client");
    }
    if (typeof verify !== "function") {
        throw new TypeError("verify callback must be a function");
    }
    if (!client.issuer || !client.issuer.issuer) {
        throw new TypeError("client must have an issuer with an identifier");
    }
    this._client = client;
    this._issuer = client.issuer;
    this._verify = verify;
    this._passReqToCallback = passReqToCallback;
    this._usePKCE = usePKCE;
    this._key = sessionKey || `oidc:${url.parse(this._issuer.issuer).hostname}`;
    this._params = cloneDeep(params);
    // state and nonce are handled in authenticate()
    delete this._params.state;
    delete this._params.nonce;
    this._extras = cloneDeep(extras);
    if (!this._params.response_type) this._params.response_type = resolveResponseType.call(client);
    if (!this._params.redirect_uri) this._params.redirect_uri = resolveRedirectUri.call(client);
    if (!this._params.scope) this._params.scope = "openid";
    if (this._usePKCE === true) {
        const supportedMethods = Array.isArray(this._issuer.code_challenge_methods_supported) ? this._issuer.code_challenge_methods_supported : false;
        if (supportedMethods && supportedMethods.includes("S256")) {
            this._usePKCE = "S256";
        } else if (supportedMethods && supportedMethods.includes("plain")) {
            this._usePKCE = "plain";
        } else if (supportedMethods) {
            throw new TypeError("neither code_challenge_method supported by the client is supported by the issuer");
        } else {
            this._usePKCE = "S256";
        }
    } else if (typeof this._usePKCE === "string" && ![
        "plain",
        "S256"
    ].includes(this._usePKCE)) {
        throw new TypeError(`${this._usePKCE} is not valid/implemented PKCE code_challenge_method`);
    }
    this.name = url.parse(client.issuer.issuer).hostname;
}
OpenIDConnectStrategy.prototype.authenticate = function authenticate(req, options) {
    (async ()=>{
        const client = this._client;
        if (!req.session) {
            throw new TypeError("authentication requires session support");
        }
        const reqParams = client.callbackParams(req);
        const sessionKey = this._key;
        const { 0: parameter, length } = Object.keys(reqParams);
        /**
     * Start authentication request if this has no authorization response parameters or
     * this might a login initiated from a third party as per
     * https://openid.net/specs/openid-connect-core-1_0.html#ThirdPartyInitiatedLogin.
     */ if (length === 0 || length === 1 && parameter === "iss") {
            // provide options object with extra authentication parameters
            const params = {
                state: random(),
                ...this._params,
                ...options
            };
            if (!params.nonce && params.response_type.includes("id_token")) {
                params.nonce = random();
            }
            req.session[sessionKey] = pick(params, "nonce", "state", "max_age", "response_type");
            if (this._usePKCE && params.response_type.includes("code")) {
                const verifier = random();
                req.session[sessionKey].code_verifier = verifier;
                switch(this._usePKCE){
                    case "S256":
                        params.code_challenge = codeChallenge(verifier);
                        params.code_challenge_method = "S256";
                        break;
                    case "plain":
                        params.code_challenge = verifier;
                        break;
                }
            }
            this.redirect(client.authorizationUrl(params));
            return;
        }
        /* end authentication request */ /* start authentication response */ const session = req.session[sessionKey];
        if (Object.keys(session || {}).length === 0) {
            throw new Error(format('did not find expected authorization request details in session, req.session["%s"] is %j', sessionKey, session));
        }
        const { state, nonce, max_age: maxAge, code_verifier: codeVerifier, response_type: responseType } = session;
        try {
            delete req.session[sessionKey];
        } catch (err) {}
        const opts = {
            redirect_uri: this._params.redirect_uri,
            ...options
        };
        const checks = {
            state,
            nonce,
            max_age: maxAge,
            code_verifier: codeVerifier,
            response_type: responseType
        };
        const tokenset = await client.callback(opts.redirect_uri, reqParams, checks, this._extras);
        const passReq = this._passReqToCallback;
        const loadUserinfo = this._verify.length > (passReq ? 3 : 2) && client.issuer.userinfo_endpoint;
        const args = [
            tokenset,
            verified.bind(this)
        ];
        if (loadUserinfo) {
            if (!tokenset.access_token) {
                throw new RPError({
                    message: "expected access_token to be returned when asking for userinfo in verify callback",
                    tokenset
                });
            }
            const userinfo = await client.userinfo(tokenset);
            args.splice(1, 0, userinfo);
        }
        if (passReq) {
            args.unshift(req);
        }
        this._verify(...args);
    /* end authentication response */ })().catch((error)=>{
        if (error instanceof OPError && error.error !== "server_error" && !error.error.startsWith("invalid") || error instanceof RPError) {
            this.fail(error);
        } else {
            this.error(error);
        }
    });
};
module.exports = OpenIDConnectStrategy;


/***/ }),

/***/ 90224:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

const base64url = __webpack_require__(86361);
const now = __webpack_require__(75031);
class TokenSet {
    constructor(values){
        Object.assign(this, values);
        const { constructor, ...properties } = Object.getOwnPropertyDescriptors(this.constructor.prototype);
        Object.defineProperties(this, properties);
    }
    set expires_in(value) {
        this.expires_at = now() + Number(value);
    }
    get expires_in() {
        return Math.max.apply(null, [
            this.expires_at - now(),
            0
        ]);
    }
    expired() {
        return this.expires_in === 0;
    }
    claims() {
        if (!this.id_token) {
            throw new TypeError("id_token not present in TokenSet");
        }
        return JSON.parse(base64url.decode(this.id_token.split(".")[1]));
    }
}
module.exports = TokenSet;


/***/ }),

/***/ 96442:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

// A linked list to keep track of recently-used-ness
const Yallist = __webpack_require__(48242);
const MAX = Symbol("max");
const LENGTH = Symbol("length");
const LENGTH_CALCULATOR = Symbol("lengthCalculator");
const ALLOW_STALE = Symbol("allowStale");
const MAX_AGE = Symbol("maxAge");
const DISPOSE = Symbol("dispose");
const NO_DISPOSE_ON_SET = Symbol("noDisposeOnSet");
const LRU_LIST = Symbol("lruList");
const CACHE = Symbol("cache");
const UPDATE_AGE_ON_GET = Symbol("updateAgeOnGet");
const naiveLength = ()=>1;
// lruList is a yallist where the head is the youngest
// item, and the tail is the oldest.  the list contains the Hit
// objects as the entries.
// Each Hit object has a reference to its Yallist.Node.  This
// never changes.
//
// cache is a Map (or PseudoMap) that matches the keys to
// the Yallist.Node object.
class LRUCache {
    constructor(options){
        if (typeof options === "number") options = {
            max: options
        };
        if (!options) options = {};
        if (options.max && (typeof options.max !== "number" || options.max < 0)) throw new TypeError("max must be a non-negative number");
        // Kind of weird to have a default max of Infinity, but oh well.
        const max = this[MAX] = options.max || Infinity;
        const lc = options.length || naiveLength;
        this[LENGTH_CALCULATOR] = typeof lc !== "function" ? naiveLength : lc;
        this[ALLOW_STALE] = options.stale || false;
        if (options.maxAge && typeof options.maxAge !== "number") throw new TypeError("maxAge must be a number");
        this[MAX_AGE] = options.maxAge || 0;
        this[DISPOSE] = options.dispose;
        this[NO_DISPOSE_ON_SET] = options.noDisposeOnSet || false;
        this[UPDATE_AGE_ON_GET] = options.updateAgeOnGet || false;
        this.reset();
    }
    // resize the cache when the max changes.
    set max(mL) {
        if (typeof mL !== "number" || mL < 0) throw new TypeError("max must be a non-negative number");
        this[MAX] = mL || Infinity;
        trim(this);
    }
    get max() {
        return this[MAX];
    }
    set allowStale(allowStale) {
        this[ALLOW_STALE] = !!allowStale;
    }
    get allowStale() {
        return this[ALLOW_STALE];
    }
    set maxAge(mA) {
        if (typeof mA !== "number") throw new TypeError("maxAge must be a non-negative number");
        this[MAX_AGE] = mA;
        trim(this);
    }
    get maxAge() {
        return this[MAX_AGE];
    }
    // resize the cache when the lengthCalculator changes.
    set lengthCalculator(lC) {
        if (typeof lC !== "function") lC = naiveLength;
        if (lC !== this[LENGTH_CALCULATOR]) {
            this[LENGTH_CALCULATOR] = lC;
            this[LENGTH] = 0;
            this[LRU_LIST].forEach((hit)=>{
                hit.length = this[LENGTH_CALCULATOR](hit.value, hit.key);
                this[LENGTH] += hit.length;
            });
        }
        trim(this);
    }
    get lengthCalculator() {
        return this[LENGTH_CALCULATOR];
    }
    get length() {
        return this[LENGTH];
    }
    get itemCount() {
        return this[LRU_LIST].length;
    }
    rforEach(fn, thisp) {
        thisp = thisp || this;
        for(let walker = this[LRU_LIST].tail; walker !== null;){
            const prev = walker.prev;
            forEachStep(this, fn, walker, thisp);
            walker = prev;
        }
    }
    forEach(fn, thisp) {
        thisp = thisp || this;
        for(let walker = this[LRU_LIST].head; walker !== null;){
            const next = walker.next;
            forEachStep(this, fn, walker, thisp);
            walker = next;
        }
    }
    keys() {
        return this[LRU_LIST].toArray().map((k)=>k.key);
    }
    values() {
        return this[LRU_LIST].toArray().map((k)=>k.value);
    }
    reset() {
        if (this[DISPOSE] && this[LRU_LIST] && this[LRU_LIST].length) {
            this[LRU_LIST].forEach((hit)=>this[DISPOSE](hit.key, hit.value));
        }
        this[CACHE] = new Map() // hash of items by key
        ;
        this[LRU_LIST] = new Yallist() // list of items in order of use recency
        ;
        this[LENGTH] = 0 // length of items in the list
        ;
    }
    dump() {
        return this[LRU_LIST].map((hit)=>isStale(this, hit) ? false : {
                k: hit.key,
                v: hit.value,
                e: hit.now + (hit.maxAge || 0)
            }).toArray().filter((h)=>h);
    }
    dumpLru() {
        return this[LRU_LIST];
    }
    set(key, value, maxAge) {
        maxAge = maxAge || this[MAX_AGE];
        if (maxAge && typeof maxAge !== "number") throw new TypeError("maxAge must be a number");
        const now = maxAge ? Date.now() : 0;
        const len = this[LENGTH_CALCULATOR](value, key);
        if (this[CACHE].has(key)) {
            if (len > this[MAX]) {
                del(this, this[CACHE].get(key));
                return false;
            }
            const node = this[CACHE].get(key);
            const item = node.value;
            // dispose of the old one before overwriting
            // split out into 2 ifs for better coverage tracking
            if (this[DISPOSE]) {
                if (!this[NO_DISPOSE_ON_SET]) this[DISPOSE](key, item.value);
            }
            item.now = now;
            item.maxAge = maxAge;
            item.value = value;
            this[LENGTH] += len - item.length;
            item.length = len;
            this.get(key);
            trim(this);
            return true;
        }
        const hit = new Entry(key, value, len, now, maxAge);
        // oversized objects fall out of cache automatically.
        if (hit.length > this[MAX]) {
            if (this[DISPOSE]) this[DISPOSE](key, value);
            return false;
        }
        this[LENGTH] += hit.length;
        this[LRU_LIST].unshift(hit);
        this[CACHE].set(key, this[LRU_LIST].head);
        trim(this);
        return true;
    }
    has(key) {
        if (!this[CACHE].has(key)) return false;
        const hit = this[CACHE].get(key).value;
        return !isStale(this, hit);
    }
    get(key) {
        return get(this, key, true);
    }
    peek(key) {
        return get(this, key, false);
    }
    pop() {
        const node = this[LRU_LIST].tail;
        if (!node) return null;
        del(this, node);
        return node.value;
    }
    del(key) {
        del(this, this[CACHE].get(key));
    }
    load(arr) {
        // reset the cache
        this.reset();
        const now = Date.now();
        // A previous serialized cache has the most recent items first
        for(let l = arr.length - 1; l >= 0; l--){
            const hit = arr[l];
            const expiresAt = hit.e || 0;
            if (expiresAt === 0) // the item was created without expiration in a non aged cache
            this.set(hit.k, hit.v);
            else {
                const maxAge = expiresAt - now;
                // dont add already expired items
                if (maxAge > 0) {
                    this.set(hit.k, hit.v, maxAge);
                }
            }
        }
    }
    prune() {
        this[CACHE].forEach((value, key)=>get(this, key, false));
    }
}
const get = (self, key, doUse)=>{
    const node = self[CACHE].get(key);
    if (node) {
        const hit = node.value;
        if (isStale(self, hit)) {
            del(self, node);
            if (!self[ALLOW_STALE]) return undefined;
        } else {
            if (doUse) {
                if (self[UPDATE_AGE_ON_GET]) node.value.now = Date.now();
                self[LRU_LIST].unshiftNode(node);
            }
        }
        return hit.value;
    }
};
const isStale = (self, hit)=>{
    if (!hit || !hit.maxAge && !self[MAX_AGE]) return false;
    const diff = Date.now() - hit.now;
    return hit.maxAge ? diff > hit.maxAge : self[MAX_AGE] && diff > self[MAX_AGE];
};
const trim = (self)=>{
    if (self[LENGTH] > self[MAX]) {
        for(let walker = self[LRU_LIST].tail; self[LENGTH] > self[MAX] && walker !== null;){
            // We know that we're about to delete this one, and also
            // what the next least recently used key will be, so just
            // go ahead and set it now.
            const prev = walker.prev;
            del(self, walker);
            walker = prev;
        }
    }
};
const del = (self, node)=>{
    if (node) {
        const hit = node.value;
        if (self[DISPOSE]) self[DISPOSE](hit.key, hit.value);
        self[LENGTH] -= hit.length;
        self[CACHE].delete(hit.key);
        self[LRU_LIST].removeNode(node);
    }
};
class Entry {
    constructor(key, value, length, now, maxAge){
        this.key = key;
        this.value = value;
        this.length = length;
        this.now = now;
        this.maxAge = maxAge || 0;
    }
}
const forEachStep = (self, fn, node, thisp)=>{
    let hit = node.value;
    if (isStale(self, hit)) {
        del(self, node);
        if (!self[ALLOW_STALE]) hit = undefined;
    }
    if (hit) fn.call(thisp, hit.value, hit.key, self);
};
module.exports = LRUCache;


/***/ }),

/***/ 97968:
/***/ ((module) => {

"use strict";

module.exports = function(Yallist) {
    Yallist.prototype[Symbol.iterator] = function*() {
        for(let walker = this.head; walker; walker = walker.next){
            yield walker.value;
        }
    };
};


/***/ }),

/***/ 48242:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = Yallist;
Yallist.Node = Node;
Yallist.create = Yallist;
function Yallist(list) {
    var self = this;
    if (!(self instanceof Yallist)) {
        self = new Yallist();
    }
    self.tail = null;
    self.head = null;
    self.length = 0;
    if (list && typeof list.forEach === "function") {
        list.forEach(function(item) {
            self.push(item);
        });
    } else if (arguments.length > 0) {
        for(var i = 0, l = arguments.length; i < l; i++){
            self.push(arguments[i]);
        }
    }
    return self;
}
Yallist.prototype.removeNode = function(node) {
    if (node.list !== this) {
        throw new Error("removing node which does not belong to this list");
    }
    var next = node.next;
    var prev = node.prev;
    if (next) {
        next.prev = prev;
    }
    if (prev) {
        prev.next = next;
    }
    if (node === this.head) {
        this.head = next;
    }
    if (node === this.tail) {
        this.tail = prev;
    }
    node.list.length--;
    node.next = null;
    node.prev = null;
    node.list = null;
    return next;
};
Yallist.prototype.unshiftNode = function(node) {
    if (node === this.head) {
        return;
    }
    if (node.list) {
        node.list.removeNode(node);
    }
    var head = this.head;
    node.list = this;
    node.next = head;
    if (head) {
        head.prev = node;
    }
    this.head = node;
    if (!this.tail) {
        this.tail = node;
    }
    this.length++;
};
Yallist.prototype.pushNode = function(node) {
    if (node === this.tail) {
        return;
    }
    if (node.list) {
        node.list.removeNode(node);
    }
    var tail = this.tail;
    node.list = this;
    node.prev = tail;
    if (tail) {
        tail.next = node;
    }
    this.tail = node;
    if (!this.head) {
        this.head = node;
    }
    this.length++;
};
Yallist.prototype.push = function() {
    for(var i = 0, l = arguments.length; i < l; i++){
        push(this, arguments[i]);
    }
    return this.length;
};
Yallist.prototype.unshift = function() {
    for(var i = 0, l = arguments.length; i < l; i++){
        unshift(this, arguments[i]);
    }
    return this.length;
};
Yallist.prototype.pop = function() {
    if (!this.tail) {
        return undefined;
    }
    var res = this.tail.value;
    this.tail = this.tail.prev;
    if (this.tail) {
        this.tail.next = null;
    } else {
        this.head = null;
    }
    this.length--;
    return res;
};
Yallist.prototype.shift = function() {
    if (!this.head) {
        return undefined;
    }
    var res = this.head.value;
    this.head = this.head.next;
    if (this.head) {
        this.head.prev = null;
    } else {
        this.tail = null;
    }
    this.length--;
    return res;
};
Yallist.prototype.forEach = function(fn, thisp) {
    thisp = thisp || this;
    for(var walker = this.head, i = 0; walker !== null; i++){
        fn.call(thisp, walker.value, i, this);
        walker = walker.next;
    }
};
Yallist.prototype.forEachReverse = function(fn, thisp) {
    thisp = thisp || this;
    for(var walker = this.tail, i = this.length - 1; walker !== null; i--){
        fn.call(thisp, walker.value, i, this);
        walker = walker.prev;
    }
};
Yallist.prototype.get = function(n) {
    for(var i = 0, walker = this.head; walker !== null && i < n; i++){
        // abort out of the list early if we hit a cycle
        walker = walker.next;
    }
    if (i === n && walker !== null) {
        return walker.value;
    }
};
Yallist.prototype.getReverse = function(n) {
    for(var i = 0, walker = this.tail; walker !== null && i < n; i++){
        // abort out of the list early if we hit a cycle
        walker = walker.prev;
    }
    if (i === n && walker !== null) {
        return walker.value;
    }
};
Yallist.prototype.map = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for(var walker = this.head; walker !== null;){
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.next;
    }
    return res;
};
Yallist.prototype.mapReverse = function(fn, thisp) {
    thisp = thisp || this;
    var res = new Yallist();
    for(var walker = this.tail; walker !== null;){
        res.push(fn.call(thisp, walker.value, this));
        walker = walker.prev;
    }
    return res;
};
Yallist.prototype.reduce = function(fn, initial) {
    var acc;
    var walker = this.head;
    if (arguments.length > 1) {
        acc = initial;
    } else if (this.head) {
        walker = this.head.next;
        acc = this.head.value;
    } else {
        throw new TypeError("Reduce of empty list with no initial value");
    }
    for(var i = 0; walker !== null; i++){
        acc = fn(acc, walker.value, i);
        walker = walker.next;
    }
    return acc;
};
Yallist.prototype.reduceReverse = function(fn, initial) {
    var acc;
    var walker = this.tail;
    if (arguments.length > 1) {
        acc = initial;
    } else if (this.tail) {
        walker = this.tail.prev;
        acc = this.tail.value;
    } else {
        throw new TypeError("Reduce of empty list with no initial value");
    }
    for(var i = this.length - 1; walker !== null; i--){
        acc = fn(acc, walker.value, i);
        walker = walker.prev;
    }
    return acc;
};
Yallist.prototype.toArray = function() {
    var arr = new Array(this.length);
    for(var i = 0, walker = this.head; walker !== null; i++){
        arr[i] = walker.value;
        walker = walker.next;
    }
    return arr;
};
Yallist.prototype.toArrayReverse = function() {
    var arr = new Array(this.length);
    for(var i = 0, walker = this.tail; walker !== null; i++){
        arr[i] = walker.value;
        walker = walker.prev;
    }
    return arr;
};
Yallist.prototype.slice = function(from, to) {
    to = to || this.length;
    if (to < 0) {
        to += this.length;
    }
    from = from || 0;
    if (from < 0) {
        from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
        return ret;
    }
    if (from < 0) {
        from = 0;
    }
    if (to > this.length) {
        to = this.length;
    }
    for(var i = 0, walker = this.head; walker !== null && i < from; i++){
        walker = walker.next;
    }
    for(; walker !== null && i < to; i++, walker = walker.next){
        ret.push(walker.value);
    }
    return ret;
};
Yallist.prototype.sliceReverse = function(from, to) {
    to = to || this.length;
    if (to < 0) {
        to += this.length;
    }
    from = from || 0;
    if (from < 0) {
        from += this.length;
    }
    var ret = new Yallist();
    if (to < from || to < 0) {
        return ret;
    }
    if (from < 0) {
        from = 0;
    }
    if (to > this.length) {
        to = this.length;
    }
    for(var i = this.length, walker = this.tail; walker !== null && i > to; i--){
        walker = walker.prev;
    }
    for(; walker !== null && i > from; i--, walker = walker.prev){
        ret.push(walker.value);
    }
    return ret;
};
Yallist.prototype.splice = function(start, deleteCount, ...nodes) {
    if (start > this.length) {
        start = this.length - 1;
    }
    if (start < 0) {
        start = this.length + start;
    }
    for(var i = 0, walker = this.head; walker !== null && i < start; i++){
        walker = walker.next;
    }
    var ret = [];
    for(var i = 0; walker && i < deleteCount; i++){
        ret.push(walker.value);
        walker = this.removeNode(walker);
    }
    if (walker === null) {
        walker = this.tail;
    }
    if (walker !== this.head && walker !== this.tail) {
        walker = walker.prev;
    }
    for(var i = 0; i < nodes.length; i++){
        walker = insert(this, walker, nodes[i]);
    }
    return ret;
};
Yallist.prototype.reverse = function() {
    var head = this.head;
    var tail = this.tail;
    for(var walker = head; walker !== null; walker = walker.prev){
        var p = walker.prev;
        walker.prev = walker.next;
        walker.next = p;
    }
    this.head = tail;
    this.tail = head;
    return this;
};
function insert(self, node, value) {
    var inserted = node === self.head ? new Node(value, null, node, self) : new Node(value, node, node.next, self);
    if (inserted.next === null) {
        self.tail = inserted;
    }
    if (inserted.prev === null) {
        self.head = inserted;
    }
    self.length++;
    return inserted;
}
function push(self, item) {
    self.tail = new Node(item, self.tail, null, self);
    if (!self.head) {
        self.head = self.tail;
    }
    self.length++;
}
function unshift(self, item) {
    self.head = new Node(item, null, self.head, self);
    if (!self.tail) {
        self.tail = self.head;
    }
    self.length++;
}
function Node(value, prev, next, list) {
    if (!(this instanceof Node)) {
        return new Node(value, prev, next, list);
    }
    this.list = list;
    this.value = value;
    if (prev) {
        prev.next = this;
        this.prev = prev;
    } else {
        this.prev = null;
    }
    if (next) {
        next.prev = this;
        this.next = next;
    } else {
        this.next = null;
    }
}
try {
    // add if support for Symbol.iterator is present
    __webpack_require__(97968)(Yallist);
} catch (er) {}


/***/ }),

/***/ 94567:
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

!function(e, t) {
     true ? t(exports, __webpack_require__(41405)) : 0;
}(this, function(e, t) {
    var n = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|^--/i, r = /^(area|base|br|col|embed|hr|img|input|link|meta|param|source|track|wbr)$/, o = /[\s\n\\/='"\0<>]/, i = /^xlink:?./, s = /["&<]/;
    function a(e) {
        if (!1 === s.test(e += "")) return e;
        for(var t = 0, n = 0, r = "", o = ""; n < e.length; n++){
            switch(e.charCodeAt(n)){
                case 34:
                    o = "&quot;";
                    break;
                case 38:
                    o = "&amp;";
                    break;
                case 60:
                    o = "&lt;";
                    break;
                default:
                    continue;
            }
            n !== t && (r += e.slice(t, n)), r += o, t = n + 1;
        }
        return n !== t && (r += e.slice(t, n)), r;
    }
    var l = function(e, t) {
        return String(e).replace(/(\n+)/g, "$1" + (t || "	"));
    }, f = function(e, t, n) {
        return String(e).length > (t || 40) || !n && -1 !== String(e).indexOf("\n") || -1 !== String(e).indexOf("<");
    }, u = {}, p = /([A-Z])/g;
    function c(e) {
        var t = "";
        for(var r in e){
            var o = e[r];
            null != o && "" !== o && (t && (t += " "), t += "-" == r[0] ? r : u[r] || (u[r] = r.replace(p, "-$1").toLowerCase()), t = "number" == typeof o && !1 === n.test(r) ? t + ": " + o + "px;" : t + ": " + o + ";");
        }
        return t || void 0;
    }
    function _(e, t) {
        return Array.isArray(t) ? t.reduce(_, e) : null != t && !1 !== t && e.push(t), e;
    }
    function d() {
        this.__d = !0;
    }
    function v(e, t) {
        return {
            __v: e,
            context: t,
            props: e.props,
            setState: d,
            forceUpdate: d,
            __d: !0,
            __h: []
        };
    }
    function g(e, t) {
        var n = e.contextType, r = n && t[n.__c];
        return null != n ? r ? r.props.value : n.__ : t;
    }
    var h = [];
    function y(e, n, s, u, p, d) {
        if (null == e || "boolean" == typeof e) return "";
        if ("object" != typeof e) return "function" == typeof e ? "" : a(e);
        var m = s.pretty, b = m && "string" == typeof m ? m : "	";
        if (Array.isArray(e)) {
            for(var x = "", k = 0; k < e.length; k++)m && k > 0 && (x += "\n"), x += y(e[k], n, s, u, p, d);
            return x;
        }
        if (void 0 !== e.constructor) return "";
        var S, w = e.type, C = e.props, O = !1;
        if ("function" == typeof w) {
            if (O = !0, !s.shallow || !u && !1 !== s.renderRootComponent) {
                if (w === t.Fragment) {
                    var j = [];
                    return _(j, e.props.children), y(j, n, s, !1 !== s.shallowHighOrder, p, d);
                }
                var F, A = e.__c = v(e, n);
                t.options.__b && t.options.__b(e);
                var T = t.options.__r;
                if (w.prototype && "function" == typeof w.prototype.render) {
                    var H = g(w, n);
                    (A = e.__c = new w(C, H)).__v = e, A._dirty = A.__d = !0, A.props = C, null == A.state && (A.state = {}), null == A._nextState && null == A.__s && (A._nextState = A.__s = A.state), A.context = H, w.getDerivedStateFromProps ? A.state = Object.assign({}, A.state, w.getDerivedStateFromProps(A.props, A.state)) : A.componentWillMount && (A.componentWillMount(), A.state = A._nextState !== A.state ? A._nextState : A.__s !== A.state ? A.__s : A.state), T && T(e), F = A.render(A.props, A.state, A.context);
                } else for(var M = g(w, n), L = 0; A.__d && L++ < 25;)A.__d = !1, T && T(e), F = w.call(e.__c, C, M);
                return A.getChildContext && (n = Object.assign({}, n, A.getChildContext())), t.options.diffed && t.options.diffed(e), y(F, n, s, !1 !== s.shallowHighOrder, p, d);
            }
            w = (S = w).displayName || S !== Function && S.name || function(e) {
                var t = (Function.prototype.toString.call(e).match(/^\s*function\s+([^( ]+)/) || "")[1];
                if (!t) {
                    for(var n = -1, r = h.length; r--;)if (h[r] === e) {
                        n = r;
                        break;
                    }
                    n < 0 && (n = h.push(e) - 1), t = "UnnamedComponent" + n;
                }
                return t;
            }(S);
        }
        var E, $, D = "<" + w;
        if (C) {
            var N = Object.keys(C);
            s && !0 === s.sortAttributes && N.sort();
            for(var P = 0; P < N.length; P++){
                var R = N[P], W = C[R];
                if ("children" !== R) {
                    if (!o.test(R) && (s && s.allAttributes || "key" !== R && "ref" !== R && "__self" !== R && "__source" !== R)) {
                        if ("defaultValue" === R) R = "value";
                        else if ("defaultChecked" === R) R = "checked";
                        else if ("defaultSelected" === R) R = "selected";
                        else if ("className" === R) {
                            if (void 0 !== C.class) continue;
                            R = "class";
                        } else p && i.test(R) && (R = R.toLowerCase().replace(/^xlink:?/, "xlink:"));
                        if ("htmlFor" === R) {
                            if (C.for) continue;
                            R = "for";
                        }
                        "style" === R && W && "object" == typeof W && (W = c(W)), "a" === R[0] && "r" === R[1] && "boolean" == typeof W && (W = String(W));
                        var q = s.attributeHook && s.attributeHook(R, W, n, s, O);
                        if (q || "" === q) D += q;
                        else if ("dangerouslySetInnerHTML" === R) $ = W && W.__html;
                        else if ("textarea" === w && "value" === R) E = W;
                        else if ((W || 0 === W || "" === W) && "function" != typeof W) {
                            if (!(!0 !== W && "" !== W || (W = R, s && s.xml))) {
                                D = D + " " + R;
                                continue;
                            }
                            if ("value" === R) {
                                if ("select" === w) {
                                    d = W;
                                    continue;
                                }
                                "option" === w && d == W && void 0 === C.selected && (D += " selected");
                            }
                            D = D + " " + R + '="' + a(W) + '"';
                        }
                    }
                } else E = W;
            }
        }
        if (m) {
            var I = D.replace(/\n\s*/, " ");
            I === D || ~I.indexOf("\n") ? m && ~D.indexOf("\n") && (D += "\n") : D = I;
        }
        if (D += ">", o.test(w)) throw new Error(w + " is not a valid HTML tag name in " + D);
        var U, V = r.test(w) || s.voidElements && s.voidElements.test(w), z = [];
        if ($) m && f($) && ($ = "\n" + b + l($, b)), D += $;
        else if (null != E && _(U = [], E).length) {
            for(var Z = m && ~D.indexOf("\n"), B = !1, G = 0; G < U.length; G++){
                var J = U[G];
                if (null != J && !1 !== J) {
                    var K = y(J, n, s, !0, "svg" === w || "foreignObject" !== w && p, d);
                    if (m && !Z && f(K) && (Z = !0), K) if (m) {
                        var Q = K.length > 0 && "<" != K[0];
                        B && Q ? z[z.length - 1] += K : z.push(K), B = Q;
                    } else z.push(K);
                }
            }
            if (m && Z) for(var X = z.length; X--;)z[X] = "\n" + b + l(z[X], b);
        }
        if (z.length || $) D += z.join("");
        else if (s && s.xml) return D.substring(0, D.length - 1) + " />";
        return !V || U || $ ? (m && ~D.indexOf("\n") && (D += "\n"), D = D + "</" + w + ">") : D = D.replace(/>$/, " />"), D;
    }
    var m = {
        shallow: !0
    };
    k.render = k;
    var b = function(e, t) {
        return k(e, t, m);
    }, x = [];
    function k(e, n, r) {
        n = n || {};
        var o = t.options.__s;
        t.options.__s = !0;
        var i, s = t.h(t.Fragment, null);
        return s.__k = [
            e
        ], i = r && (r.pretty || r.voidElements || r.sortAttributes || r.shallow || r.allAttributes || r.xml || r.attributeHook) ? y(e, n, r) : F(e, n, !1, void 0, s), t.options.__c && t.options.__c(e, x), t.options.__s = o, x.length = 0, i;
    }
    function S(e) {
        return null == e || "boolean" == typeof e ? null : "string" == typeof e || "number" == typeof e || "bigint" == typeof e ? t.h(null, null, e) : e;
    }
    function w(e, t) {
        return "className" === e ? "class" : "htmlFor" === e ? "for" : "defaultValue" === e ? "value" : "defaultChecked" === e ? "checked" : "defaultSelected" === e ? "selected" : t && i.test(e) ? e.toLowerCase().replace(/^xlink:?/, "xlink:") : e;
    }
    function C(e, t) {
        return "style" === e && null != t && "object" == typeof t ? c(t) : "a" === e[0] && "r" === e[1] && "boolean" == typeof t ? String(t) : t;
    }
    var O = Array.isArray, j = Object.assign;
    function F(e, n, i, s, l) {
        if (null == e || !0 === e || !1 === e || "" === e) return "";
        if ("object" != typeof e) return "function" == typeof e ? "" : a(e);
        if (O(e)) {
            var f = "";
            l.__k = e;
            for(var u = 0; u < e.length; u++)f += F(e[u], n, i, s, l), e[u] = S(e[u]);
            return f;
        }
        if (void 0 !== e.constructor) return "";
        e.__ = l, t.options.__b && t.options.__b(e);
        var p = e.type, c = e.props;
        if ("function" == typeof p) {
            var _;
            if (p === t.Fragment) _ = c.children;
            else {
                _ = p.prototype && "function" == typeof p.prototype.render ? function(e, n) {
                    var r = e.type, o = g(r, n), i = new r(e.props, o);
                    e.__c = i, i.__v = e, i.__d = !0, i.props = e.props, null == i.state && (i.state = {}), null == i.__s && (i.__s = i.state), i.context = o, r.getDerivedStateFromProps ? i.state = j({}, i.state, r.getDerivedStateFromProps(i.props, i.state)) : i.componentWillMount && (i.componentWillMount(), i.state = i.__s !== i.state ? i.__s : i.state);
                    var s = t.options.__r;
                    return s && s(e), i.render(i.props, i.state, i.context);
                }(e, n) : function(e, n) {
                    var r, o = v(e, n), i = g(e.type, n);
                    e.__c = o;
                    for(var s = t.options.__r, a = 0; o.__d && a++ < 25;)o.__d = !1, s && s(e), r = e.type.call(o, e.props, i);
                    return r;
                }(e, n);
                var d = e.__c;
                d.getChildContext && (n = j({}, n, d.getChildContext()));
            }
            var h = F(_ = null != _ && _.type === t.Fragment && null == _.key ? _.props.children : _, n, i, s, e);
            return t.options.diffed && t.options.diffed(e), e.__ = void 0, t.options.unmount && t.options.unmount(e), h;
        }
        var y, m, b = "<";
        if (b += p, c) for(var x in y = c.children, c){
            var k = c[x];
            if (!("key" === x || "ref" === x || "__self" === x || "__source" === x || "children" === x || "className" === x && "class" in c || "htmlFor" === x && "for" in c || o.test(x))) {
                if (k = C(x = w(x, i), k), "dangerouslySetInnerHTML" === x) m = k && k.__html;
                else if ("textarea" === p && "value" === x) y = k;
                else if ((k || 0 === k || "" === k) && "function" != typeof k) {
                    if (!0 === k || "" === k) {
                        k = x, b = b + " " + x;
                        continue;
                    }
                    if ("value" === x) {
                        if ("select" === p) {
                            s = k;
                            continue;
                        }
                        "option" !== p || s != k || "selected" in c || (b += " selected");
                    }
                    b = b + " " + x + '="' + a(k) + '"';
                }
            }
        }
        var A = b;
        if (b += ">", o.test(p)) throw new Error(p + " is not a valid HTML tag name in " + b);
        var T = "", H = !1;
        if (m) T += m, H = !0;
        else if ("string" == typeof y) T += a(y), H = !0;
        else if (O(y)) {
            e.__k = y;
            for(var M = 0; M < y.length; M++){
                var L = y[M];
                if (y[M] = S(L), null != L && !1 !== L) {
                    var E = F(L, n, "svg" === p || "foreignObject" !== p && i, s, e);
                    E && (T += E, H = !0);
                }
            }
        } else if (null != y && !1 !== y && !0 !== y) {
            e.__k = [
                S(y)
            ];
            var $ = F(y, n, "svg" === p || "foreignObject" !== p && i, s, e);
            $ && (T += $, H = !0);
        }
        if (t.options.diffed && t.options.diffed(e), e.__ = void 0, t.options.unmount && t.options.unmount(e), H) b += T;
        else if (r.test(p)) return A + " />";
        return b + "</" + p + ">";
    }
    k.shallowRender = b, e.default = k, e.render = k, e.renderToStaticMarkup = k, e.renderToString = k, e.shallowRender = b;
}); //# sourceMappingURL=index.js.map


/***/ }),

/***/ 58568:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

module.exports = __webpack_require__(94567)["default"];


/***/ }),

/***/ 41405:
/***/ ((__unused_webpack_module, exports) => {

var n, l, u, t, i, o, r, f, e, c = {}, s = [], p = /acit|ex(?:s|g|n|p|$)|rph|grid|ows|mnc|ntw|ine[ch]|zoo|^ord|itera/i, a = Array.isArray;
function v(n, l) {
    for(var u in l)n[u] = l[u];
    return n;
}
function h(n) {
    var l = n.parentNode;
    l && l.removeChild(n);
}
function y(l, u, t) {
    var i, o, r, f = {};
    for(r in u)"key" == r ? i = u[r] : "ref" == r ? o = u[r] : f[r] = u[r];
    if (arguments.length > 2 && (f.children = arguments.length > 3 ? n.call(arguments, 2) : t), "function" == typeof l && null != l.defaultProps) for(r in l.defaultProps)void 0 === f[r] && (f[r] = l.defaultProps[r]);
    return d(l, f, i, o, null);
}
function d(n, t, i, o, r) {
    var f = {
        type: n,
        props: t,
        key: i,
        ref: o,
        __k: null,
        __: null,
        __b: 0,
        __e: null,
        __d: void 0,
        __c: null,
        __h: null,
        constructor: void 0,
        __v: null == r ? ++u : r
    };
    return null == r && null != l.vnode && l.vnode(f), f;
}
function _(n) {
    return n.children;
}
function x(n, l) {
    this.props = n, this.context = l;
}
function k(n, l) {
    if (null == l) return n.__ ? k(n.__, n.__.__k.indexOf(n) + 1) : null;
    for(var u; l < n.__k.length; l++)if (null != (u = n.__k[l]) && null != u.__e) return u.__e;
    return "function" == typeof n.type ? k(n) : null;
}
function b(n) {
    var l, u;
    if (null != (n = n.__) && null != n.__c) {
        for(n.__e = n.__c.base = null, l = 0; l < n.__k.length; l++)if (null != (u = n.__k[l]) && null != u.__e) {
            n.__e = n.__c.base = u.__e;
            break;
        }
        return b(n);
    }
}
function g(n) {
    (!n.__d && (n.__d = !0) && i.push(n) && !m.__r++ || o !== l.debounceRendering) && ((o = l.debounceRendering) || r)(m);
}
function m() {
    var n, l, u, t, o, r, e, c, s;
    for(i.sort(f); n = i.shift();)n.__d && (l = i.length, t = void 0, o = void 0, r = void 0, c = (e = (u = n).__v).__e, (s = u.__P) && (t = [], o = [], (r = v({}, e)).__v = e.__v + 1, j(s, e, r, u.__n, void 0 !== s.ownerSVGElement, null != e.__h ? [
        c
    ] : null, t, null == c ? k(e) : c, e.__h, o), z(t, e, o), e.__e != c && b(e)), i.length > l && i.sort(f));
    m.__r = 0;
}
function w(n, l, u, t, i, o, r, f, e, p, v) {
    var h, y, x, b, g, m, w, S, A, H = 0, I = t && t.__k || s, T = I.length, z = T, L = l.length;
    for(u.__k = [], h = 0; h < L; h++)null != (b = u.__k[h] = null == (b = l[h]) || "boolean" == typeof b || "function" == typeof b ? null : "string" == typeof b || "number" == typeof b || "bigint" == typeof b ? d(null, b, null, null, b) : a(b) ? d(_, {
        children: b
    }, null, null, null) : b.__b > 0 ? d(b.type, b.props, b.key, b.ref ? b.ref : null, b.__v) : b) ? (b.__ = u, b.__b = u.__b + 1, -1 === (S = C(b, I, w = h + H, z)) ? x = c : (x = I[S] || c, I[S] = void 0, z--), j(n, b, x, i, o, r, f, e, p, v), g = b.__e, (y = b.ref) && x.ref != y && (x.ref && M(x.ref, null, b), v.push(y, b.__c || g, b)), null != g && (null == m && (m = g), (A = x === c || null === x.__v) ? -1 == S && H-- : S !== w && (S === w + 1 ? H++ : S > w ? z > L - w ? H += S - w : H-- : H = S < w && S == w - 1 ? S - w : 0), w = h + H, "function" != typeof b.type || S === w && x.__k !== b.__k ? "function" == typeof b.type || S === w && !A ? void 0 !== b.__d ? (e = b.__d, b.__d = void 0) : e = g.nextSibling : e = $(n, g, e) : e = P(b, e, n), "function" == typeof u.type && (u.__d = e))) : (x = I[h]) && null == x.key && x.__e && (x.__e == e && (e = k(x)), N(x, x, !1), I[h] = null);
    for(u.__e = m, h = T; h--;)null != I[h] && ("function" == typeof u.type && null != I[h].__e && I[h].__e == u.__d && (u.__d = I[h].__e.nextSibling), N(I[h], I[h]));
}
function P(n, l, u) {
    for(var t, i = n.__k, o = 0; i && o < i.length; o++)(t = i[o]) && (t.__ = n, l = "function" == typeof t.type ? P(t, l, u) : $(u, t.__e, l));
    return l;
}
function $(n, l, u) {
    return null == u || u.parentNode !== n ? n.insertBefore(l, null) : l == u && null != l.parentNode || n.insertBefore(l, u), l.nextSibling;
}
function C(n, l, u, t) {
    var i = n.key, o = n.type, r = u - 1, f = u + 1, e = l[u];
    if (null === e || e && i == e.key && o === e.type) return u;
    if (t > (null != e ? 1 : 0)) for(; r >= 0 || f < l.length;){
        if (r >= 0) {
            if ((e = l[r]) && i == e.key && o === e.type) return r;
            r--;
        }
        if (f < l.length) {
            if ((e = l[f]) && i == e.key && o === e.type) return f;
            f++;
        }
    }
    return -1;
}
function S(n, l, u, t, i) {
    var o;
    for(o in u)"children" === o || "key" === o || o in l || H(n, o, null, u[o], t);
    for(o in l)i && "function" != typeof l[o] || "children" === o || "key" === o || "value" === o || "checked" === o || u[o] === l[o] || H(n, o, l[o], u[o], t);
}
function A(n, l, u) {
    "-" === l[0] ? n.setProperty(l, null == u ? "" : u) : n[l] = null == u ? "" : "number" != typeof u || p.test(l) ? u : u + "px";
}
function H(n, l, u, t, i) {
    var o;
    n: if ("style" === l) if ("string" == typeof u) n.style.cssText = u;
    else {
        if ("string" == typeof t && (n.style.cssText = t = ""), t) for(l in t)u && l in u || A(n.style, l, "");
        if (u) for(l in u)t && u[l] === t[l] || A(n.style, l, u[l]);
    }
    else if ("o" === l[0] && "n" === l[1]) o = l !== (l = l.replace(/(PointerCapture)$|Capture$/, "$1")), l = l.toLowerCase() in n ? l.toLowerCase().slice(2) : l.slice(2), n.l || (n.l = {}), n.l[l + o] = u, u ? t || n.addEventListener(l, o ? T : I, o) : n.removeEventListener(l, o ? T : I, o);
    else if ("dangerouslySetInnerHTML" !== l) {
        if (i) l = l.replace(/xlink(H|:h)/, "h").replace(/sName$/, "s");
        else if ("width" !== l && "height" !== l && "href" !== l && "list" !== l && "form" !== l && "tabIndex" !== l && "download" !== l && "rowSpan" !== l && "colSpan" !== l && l in n) try {
            n[l] = null == u ? "" : u;
            break n;
        } catch (n) {}
        "function" == typeof u || (null == u || !1 === u && "-" !== l[4] ? n.removeAttribute(l) : n.setAttribute(l, u));
    }
}
function I(n) {
    return this.l[n.type + !1](l.event ? l.event(n) : n);
}
function T(n) {
    return this.l[n.type + !0](l.event ? l.event(n) : n);
}
function j(n, u, t, i, o, r, f, e, c, s) {
    var p, h, y, d, k, b, g, m, P, $, C, S, A, H, I, T = u.type;
    if (void 0 !== u.constructor) return null;
    null != t.__h && (c = t.__h, e = u.__e = t.__e, u.__h = null, r = [
        e
    ]), (p = l.__b) && p(u);
    n: if ("function" == typeof T) try {
        if (m = u.props, P = (p = T.contextType) && i[p.__c], $ = p ? P ? P.props.value : p.__ : i, t.__c ? g = (h = u.__c = t.__c).__ = h.__E : ("prototype" in T && T.prototype.render ? u.__c = h = new T(m, $) : (u.__c = h = new x(m, $), h.constructor = T, h.render = O), P && P.sub(h), h.props = m, h.state || (h.state = {}), h.context = $, h.__n = i, y = h.__d = !0, h.__h = [], h._sb = []), null == h.__s && (h.__s = h.state), null != T.getDerivedStateFromProps && (h.__s == h.state && (h.__s = v({}, h.__s)), v(h.__s, T.getDerivedStateFromProps(m, h.__s))), d = h.props, k = h.state, h.__v = u, y) null == T.getDerivedStateFromProps && null != h.componentWillMount && h.componentWillMount(), null != h.componentDidMount && h.__h.push(h.componentDidMount);
        else {
            if (null == T.getDerivedStateFromProps && m !== d && null != h.componentWillReceiveProps && h.componentWillReceiveProps(m, $), !h.__e && (null != h.shouldComponentUpdate && !1 === h.shouldComponentUpdate(m, h.__s, $) || u.__v === t.__v)) {
                for(u.__v !== t.__v && (h.props = m, h.state = h.__s, h.__d = !1), u.__e = t.__e, u.__k = t.__k, u.__k.forEach(function(n) {
                    n && (n.__ = u);
                }), C = 0; C < h._sb.length; C++)h.__h.push(h._sb[C]);
                h._sb = [], h.__h.length && f.push(h);
                break n;
            }
            null != h.componentWillUpdate && h.componentWillUpdate(m, h.__s, $), null != h.componentDidUpdate && h.__h.push(function() {
                h.componentDidUpdate(d, k, b);
            });
        }
        if (h.context = $, h.props = m, h.__P = n, h.__e = !1, S = l.__r, A = 0, "prototype" in T && T.prototype.render) {
            for(h.state = h.__s, h.__d = !1, S && S(u), p = h.render(h.props, h.state, h.context), H = 0; H < h._sb.length; H++)h.__h.push(h._sb[H]);
            h._sb = [];
        } else do {
            h.__d = !1, S && S(u), p = h.render(h.props, h.state, h.context), h.state = h.__s;
        }while (h.__d && ++A < 25);
        h.state = h.__s, null != h.getChildContext && (i = v(v({}, i), h.getChildContext())), y || null == h.getSnapshotBeforeUpdate || (b = h.getSnapshotBeforeUpdate(d, k)), w(n, a(I = null != p && p.type === _ && null == p.key ? p.props.children : p) ? I : [
            I
        ], u, t, i, o, r, f, e, c, s), h.base = u.__e, u.__h = null, h.__h.length && f.push(h), g && (h.__E = h.__ = null);
    } catch (n) {
        u.__v = null, (c || null != r) && (u.__e = e, u.__h = !!c, r[r.indexOf(e)] = null), l.__e(n, u, t);
    }
    else null == r && u.__v === t.__v ? (u.__k = t.__k, u.__e = t.__e) : u.__e = L(t.__e, u, t, i, o, r, f, c, s);
    (p = l.diffed) && p(u);
}
function z(n, u, t) {
    for(var i = 0; i < t.length; i++)M(t[i], t[++i], t[++i]);
    l.__c && l.__c(u, n), n.some(function(u) {
        try {
            n = u.__h, u.__h = [], n.some(function(n) {
                n.call(u);
            });
        } catch (n) {
            l.__e(n, u.__v);
        }
    });
}
function L(l, u, t, i, o, r, f, e, s) {
    var p, v, y, d = t.props, _ = u.props, x = u.type, b = 0;
    if ("svg" === x && (o = !0), null != r) {
        for(; b < r.length; b++)if ((p = r[b]) && "setAttribute" in p == !!x && (x ? p.localName === x : 3 === p.nodeType)) {
            l = p, r[b] = null;
            break;
        }
    }
    if (null == l) {
        if (null === x) return document.createTextNode(_);
        l = o ? document.createElementNS("http://www.w3.org/2000/svg", x) : document.createElement(x, _.is && _), r = null, e = !1;
    }
    if (null === x) d === _ || e && l.data === _ || (l.data = _);
    else {
        if (r = r && n.call(l.childNodes), v = (d = t.props || c).dangerouslySetInnerHTML, y = _.dangerouslySetInnerHTML, !e) {
            if (null != r) for(d = {}, b = 0; b < l.attributes.length; b++)d[l.attributes[b].name] = l.attributes[b].value;
            (y || v) && (y && (v && y.__html == v.__html || y.__html === l.innerHTML) || (l.innerHTML = y && y.__html || ""));
        }
        if (S(l, _, d, o, e), y) u.__k = [];
        else if (w(l, a(b = u.props.children) ? b : [
            b
        ], u, t, i, o && "foreignObject" !== x, r, f, r ? r[0] : t.__k && k(t, 0), e, s), null != r) for(b = r.length; b--;)null != r[b] && h(r[b]);
        e || ("value" in _ && void 0 !== (b = _.value) && (b !== l.value || "progress" === x && !b || "option" === x && b !== d.value) && H(l, "value", b, d.value, !1), "checked" in _ && void 0 !== (b = _.checked) && b !== l.checked && H(l, "checked", b, d.checked, !1));
    }
    return l;
}
function M(n, u, t) {
    try {
        "function" == typeof n ? n(u) : n.current = u;
    } catch (n) {
        l.__e(n, t);
    }
}
function N(n, u, t) {
    var i, o;
    if (l.unmount && l.unmount(n), (i = n.ref) && (i.current && i.current !== n.__e || M(i, null, u)), null != (i = n.__c)) {
        if (i.componentWillUnmount) try {
            i.componentWillUnmount();
        } catch (n) {
            l.__e(n, u);
        }
        i.base = i.__P = null, n.__c = void 0;
    }
    if (i = n.__k) for(o = 0; o < i.length; o++)i[o] && N(i[o], u, t || "function" != typeof n.type);
    t || null == n.__e || h(n.__e), n.__ = n.__e = n.__d = void 0;
}
function O(n, l, u) {
    return this.constructor(n, u);
}
function q(u, t, i) {
    var o, r, f, e;
    l.__ && l.__(u, t), r = (o = "function" == typeof i) ? null : i && i.__k || t.__k, f = [], e = [], j(t, u = (!o && i || t).__k = y(_, null, [
        u
    ]), r || c, c, void 0 !== t.ownerSVGElement, !o && i ? [
        i
    ] : r ? null : t.firstChild ? n.call(t.childNodes) : null, f, !o && i ? i : r ? r.__e : t.firstChild, o, e), z(f, u, e);
}
n = s.slice, l = {
    __e: function(n, l, u, t) {
        for(var i, o, r; l = l.__;)if ((i = l.__c) && !i.__) try {
            if ((o = i.constructor) && null != o.getDerivedStateFromError && (i.setState(o.getDerivedStateFromError(n)), r = i.__d), null != i.componentDidCatch && (i.componentDidCatch(n, t || {}), r = i.__d), r) return i.__E = i;
        } catch (l) {
            n = l;
        }
        throw n;
    }
}, u = 0, t = function(n) {
    return null != n && void 0 === n.constructor;
}, x.prototype.setState = function(n, l) {
    var u;
    u = null != this.__s && this.__s !== this.state ? this.__s : this.__s = v({}, this.state), "function" == typeof n && (n = n(v({}, u), this.props)), n && v(u, n), null != n && this.__v && (l && this._sb.push(l), g(this));
}, x.prototype.forceUpdate = function(n) {
    this.__v && (this.__e = !0, n && this.__h.push(n), g(this));
}, x.prototype.render = _, i = [], r = "function" == typeof Promise ? Promise.prototype.then.bind(Promise.resolve()) : setTimeout, f = function(n, l) {
    return n.__v.__b - l.__v.__b;
}, m.__r = 0, e = 0, exports.Component = x, exports.Fragment = _, exports.cloneElement = function(l, u, t) {
    var i, o, r, f, e = v({}, l.props);
    for(r in l.type && l.type.defaultProps && (f = l.type.defaultProps), u)"key" == r ? i = u[r] : "ref" == r ? o = u[r] : e[r] = void 0 === u[r] && void 0 !== f ? f[r] : u[r];
    return arguments.length > 2 && (e.children = arguments.length > 3 ? n.call(arguments, 2) : t), d(l.type, e, i || l.key, o || l.ref, null);
}, exports.createContext = function(n, l) {
    var u = {
        __c: l = "__cC" + e++,
        __: n,
        Consumer: function(n, l) {
            return n.children(l);
        },
        Provider: function(n) {
            var u, t;
            return this.getChildContext || (u = [], (t = {})[l] = this, this.getChildContext = function() {
                return t;
            }, this.shouldComponentUpdate = function(n) {
                this.props.value !== n.value && u.some(function(n) {
                    n.__e = !0, g(n);
                });
            }, this.sub = function(n) {
                u.push(n);
                var l = n.componentWillUnmount;
                n.componentWillUnmount = function() {
                    u.splice(u.indexOf(n), 1), l && l.call(n);
                };
            }), n.children;
        }
    };
    return u.Provider.__ = u.Consumer.contextType = u;
}, exports.createElement = y, exports.createRef = function() {
    return {
        current: null
    };
}, exports.h = y, exports.hydrate = function n(l, u) {
    q(l, u, n);
}, exports.isValidElement = t, exports.options = l, exports.render = q, exports.toChildArray = function n(l, u) {
    return u = u || [], null == l || "boolean" == typeof l || (a(l) ? l.some(function(l) {
        n(l, u);
    }) : u.push(l)), u;
}; //# sourceMappingURL=preact.js.map


/***/ }),

/***/ 49765:
/***/ ((module, exports, __webpack_require__) => {

"use strict";
/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */ /* eslint-disable node/no-deprecated-api */ 
var buffer = __webpack_require__(14300);
var Buffer = buffer.Buffer;
// alternative to using Object.keys for old browsers
function copyProps(src, dst) {
    for(var key in src){
        dst[key] = src[key];
    }
}
if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
    module.exports = buffer;
} else {
    // Copy properties from require('buffer')
    copyProps(buffer, exports);
    exports.Buffer = SafeBuffer;
}
function SafeBuffer(arg, encodingOrOffset, length) {
    return Buffer(arg, encodingOrOffset, length);
}
SafeBuffer.prototype = Object.create(Buffer.prototype);
// Copy static methods from Buffer
copyProps(Buffer, SafeBuffer);
SafeBuffer.from = function(arg, encodingOrOffset, length) {
    if (typeof arg === "number") {
        throw new TypeError("Argument must not be a number");
    }
    return Buffer(arg, encodingOrOffset, length);
};
SafeBuffer.alloc = function(size, fill, encoding) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    var buf = Buffer(size);
    if (fill !== undefined) {
        if (typeof encoding === "string") {
            buf.fill(fill, encoding);
        } else {
            buf.fill(fill);
        }
    } else {
        buf.fill(0);
    }
    return buf;
};
SafeBuffer.allocUnsafe = function(size) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    return Buffer(size);
};
SafeBuffer.allocUnsafeSlow = function(size) {
    if (typeof size !== "number") {
        throw new TypeError("Argument must be a number");
    }
    return buffer.SlowBuffer(size);
};


/***/ }),

/***/ 53443:
/***/ ((module) => {

"use strict";

function _assertThisInitialized(self) {
    if (self === void 0) {
        throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
    }
    return self;
}
module.exports = _assertThisInitialized, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 70895:
/***/ ((module) => {

"use strict";

function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
    try {
        var info = gen[key](arg);
        var value = info.value;
    } catch (error) {
        reject(error);
        return;
    }
    if (info.done) {
        resolve(value);
    } else {
        Promise.resolve(value).then(_next, _throw);
    }
}
function _asyncToGenerator(fn) {
    return function() {
        var self = this, args = arguments;
        return new Promise(function(resolve, reject) {
            var gen = fn.apply(self, args);
            function _next(value) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
            }
            function _throw(err) {
                asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
            }
            _next(undefined);
        });
    };
}
module.exports = _asyncToGenerator, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 21656:
/***/ ((module) => {

"use strict";

function _classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
        throw new TypeError("Cannot call a class as a function");
    }
}
module.exports = _classCallCheck, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 61975:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var setPrototypeOf = __webpack_require__(96542);
var isNativeReflectConstruct = __webpack_require__(31272);
function _construct(Parent, args, Class) {
    if (isNativeReflectConstruct()) {
        module.exports = _construct = Reflect.construct.bind(), module.exports.__esModule = true, module.exports["default"] = module.exports;
    } else {
        module.exports = _construct = function _construct(Parent, args, Class) {
            var a = [
                null
            ];
            a.push.apply(a, args);
            var Constructor = Function.bind.apply(Parent, a);
            var instance = new Constructor();
            if (Class) setPrototypeOf(instance, Class.prototype);
            return instance;
        }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    }
    return _construct.apply(null, arguments);
}
module.exports = _construct, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 73381:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPropertyKey = __webpack_require__(31761);
function _defineProperties(target, props) {
    for(var i = 0; i < props.length; i++){
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, toPropertyKey(descriptor.key), descriptor);
    }
}
function _createClass(Constructor, protoProps, staticProps) {
    if (protoProps) _defineProperties(Constructor.prototype, protoProps);
    if (staticProps) _defineProperties(Constructor, staticProps);
    Object.defineProperty(Constructor, "prototype", {
        writable: false
    });
    return Constructor;
}
module.exports = _createClass, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 97662:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var toPropertyKey = __webpack_require__(31761);
function _defineProperty(obj, key, value) {
    key = toPropertyKey(key);
    if (key in obj) {
        Object.defineProperty(obj, key, {
            value: value,
            enumerable: true,
            configurable: true,
            writable: true
        });
    } else {
        obj[key] = value;
    }
    return obj;
}
module.exports = _defineProperty, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 33911:
/***/ ((module) => {

"use strict";

function _extends() {
    module.exports = _extends = Object.assign ? Object.assign.bind() : function(target) {
        for(var i = 1; i < arguments.length; i++){
            var source = arguments[i];
            for(var key in source){
                if (Object.prototype.hasOwnProperty.call(source, key)) {
                    target[key] = source[key];
                }
            }
        }
        return target;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _extends.apply(this, arguments);
}
module.exports = _extends, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 31212:
/***/ ((module) => {

"use strict";

function _getPrototypeOf(o) {
    module.exports = _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf.bind() : function _getPrototypeOf(o) {
        return o.__proto__ || Object.getPrototypeOf(o);
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _getPrototypeOf(o);
}
module.exports = _getPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 63160:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var setPrototypeOf = __webpack_require__(96542);
function _inherits(subClass, superClass) {
    if (typeof superClass !== "function" && superClass !== null) {
        throw new TypeError("Super expression must either be null or a function");
    }
    subClass.prototype = Object.create(superClass && superClass.prototype, {
        constructor: {
            value: subClass,
            writable: true,
            configurable: true
        }
    });
    Object.defineProperty(subClass, "prototype", {
        writable: false
    });
    if (superClass) setPrototypeOf(subClass, superClass);
}
module.exports = _inherits, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 511:
/***/ ((module) => {

"use strict";

function _isNativeFunction(fn) {
    return Function.toString.call(fn).indexOf("[native code]") !== -1;
}
module.exports = _isNativeFunction, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 31272:
/***/ ((module) => {

"use strict";

function _isNativeReflectConstruct() {
    if (typeof Reflect === "undefined" || !Reflect.construct) return false;
    if (Reflect.construct.sham) return false;
    if (typeof Proxy === "function") return true;
    try {
        Boolean.prototype.valueOf.call(Reflect.construct(Boolean, [], function() {}));
        return true;
    } catch (e) {
        return false;
    }
}
module.exports = _isNativeReflectConstruct, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 31582:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var _typeof = (__webpack_require__(55860)["default"]);
var assertThisInitialized = __webpack_require__(53443);
function _possibleConstructorReturn(self, call) {
    if (call && (_typeof(call) === "object" || typeof call === "function")) {
        return call;
    } else if (call !== void 0) {
        throw new TypeError("Derived constructors may only return object or undefined");
    }
    return assertThisInitialized(self);
}
module.exports = _possibleConstructorReturn, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 46620:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var _typeof = (__webpack_require__(55860)["default"]);
function _regeneratorRuntime() {
    "use strict"; /*! regenerator-runtime -- Copyright (c) 2014-present, Facebook, Inc. -- license (MIT): https://github.com/facebook/regenerator/blob/main/LICENSE */ 
    module.exports = _regeneratorRuntime = function _regeneratorRuntime() {
        return exports;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    var exports = {}, Op = Object.prototype, hasOwn = Op.hasOwnProperty, defineProperty = Object.defineProperty || function(obj, key, desc) {
        obj[key] = desc.value;
    }, $Symbol = "function" == typeof Symbol ? Symbol : {}, iteratorSymbol = $Symbol.iterator || "@@iterator", asyncIteratorSymbol = $Symbol.asyncIterator || "@@asyncIterator", toStringTagSymbol = $Symbol.toStringTag || "@@toStringTag";
    function define(obj, key, value) {
        return Object.defineProperty(obj, key, {
            value: value,
            enumerable: !0,
            configurable: !0,
            writable: !0
        }), obj[key];
    }
    try {
        define({}, "");
    } catch (err) {
        define = function define(obj, key, value) {
            return obj[key] = value;
        };
    }
    function wrap(innerFn, outerFn, self, tryLocsList) {
        var protoGenerator = outerFn && outerFn.prototype instanceof Generator ? outerFn : Generator, generator = Object.create(protoGenerator.prototype), context = new Context(tryLocsList || []);
        return defineProperty(generator, "_invoke", {
            value: makeInvokeMethod(innerFn, self, context)
        }), generator;
    }
    function tryCatch(fn, obj, arg) {
        try {
            return {
                type: "normal",
                arg: fn.call(obj, arg)
            };
        } catch (err) {
            return {
                type: "throw",
                arg: err
            };
        }
    }
    exports.wrap = wrap;
    var ContinueSentinel = {};
    function Generator() {}
    function GeneratorFunction() {}
    function GeneratorFunctionPrototype() {}
    var IteratorPrototype = {};
    define(IteratorPrototype, iteratorSymbol, function() {
        return this;
    });
    var getProto = Object.getPrototypeOf, NativeIteratorPrototype = getProto && getProto(getProto(values([])));
    NativeIteratorPrototype && NativeIteratorPrototype !== Op && hasOwn.call(NativeIteratorPrototype, iteratorSymbol) && (IteratorPrototype = NativeIteratorPrototype);
    var Gp = GeneratorFunctionPrototype.prototype = Generator.prototype = Object.create(IteratorPrototype);
    function defineIteratorMethods(prototype) {
        [
            "next",
            "throw",
            "return"
        ].forEach(function(method) {
            define(prototype, method, function(arg) {
                return this._invoke(method, arg);
            });
        });
    }
    function AsyncIterator(generator, PromiseImpl) {
        function invoke(method, arg, resolve, reject) {
            var record = tryCatch(generator[method], generator, arg);
            if ("throw" !== record.type) {
                var result = record.arg, value = result.value;
                return value && "object" == _typeof(value) && hasOwn.call(value, "__await") ? PromiseImpl.resolve(value.__await).then(function(value) {
                    invoke("next", value, resolve, reject);
                }, function(err) {
                    invoke("throw", err, resolve, reject);
                }) : PromiseImpl.resolve(value).then(function(unwrapped) {
                    result.value = unwrapped, resolve(result);
                }, function(error) {
                    return invoke("throw", error, resolve, reject);
                });
            }
            reject(record.arg);
        }
        var previousPromise;
        defineProperty(this, "_invoke", {
            value: function value(method, arg) {
                function callInvokeWithMethodAndArg() {
                    return new PromiseImpl(function(resolve, reject) {
                        invoke(method, arg, resolve, reject);
                    });
                }
                return previousPromise = previousPromise ? previousPromise.then(callInvokeWithMethodAndArg, callInvokeWithMethodAndArg) : callInvokeWithMethodAndArg();
            }
        });
    }
    function makeInvokeMethod(innerFn, self, context) {
        var state = "suspendedStart";
        return function(method, arg) {
            if ("executing" === state) throw new Error("Generator is already running");
            if ("completed" === state) {
                if ("throw" === method) throw arg;
                return doneResult();
            }
            for(context.method = method, context.arg = arg;;){
                var delegate = context.delegate;
                if (delegate) {
                    var delegateResult = maybeInvokeDelegate(delegate, context);
                    if (delegateResult) {
                        if (delegateResult === ContinueSentinel) continue;
                        return delegateResult;
                    }
                }
                if ("next" === context.method) context.sent = context._sent = context.arg;
                else if ("throw" === context.method) {
                    if ("suspendedStart" === state) throw state = "completed", context.arg;
                    context.dispatchException(context.arg);
                } else "return" === context.method && context.abrupt("return", context.arg);
                state = "executing";
                var record = tryCatch(innerFn, self, context);
                if ("normal" === record.type) {
                    if (state = context.done ? "completed" : "suspendedYield", record.arg === ContinueSentinel) continue;
                    return {
                        value: record.arg,
                        done: context.done
                    };
                }
                "throw" === record.type && (state = "completed", context.method = "throw", context.arg = record.arg);
            }
        };
    }
    function maybeInvokeDelegate(delegate, context) {
        var methodName = context.method, method = delegate.iterator[methodName];
        if (undefined === method) return context.delegate = null, "throw" === methodName && delegate.iterator["return"] && (context.method = "return", context.arg = undefined, maybeInvokeDelegate(delegate, context), "throw" === context.method) || "return" !== methodName && (context.method = "throw", context.arg = new TypeError("The iterator does not provide a '" + methodName + "' method")), ContinueSentinel;
        var record = tryCatch(method, delegate.iterator, context.arg);
        if ("throw" === record.type) return context.method = "throw", context.arg = record.arg, context.delegate = null, ContinueSentinel;
        var info = record.arg;
        return info ? info.done ? (context[delegate.resultName] = info.value, context.next = delegate.nextLoc, "return" !== context.method && (context.method = "next", context.arg = undefined), context.delegate = null, ContinueSentinel) : info : (context.method = "throw", context.arg = new TypeError("iterator result is not an object"), context.delegate = null, ContinueSentinel);
    }
    function pushTryEntry(locs) {
        var entry = {
            tryLoc: locs[0]
        };
        1 in locs && (entry.catchLoc = locs[1]), 2 in locs && (entry.finallyLoc = locs[2], entry.afterLoc = locs[3]), this.tryEntries.push(entry);
    }
    function resetTryEntry(entry) {
        var record = entry.completion || {};
        record.type = "normal", delete record.arg, entry.completion = record;
    }
    function Context(tryLocsList) {
        this.tryEntries = [
            {
                tryLoc: "root"
            }
        ], tryLocsList.forEach(pushTryEntry, this), this.reset(!0);
    }
    function values(iterable) {
        if (iterable) {
            var iteratorMethod = iterable[iteratorSymbol];
            if (iteratorMethod) return iteratorMethod.call(iterable);
            if ("function" == typeof iterable.next) return iterable;
            if (!isNaN(iterable.length)) {
                var i = -1, next = function next() {
                    for(; ++i < iterable.length;)if (hasOwn.call(iterable, i)) return next.value = iterable[i], next.done = !1, next;
                    return next.value = undefined, next.done = !0, next;
                };
                return next.next = next;
            }
        }
        return {
            next: doneResult
        };
    }
    function doneResult() {
        return {
            value: undefined,
            done: !0
        };
    }
    return GeneratorFunction.prototype = GeneratorFunctionPrototype, defineProperty(Gp, "constructor", {
        value: GeneratorFunctionPrototype,
        configurable: !0
    }), defineProperty(GeneratorFunctionPrototype, "constructor", {
        value: GeneratorFunction,
        configurable: !0
    }), GeneratorFunction.displayName = define(GeneratorFunctionPrototype, toStringTagSymbol, "GeneratorFunction"), exports.isGeneratorFunction = function(genFun) {
        var ctor = "function" == typeof genFun && genFun.constructor;
        return !!ctor && (ctor === GeneratorFunction || "GeneratorFunction" === (ctor.displayName || ctor.name));
    }, exports.mark = function(genFun) {
        return Object.setPrototypeOf ? Object.setPrototypeOf(genFun, GeneratorFunctionPrototype) : (genFun.__proto__ = GeneratorFunctionPrototype, define(genFun, toStringTagSymbol, "GeneratorFunction")), genFun.prototype = Object.create(Gp), genFun;
    }, exports.awrap = function(arg) {
        return {
            __await: arg
        };
    }, defineIteratorMethods(AsyncIterator.prototype), define(AsyncIterator.prototype, asyncIteratorSymbol, function() {
        return this;
    }), exports.AsyncIterator = AsyncIterator, exports.async = function(innerFn, outerFn, self, tryLocsList, PromiseImpl) {
        void 0 === PromiseImpl && (PromiseImpl = Promise);
        var iter = new AsyncIterator(wrap(innerFn, outerFn, self, tryLocsList), PromiseImpl);
        return exports.isGeneratorFunction(outerFn) ? iter : iter.next().then(function(result) {
            return result.done ? result.value : iter.next();
        });
    }, defineIteratorMethods(Gp), define(Gp, toStringTagSymbol, "Generator"), define(Gp, iteratorSymbol, function() {
        return this;
    }), define(Gp, "toString", function() {
        return "[object Generator]";
    }), exports.keys = function(val) {
        var object = Object(val), keys = [];
        for(var key in object)keys.push(key);
        return keys.reverse(), function next() {
            for(; keys.length;){
                var key = keys.pop();
                if (key in object) return next.value = key, next.done = !1, next;
            }
            return next.done = !0, next;
        };
    }, exports.values = values, Context.prototype = {
        constructor: Context,
        reset: function reset(skipTempReset) {
            if (this.prev = 0, this.next = 0, this.sent = this._sent = undefined, this.done = !1, this.delegate = null, this.method = "next", this.arg = undefined, this.tryEntries.forEach(resetTryEntry), !skipTempReset) for(var name in this)"t" === name.charAt(0) && hasOwn.call(this, name) && !isNaN(+name.slice(1)) && (this[name] = undefined);
        },
        stop: function stop() {
            this.done = !0;
            var rootRecord = this.tryEntries[0].completion;
            if ("throw" === rootRecord.type) throw rootRecord.arg;
            return this.rval;
        },
        dispatchException: function dispatchException(exception) {
            if (this.done) throw exception;
            var context = this;
            function handle(loc, caught) {
                return record.type = "throw", record.arg = exception, context.next = loc, caught && (context.method = "next", context.arg = undefined), !!caught;
            }
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i], record = entry.completion;
                if ("root" === entry.tryLoc) return handle("end");
                if (entry.tryLoc <= this.prev) {
                    var hasCatch = hasOwn.call(entry, "catchLoc"), hasFinally = hasOwn.call(entry, "finallyLoc");
                    if (hasCatch && hasFinally) {
                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                        if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                    } else if (hasCatch) {
                        if (this.prev < entry.catchLoc) return handle(entry.catchLoc, !0);
                    } else {
                        if (!hasFinally) throw new Error("try statement without catch or finally");
                        if (this.prev < entry.finallyLoc) return handle(entry.finallyLoc);
                    }
                }
            }
        },
        abrupt: function abrupt(type, arg) {
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i];
                if (entry.tryLoc <= this.prev && hasOwn.call(entry, "finallyLoc") && this.prev < entry.finallyLoc) {
                    var finallyEntry = entry;
                    break;
                }
            }
            finallyEntry && ("break" === type || "continue" === type) && finallyEntry.tryLoc <= arg && arg <= finallyEntry.finallyLoc && (finallyEntry = null);
            var record = finallyEntry ? finallyEntry.completion : {};
            return record.type = type, record.arg = arg, finallyEntry ? (this.method = "next", this.next = finallyEntry.finallyLoc, ContinueSentinel) : this.complete(record);
        },
        complete: function complete(record, afterLoc) {
            if ("throw" === record.type) throw record.arg;
            return "break" === record.type || "continue" === record.type ? this.next = record.arg : "return" === record.type ? (this.rval = this.arg = record.arg, this.method = "return", this.next = "end") : "normal" === record.type && afterLoc && (this.next = afterLoc), ContinueSentinel;
        },
        finish: function finish(finallyLoc) {
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i];
                if (entry.finallyLoc === finallyLoc) return this.complete(entry.completion, entry.afterLoc), resetTryEntry(entry), ContinueSentinel;
            }
        },
        "catch": function _catch(tryLoc) {
            for(var i = this.tryEntries.length - 1; i >= 0; --i){
                var entry = this.tryEntries[i];
                if (entry.tryLoc === tryLoc) {
                    var record = entry.completion;
                    if ("throw" === record.type) {
                        var thrown = record.arg;
                        resetTryEntry(entry);
                    }
                    return thrown;
                }
            }
            throw new Error("illegal catch attempt");
        },
        delegateYield: function delegateYield(iterable, resultName, nextLoc) {
            return this.delegate = {
                iterator: values(iterable),
                resultName: resultName,
                nextLoc: nextLoc
            }, "next" === this.method && (this.arg = undefined), ContinueSentinel;
        }
    }, exports;
}
module.exports = _regeneratorRuntime, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 96542:
/***/ ((module) => {

"use strict";

function _setPrototypeOf(o, p) {
    module.exports = _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {
        o.__proto__ = p;
        return o;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _setPrototypeOf(o, p);
}
module.exports = _setPrototypeOf, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 30836:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var _typeof = (__webpack_require__(55860)["default"]);
function _toPrimitive(input, hint) {
    if (_typeof(input) !== "object" || input === null) return input;
    var prim = input[Symbol.toPrimitive];
    if (prim !== undefined) {
        var res = prim.call(input, hint || "default");
        if (_typeof(res) !== "object") return res;
        throw new TypeError("@@toPrimitive must return a primitive value.");
    }
    return (hint === "string" ? String : Number)(input);
}
module.exports = _toPrimitive, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 31761:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var _typeof = (__webpack_require__(55860)["default"]);
var toPrimitive = __webpack_require__(30836);
function _toPropertyKey(arg) {
    var key = toPrimitive(arg, "string");
    return _typeof(key) === "symbol" ? key : String(key);
}
module.exports = _toPropertyKey, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 55860:
/***/ ((module) => {

"use strict";

function _typeof(obj) {
    "@babel/helpers - typeof";
    return module.exports = _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function(obj) {
        return typeof obj;
    } : function(obj) {
        return obj && "function" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj;
    }, module.exports.__esModule = true, module.exports["default"] = module.exports, _typeof(obj);
}
module.exports = _typeof, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 27977:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";

var getPrototypeOf = __webpack_require__(31212);
var setPrototypeOf = __webpack_require__(96542);
var isNativeFunction = __webpack_require__(511);
var construct = __webpack_require__(61975);
function _wrapNativeSuper(Class) {
    var _cache = typeof Map === "function" ? new Map() : undefined;
    module.exports = _wrapNativeSuper = function _wrapNativeSuper(Class) {
        if (Class === null || !isNativeFunction(Class)) return Class;
        if (typeof Class !== "function") {
            throw new TypeError("Super expression must either be null or a function");
        }
        if (typeof _cache !== "undefined") {
            if (_cache.has(Class)) return _cache.get(Class);
            _cache.set(Class, Wrapper);
        }
        function Wrapper() {
            return construct(Class, arguments, getPrototypeOf(this).constructor);
        }
        Wrapper.prototype = Object.create(Class.prototype, {
            constructor: {
                value: Wrapper,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        return setPrototypeOf(Wrapper, Class);
    }, module.exports.__esModule = true, module.exports["default"] = module.exports;
    return _wrapNativeSuper(Class);
}
module.exports = _wrapNativeSuper, module.exports.__esModule = true, module.exports["default"] = module.exports;


/***/ }),

/***/ 86721:
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
// TODO(Babel 8): Remove this file.

var runtime = __webpack_require__(46620)();
module.exports = runtime;
// Copied from https://github.com/facebook/regenerator/blob/main/packages/runtime/runtime.js#L736=
try {
    regeneratorRuntime = runtime;
} catch (accidentalStrictMode) {
    if (typeof globalThis === "object") {
        globalThis.regeneratorRuntime = runtime;
    } else {
        Function("r", "regeneratorRuntime = r")(runtime);
    }
}


/***/ }),

/***/ 21972:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-sso","description":"AWS SDK for JavaScript Sso Client for Node.js, Browser and React Native","version":"3.405.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:docs":"typedoc","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","extract:docs":"api-extractor run --local","generate:client":"node ../../scripts/generate-clients/single-service --solo sso"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"3.0.0","@aws-crypto/sha256-js":"3.0.0","@aws-sdk/middleware-host-header":"3.398.0","@aws-sdk/middleware-logger":"3.398.0","@aws-sdk/middleware-recursion-detection":"3.398.0","@aws-sdk/middleware-user-agent":"3.398.0","@aws-sdk/types":"3.398.0","@aws-sdk/util-endpoints":"3.398.0","@aws-sdk/util-user-agent-browser":"3.398.0","@aws-sdk/util-user-agent-node":"3.405.0","@smithy/config-resolver":"^2.0.5","@smithy/fetch-http-handler":"^2.0.5","@smithy/hash-node":"^2.0.5","@smithy/invalid-dependency":"^2.0.5","@smithy/middleware-content-length":"^2.0.5","@smithy/middleware-endpoint":"^2.0.5","@smithy/middleware-retry":"^2.0.5","@smithy/middleware-serde":"^2.0.5","@smithy/middleware-stack":"^2.0.0","@smithy/node-config-provider":"^2.0.6","@smithy/node-http-handler":"^2.0.5","@smithy/protocol-http":"^2.0.5","@smithy/smithy-client":"^2.0.5","@smithy/types":"^2.2.2","@smithy/url-parser":"^2.0.5","@smithy/util-base64":"^2.0.0","@smithy/util-body-length-browser":"^2.0.0","@smithy/util-body-length-node":"^2.1.0","@smithy/util-defaults-mode-browser":"^2.0.6","@smithy/util-defaults-mode-node":"^2.0.6","@smithy/util-retry":"^2.0.0","@smithy/util-utf8":"^2.0.0","tslib":"^2.5.0"},"devDependencies":{"@smithy/service-client-documentation-generator":"^2.0.0","@tsconfig/node14":"1.0.3","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typedoc":"0.23.23","typescript":"~4.9.5"},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*/**"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sso","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-sso"}}');

/***/ }),

/***/ 41657:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-sts","description":"AWS SDK for JavaScript Sts Client for Node.js, Browser and React Native","version":"3.405.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:docs":"typedoc","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","extract:docs":"api-extractor run --local","generate:client":"node ../../scripts/generate-clients/single-service --solo sts","test":"yarn test:unit","test:unit":"jest"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"3.0.0","@aws-crypto/sha256-js":"3.0.0","@aws-sdk/credential-provider-node":"3.405.0","@aws-sdk/middleware-host-header":"3.398.0","@aws-sdk/middleware-logger":"3.398.0","@aws-sdk/middleware-recursion-detection":"3.398.0","@aws-sdk/middleware-sdk-sts":"3.398.0","@aws-sdk/middleware-signing":"3.398.0","@aws-sdk/middleware-user-agent":"3.398.0","@aws-sdk/types":"3.398.0","@aws-sdk/util-endpoints":"3.398.0","@aws-sdk/util-user-agent-browser":"3.398.0","@aws-sdk/util-user-agent-node":"3.405.0","@smithy/config-resolver":"^2.0.5","@smithy/fetch-http-handler":"^2.0.5","@smithy/hash-node":"^2.0.5","@smithy/invalid-dependency":"^2.0.5","@smithy/middleware-content-length":"^2.0.5","@smithy/middleware-endpoint":"^2.0.5","@smithy/middleware-retry":"^2.0.5","@smithy/middleware-serde":"^2.0.5","@smithy/middleware-stack":"^2.0.0","@smithy/node-config-provider":"^2.0.6","@smithy/node-http-handler":"^2.0.5","@smithy/protocol-http":"^2.0.5","@smithy/smithy-client":"^2.0.5","@smithy/types":"^2.2.2","@smithy/url-parser":"^2.0.5","@smithy/util-base64":"^2.0.0","@smithy/util-body-length-browser":"^2.0.0","@smithy/util-body-length-node":"^2.1.0","@smithy/util-defaults-mode-browser":"^2.0.6","@smithy/util-defaults-mode-node":"^2.0.6","@smithy/util-retry":"^2.0.0","@smithy/util-utf8":"^2.0.0","fast-xml-parser":"4.2.5","tslib":"^2.5.0"},"devDependencies":{"@smithy/service-client-documentation-generator":"^2.0.0","@tsconfig/node14":"1.0.3","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typedoc":"0.23.23","typescript":"~4.9.5"},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*/**"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-sts","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-sts"}}');

/***/ }),

/***/ 22385:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"partitions":[{"id":"aws","outputs":{"dnsSuffix":"amazonaws.com","dualStackDnsSuffix":"api.aws","name":"aws","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^(us|eu|ap|sa|ca|me|af|il)\\\\-\\\\w+\\\\-\\\\d+$","regions":{"af-south-1":{"description":"Africa (Cape Town)"},"ap-east-1":{"description":"Asia Pacific (Hong Kong)"},"ap-northeast-1":{"description":"Asia Pacific (Tokyo)"},"ap-northeast-2":{"description":"Asia Pacific (Seoul)"},"ap-northeast-3":{"description":"Asia Pacific (Osaka)"},"ap-south-1":{"description":"Asia Pacific (Mumbai)"},"ap-south-2":{"description":"Asia Pacific (Hyderabad)"},"ap-southeast-1":{"description":"Asia Pacific (Singapore)"},"ap-southeast-2":{"description":"Asia Pacific (Sydney)"},"ap-southeast-3":{"description":"Asia Pacific (Jakarta)"},"ap-southeast-4":{"description":"Asia Pacific (Melbourne)"},"aws-global":{"description":"AWS Standard global region"},"ca-central-1":{"description":"Canada (Central)"},"eu-central-1":{"description":"Europe (Frankfurt)"},"eu-central-2":{"description":"Europe (Zurich)"},"eu-north-1":{"description":"Europe (Stockholm)"},"eu-south-1":{"description":"Europe (Milan)"},"eu-south-2":{"description":"Europe (Spain)"},"eu-west-1":{"description":"Europe (Ireland)"},"eu-west-2":{"description":"Europe (London)"},"eu-west-3":{"description":"Europe (Paris)"},"il-central-1":{"description":"Israel (Tel Aviv)"},"me-central-1":{"description":"Middle East (UAE)"},"me-south-1":{"description":"Middle East (Bahrain)"},"sa-east-1":{"description":"South America (Sao Paulo)"},"us-east-1":{"description":"US East (N. Virginia)"},"us-east-2":{"description":"US East (Ohio)"},"us-west-1":{"description":"US West (N. California)"},"us-west-2":{"description":"US West (Oregon)"}}},{"id":"aws-cn","outputs":{"dnsSuffix":"amazonaws.com.cn","dualStackDnsSuffix":"api.amazonwebservices.com.cn","name":"aws-cn","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^cn\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-cn-global":{"description":"AWS China global region"},"cn-north-1":{"description":"China (Beijing)"},"cn-northwest-1":{"description":"China (Ningxia)"}}},{"id":"aws-us-gov","outputs":{"dnsSuffix":"amazonaws.com","dualStackDnsSuffix":"api.aws","name":"aws-us-gov","supportsDualStack":true,"supportsFIPS":true},"regionRegex":"^us\\\\-gov\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-us-gov-global":{"description":"AWS GovCloud (US) global region"},"us-gov-east-1":{"description":"AWS GovCloud (US-East)"},"us-gov-west-1":{"description":"AWS GovCloud (US-West)"}}},{"id":"aws-iso","outputs":{"dnsSuffix":"c2s.ic.gov","dualStackDnsSuffix":"c2s.ic.gov","name":"aws-iso","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^us\\\\-iso\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-iso-global":{"description":"AWS ISO (US) global region"},"us-iso-east-1":{"description":"US ISO East"},"us-iso-west-1":{"description":"US ISO WEST"}}},{"id":"aws-iso-b","outputs":{"dnsSuffix":"sc2s.sgov.gov","dualStackDnsSuffix":"sc2s.sgov.gov","name":"aws-iso-b","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^us\\\\-isob\\\\-\\\\w+\\\\-\\\\d+$","regions":{"aws-iso-b-global":{"description":"AWS ISOB (US) global region"},"us-isob-east-1":{"description":"US ISOB East (Ohio)"}}},{"id":"aws-iso-e","outputs":{"dnsSuffix":"cloud.adc-e.uk","dualStackDnsSuffix":"cloud.adc-e.uk","name":"aws-iso-e","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^eu\\\\-isoe\\\\-\\\\w+\\\\-\\\\d+$","regions":{}},{"id":"aws-iso-f","outputs":{"dnsSuffix":"csp.hci.ic.gov","dualStackDnsSuffix":"csp.hci.ic.gov","name":"aws-iso-f","supportsDualStack":false,"supportsFIPS":true},"regionRegex":"^us\\\\-isof\\\\-\\\\w+\\\\-\\\\d+$","regions":{}}],"version":"1.1"}');

/***/ }),

/***/ 21467:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"@aws-sdk/client-cognito-identity-provider","description":"AWS SDK for JavaScript Cognito Identity Provider Client for Node.js, Browser and React Native","version":"3.405.0","scripts":{"build":"concurrently \'yarn:build:cjs\' \'yarn:build:es\' \'yarn:build:types\'","build:cjs":"tsc -p tsconfig.cjs.json","build:docs":"typedoc","build:es":"tsc -p tsconfig.es.json","build:include:deps":"lerna run --scope $npm_package_name --include-dependencies build","build:types":"tsc -p tsconfig.types.json","build:types:downlevel":"downlevel-dts dist-types dist-types/ts3.4","clean":"rimraf ./dist-* && rimraf *.tsbuildinfo","extract:docs":"api-extractor run --local","generate:client":"node ../../scripts/generate-clients/single-service --solo cognito-identity-provider"},"main":"./dist-cjs/index.js","types":"./dist-types/index.d.ts","module":"./dist-es/index.js","sideEffects":false,"dependencies":{"@aws-crypto/sha256-browser":"3.0.0","@aws-crypto/sha256-js":"3.0.0","@aws-sdk/client-sts":"3.405.0","@aws-sdk/credential-provider-node":"3.405.0","@aws-sdk/middleware-host-header":"3.398.0","@aws-sdk/middleware-logger":"3.398.0","@aws-sdk/middleware-recursion-detection":"3.398.0","@aws-sdk/middleware-signing":"3.398.0","@aws-sdk/middleware-user-agent":"3.398.0","@aws-sdk/types":"3.398.0","@aws-sdk/util-endpoints":"3.398.0","@aws-sdk/util-user-agent-browser":"3.398.0","@aws-sdk/util-user-agent-node":"3.405.0","@smithy/config-resolver":"^2.0.5","@smithy/fetch-http-handler":"^2.0.5","@smithy/hash-node":"^2.0.5","@smithy/invalid-dependency":"^2.0.5","@smithy/middleware-content-length":"^2.0.5","@smithy/middleware-endpoint":"^2.0.5","@smithy/middleware-retry":"^2.0.5","@smithy/middleware-serde":"^2.0.5","@smithy/middleware-stack":"^2.0.0","@smithy/node-config-provider":"^2.0.6","@smithy/node-http-handler":"^2.0.5","@smithy/protocol-http":"^2.0.5","@smithy/smithy-client":"^2.0.5","@smithy/types":"^2.2.2","@smithy/url-parser":"^2.0.5","@smithy/util-base64":"^2.0.0","@smithy/util-body-length-browser":"^2.0.0","@smithy/util-body-length-node":"^2.1.0","@smithy/util-defaults-mode-browser":"^2.0.6","@smithy/util-defaults-mode-node":"^2.0.6","@smithy/util-retry":"^2.0.0","@smithy/util-utf8":"^2.0.0","tslib":"^2.5.0"},"devDependencies":{"@smithy/service-client-documentation-generator":"^2.0.0","@tsconfig/node14":"1.0.3","@types/node":"^14.14.31","concurrently":"7.0.0","downlevel-dts":"0.10.1","rimraf":"3.0.2","typedoc":"0.23.23","typescript":"~4.9.5"},"engines":{"node":">=14.0.0"},"typesVersions":{"<4.0":{"dist-types/*":["dist-types/ts3.4/*"]}},"files":["dist-*/**"],"author":{"name":"AWS SDK for JavaScript Team","url":"https://aws.amazon.com/javascript/"},"license":"Apache-2.0","browser":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.browser"},"react-native":{"./dist-es/runtimeConfig":"./dist-es/runtimeConfig.native"},"homepage":"https://github.com/aws/aws-sdk-js-v3/tree/main/clients/client-cognito-identity-provider","repository":{"type":"git","url":"https://github.com/aws/aws-sdk-js-v3.git","directory":"clients/client-cognito-identity-provider"}}');

/***/ }),

/***/ 84659:
/***/ ((module) => {

"use strict";
module.exports = JSON.parse('{"name":"openid-client","version":"5.4.3","description":"OpenID Connect Relying Party (RP, Client) implementation for Node.js runtime, supports passportjs","keywords":["auth","authentication","basic","certified","client","connect","dynamic","electron","hybrid","identity","implicit","oauth","oauth2","oidc","openid","passport","relying party","strategy"],"homepage":"https://github.com/panva/node-openid-client","repository":"panva/node-openid-client","funding":{"url":"https://github.com/sponsors/panva"},"license":"MIT","author":"Filip Skokan <panva.ip@gmail.com>","exports":{"types":"./types/index.d.ts","import":"./lib/index.mjs","require":"./lib/index.js"},"main":"./lib/index.js","types":"./types/index.d.ts","files":["lib","types/index.d.ts"],"scripts":{"format":"npx prettier --loglevel silent --write ./lib ./test ./certification ./types","test":"mocha test/**/*.test.js"},"dependencies":{"jose":"^4.14.4","lru-cache":"^6.0.0","object-hash":"^2.2.0","oidc-token-hash":"^5.0.3"},"devDependencies":{"@types/node":"^16.18.31","@types/passport":"^1.0.12","base64url":"^3.0.1","chai":"^4.3.7","jose2":"npm:jose@^2.0.6","mocha":"^10.2.0","nock":"^13.3.1","prettier":"^2.8.8","readable-mock-req":"^0.2.2","sinon":"^9.2.4","timekeeper":"^2.2.0"},"standard-version":{"scripts":{"postchangelog":"sed -i \'\' -e \'s/### \\\\[/## [/g\' CHANGELOG.md"},"types":[{"type":"feat","section":"Features"},{"type":"fix","section":"Fixes"},{"type":"chore","hidden":true},{"type":"docs","hidden":true},{"type":"style","hidden":true},{"type":"refactor","section":"Refactor","hidden":false},{"type":"perf","section":"Performance","hidden":false},{"type":"test","hidden":true}]}}');

/***/ })

};
;